var relearn_searchindex = [
  {
    "breadcrumb": "技术博客 | 智能物联时代",
    "content": "4.自定义页面以康奈尔笔记格式输出\r3.github和atomgit的混合使用，哪些是值得注意的？\r2.git与github的使用\r1.博客优化笔记\r7.初次安装AD需要做哪些设置？\r6.云端一体化的环境变量问题\r5.云端一体化如何查看云函数日志？\r8.如何用旧电脑搭建自己的服务器？\r10.如何自定义hugo主题页面输出格式？\r常用的数学表达\n常用箭头\n常用函数图像公式",
    "description": "4.自定义页面以康奈尔笔记格式输出\r3.github和atomgit的混合使用，哪些是值得注意的？\r2.git与github的使用\r1.博客优化笔记\r7.初次安装AD需要做哪些设置？\r6.云端一体化的环境变量问题\r5.云端一体化如何查看云函数日志？\r8.如何用旧电脑搭建自己的服务器？\r10.如何自定义hugo主题页面输出格式？\r常用的数学表达\n常用箭头\n常用函数图像公式",
    "tags": [],
    "title": "  博客文章",
    "uri": "/log/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r计算机组成原理",
    "content": "",
    "description": "",
    "tags": [],
    "title": "过年",
    "uri": "/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%87%E5%B9%B4/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代",
    "content": "17.C加加编程\r15.计算机图形学OpenGL与C++\r14.新标准C加加程序设计\r13.从C到C++\r12.其他库的介绍\r11.STL库学习之适配器\r10.STL库学习之仿函数\r9.STL库学习之迭代器与算法\r8.STL库学习之容器\r7.STL库学习之分配器\r6.STL库学习之筑基概要\r5.STL库之观其大略\r4.C++2.0特性的使用\r3.导读\r2.组合与继承\r1.代码编写规范\r21.C语言程序设计（含面试）\r1.在线题库练习\r20.C++面试\r1.网络编程\r1.代码编写规范\r嵌入式系统设计知识点\rArkTS\r电子电路\r模拟电子技术基础笔记\r操作系统\rLinux期末复习\rAndroidStudio\rAndroidStudio\rAndroidStudio笔记\r2-1.Toolbar工具栏\r计算机组成原理\r过年\r计算机组成原理-复习\r51单片机\rpretues+kiel5仿真软件配合使用时需要注意的地方\r19.设计模式（C++）",
    "description": "17.C加加编程\r15.计算机图形学OpenGL与C++\r14.新标准C加加程序设计\r13.从C到C++\r12.其他库的介绍\r11.STL库学习之适配器\r10.STL库学习之仿函数\r9.STL库学习之迭代器与算法\r8.STL库学习之容器\r7.STL库学习之分配器\r6.STL库学习之筑基概要\r5.STL库之观其大略\r4.C++2.0特性的使用\r3.导读\r2.组合与继承\r1.代码编写规范\r21.C语言程序设计（含面试）\r1.在线题库练习\r20.C++面试\r1.网络编程\r1.代码编写规范\r嵌入式系统设计知识点\rArkTS\r电子电路\r模拟电子技术基础笔记\r操作系统\rLinux期末复习\rAndroidStudio\rAndroidStudio\rAndroidStudio笔记\r2-1.Toolbar工具栏\r计算机组成原理\r过年\r计算机组成原理-复习\r51单片机\rpretues+kiel5仿真软件配合使用时需要注意的地方\r19.设计模式（C++）",
    "tags": [],
    "title": "课程",
    "uri": "/class/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代",
    "content": "毕业设计\r电赛\r唛盟杯比赛详记",
    "description": "毕业设计\r电赛\r唛盟杯比赛详记",
    "tags": [],
    "title": "  项目",
    "uri": "/projects/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代",
    "content": "黑神话悟空之黄沙迷障这是一个关于黑神话悟空之黄风岭的故事，天命人是如何进入黄风岭，在这路上又会发生什么，真如游戏所展示的一样吗？实则不然。\n桑叶白鸟卷\r在宋朝末年的一个春日午后，阳光透过雕花窗棂，洒在了御书房的青石地板上。太傅李大人正站在书架旁，耐心地教导着最受宠爱的柒公主学习《论语》。公主虽然天资聪颖，但今日却显得心不在焉，她的目光不时飘向窗外的花园，那里的蝴蝶正在花间翩翩起舞。\r太傅李大人轻声咳嗽，试图引起公主的注意，但柒公主却只是懒洋洋地翻了一页书，完全没有将心思放在学习上。李大人心中微微叹息，他知道这位公主自小受到皇上的宠爱，性格难免有些任性。他决定采取一些措施，于是他从桌上拿起了一根精致的戒尺。\n君绘语一段跨越青春岁月的校园记忆，在友情与暧昧的缝隙中悄然生长。苏绘与张君因一场失眠邂逅另一个少年，一段段往事就此展开，她们分享秘密，试探真心，却也各自藏起无法言说的情愫。当成长的年轮碾过懵懂的约定，那些未寄出的告白、假装的笑容与深夜的眼泪，最终凝结成青春独有的遗憾与温柔。这是一个关于暗恋、陪伴与自我和解的故事，在记忆的星空中，所有未完成的对话都成了照亮年少时光的微光。\n红叶那头儿牛村与花村隔着一片红树林，阿牛和阿花从小在红叶堆里打滚长大。那年深秋，一场桥下误会让阿牛摔了定亲酒，阿花连夜进城，阿牛入伍流落街头。三年后，阿牛退伍回乡，当他接过一包绣着木棉的野菊花，才嚼出那年月里藏着的苦与甜：有些心意像深秋的红叶，风一吹就散了，可落下时偏偏砸得人心口生疼。\n半钟礼物这是一个发生在寒冬夜晚的青春校园故事。西蚌县高中生仲晨星在生日当晚，意外收到同班同学璐玲送来的特殊礼物——奶茶店相遇、密码礼盒与暗藏玄机的2.9元红包，揭开了两人长达两年的微妙情谊。当贫困搬迁户出身的璐玲在冷风中送来手工纸鹤礼盒，用九键输入法暗藏姓名密码时，这场充满少年心事的生日惊喜，却在误会与时光中尘封。直到多年后晨星偶然破解数字密码，才真正接收到那个雪夜未曾领会的少女心意\n示月祈福语上古洪荒，爱恨燃尽三界。神兽朱雀与人族勇士的禁忌之恋，诞下灵慧半神翎凤；凡尘侠侣嫦娥后羿，因长生药掀起宿命波澜；堕天妖兽螭吻与月宫仙子的生死纠葛，更在神规铁律下撕开血色裂痕。当神性、兽性与人性在云端碰撞，那些跨越种族的痴缠，违逆天命的相守，终将星月劈成碎屑，散作照亮永夜的——最灼烫也最温柔的劫灰。\n小说下载橱窗\r国学经典描述文章内容\n轻小说描述文章内容\n文学描述文章内容\n国学经典描述文章内容\n轻小说描述文章内容\n文学描述文章内容",
    "description": "黑神话悟空之黄沙迷障这是一个关于黑神话悟空之黄风岭的故事，天命人是如何进入黄风岭，在这路上又会发生什么，真如游戏所展示的一样吗？实则不然。\n桑叶白鸟卷\r在宋朝末年的一个春日午后，阳光透过雕花窗棂，洒在了御书房的青石地板上。太傅李大人正站在书架旁，耐心地教导着最受宠爱的柒公主学习《论语》。公主虽然天资聪颖，但今日却显得心不在焉，她的目光不时飘向窗外的花园，那里的蝴蝶正在花间翩翩起舞。\r太傅李大人轻声咳嗽，试图引起公主的注意，但柒公主却只是懒洋洋地翻了一页书，完全没有将心思放在学习上。李大人心中微微叹息，他知道这位公主自小受到皇上的宠爱，性格难免有些任性。他决定采取一些措施，于是他从桌上拿起了一根精致的戒尺。",
    "tags": [],
    "title": "小说",
    "uri": "/story/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代",
    "content": "",
    "description": "",
    "tags": [],
    "title": "  关于",
    "uri": "/about/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "Cues Cues Notes 创建css文件 在hugo配置中设置 在markdown文档中引用 Summary 标签/提示 ：静态网页，康奈尔笔记，hugo，自定义页面输出格式。\nNotes 创建css文件 康奈尔笔记的布局，其中左侧是 “Cues”，右侧是 “Notes”，底部是 “Summary”，您可以使用 Flexbox 的 row 和 column 布局来实现。这里是一个 CSS 示例，它将创建一个两列的布局，左侧为 “Cues”，右侧为 “Notes”，然后在这两列下方是 “Summary”。\n首先，创建一个名为 cornell-notes.css 的 CSS 文件，并添加以下样式代码：\n.cornell-notes { border: 1px solid #ccc; padding: 20px; margin: 20px; display: flex; flex-wrap: wrap; } .cues { background-image: url('icon2.svg'); border-right: 1px solid #080808; flex: 1; padding-right: 20px; } .notes { background-image: url('icon1.svg'); border-left: 1px solid #080808; flex: 2; padding-left: 20px; } .summary { width: 100%; clear: both; /* 清除浮动，确保摘要部分在下方 */ padding-top: 20px; background-image:url('wwwatercolor.jpg'); margin-top: 20px; }\r在这个样式中，.cornell-notes 是整个康奈尔笔记的容器，我们使用 display: flex; 和 flex-wrap: wrap; 来创建一个 Flex 容器，允许子元素根据需要换行。.cues 和 .notes 分别设置为容器的子项，并通过 flex 属性来分配空间。.summary 部分使用 width: 100%; 来确保它在 .cues 和 .notes 下方显示，并使用 clear: both; 来清除之前的浮动。\n此处分享一个免费的svg网站，bbburst： 在这个网站或许你可以找到适合你的背景图，用以装饰自己的康奈尔容器，此处的svg是放在css文件夹下的，所以是直接引用，如果你放在别的的放那么还请使用正确的的路径。\n在hugo配置中设置 接下来，确保将 cornell-notes.css 文件放置在 Hugo 站点的 static/css 目录下。然后，在 Hugo 的配置文件 config.toml 中添加对 CSS 文件的引用：\n# config.toml [Params] # 其他参数... [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true # 允许在 Markdown 中使用 HTML 和 CSS\r如果使用的是code打开的项目，那么可以先在code内搜索上面的配置是否已添加，因为部分hugo主题原来就添加了这一配置。\n在markdown文档中引用 在 Markdown 文件中，你可以这样使用这些类：\n--- title: \"康奈尔笔记示例\" --- \u003clink rel=\"stylesheet\" href=\"/css/cornell-notes.css\"\u003e \u003cdiv class=\"cornell-notes\"\u003e \u003cdiv class=\"cues\"\u003e ## Cues - 这里是关键词和提示。 \u003c/div\u003e \u003cdiv class=\"notes\"\u003e ## Notes - 这里是详细的笔记内容。 \u003c/div\u003e \u003cdiv class=\"summary\"\u003e ## Summary - 这里是笔记的摘要。 \u003c/div\u003e \u003c/div\u003e\r确保在 Markdown 文件中添加 标签来引入 CSS 文件，并为每个部分使用相应的类。这样，当你构建并查看 Hugo 站点时，康奈尔笔记将以正确的样式显示，其中 “Cues” 在左侧，“Notes” 在右侧，“Summary” 在底部。\nSummary 在上面我们学习了如何自定义hugo中页面的输出格式，在引用hugo主题情况下，自定义自己的页面输出格式只需要三点，即创建css文件，在config配置文件中配置相关信息，在markdown中引用。其实我们可以拓展，如果你想创建属于自己的笔记你可以参照上面的方法自制简单的笔记，希望本期内容对你有所帮助。",
    "description": "Cues Cues Notes 创建css文件 在hugo配置中设置 在markdown文档中引用 Summary 标签/提示 ：静态网页，康奈尔笔记，hugo，自定义页面输出格式。\nNotes 创建css文件 康奈尔笔记的布局，其中左侧是 “Cues”，右侧是 “Notes”，底部是 “Summary”，您可以使用 Flexbox 的 row 和 column 布局来实现。这里是一个 CSS 示例，它将创建一个两列的布局，左侧为 “Cues”，右侧为 “Notes”，然后在这两列下方是 “Summary”。",
    "tags": [],
    "title": "4.自定义页面以康奈尔笔记格式输出",
    "uri": "/log/4.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%BA%B7%E5%A5%88%E5%B0%94%E7%AC%94%E8%AE%B0%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA/"
  },
  {
    "breadcrumb": "",
    "content": "This is a new releasenote.",
    "description": "This is a new releasenote.",
    "tags": [],
    "title": "技术博客 | 智能物联时代",
    "uri": "/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "一台电脑如何使用多个远程仓库？ 下载好git，并做好相关的配置 关联github仓库 创建github仓库 克隆仓库到本地 git clone \u003c你的远程仓库URL\u003e\r创建多个 SSH 密钥对涉及到在本地生成多个公钥和私钥文件，并将公钥添加到你想要访问的远程服务器上。以下是详细步骤：\n打开终端： 打开你的终端（在 macOS 或 Linux 上）或 Git Bash（在 Windows 上）。\n导航到 SSH 目录： 使用 cd 命令切换到你的 SSH 目录，通常是 ~/.ssh。\ncd ~/.ssh 生成新的 SSH 密钥对： 使用 ssh-keygen 命令生成新的密钥对。每次运行此命令时，你都可以指定不同的文件名，以便区分不同的密钥对。例如，为 GitHub 生成的密钥对可能命名为 id_rsa_github，为 GitLab 生成的密钥对可能命名为 id_rsa_gitlab。\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" -f id_rsa_github 重复上述步骤，为其他服务生成密钥对，只需更改文件名即可。例如：\nssh-keygen -t rsa -b 4096 -C \"another_email@example.com\" -f id_rsa_gitlab\n-b是指密码的长度是4096，与加密有关，-f表示要创建的ssh有关文件名\n在生成密钥时，系统会提示你输入一个文件名来保存新的密钥对。如果你直接按回车键，它将使用默认的文件名（如 id_rsa）。如果你想要为每个服务使用不同的文件名，确保在命令中指定 -f 选项后跟你想要的文件名。\n将公钥添加到远程服务器： 生成密钥对后，你需要将公钥（文件名后缀为 .pub）添加到远程服务器的 SSH 密钥管理界面。例如，在 GitHub 上，你可以在 Settings \u003e SSH and GPG keys 部分添加新的公钥。\n配置 SSH 配置文件： 为了确保 SSH 使用正确的密钥对连接到正确的服务器，你可以在 .ssh 目录下创建一个名为 config 的文件（如果该文件不存在的话），并为每个服务配置不同的设置。\ntouch ~/.ssh/config\n然后编辑这个文件，添加以下内容：\nHost github.com User git IdentityFile ~/.ssh/id_rsa_github IdentitiesOnly yes Host gitlab.com User git IdentityFile ~/.ssh/id_rsa_gitlab IdentitiesOnly yes\r这里的 Host 是你为每个服务设置的别名，User 是 Git 服务的默认用户名（通常是 git），IdentityFile 是你的私钥文件的路径。\n测试 SSH 连接： 使用 ssh -T 命令测试与远程服务器的连接。例如：\nssh -T git@github.com ssh -T git@gitlab.com\r如果一切设置正确，你应该会看到一条欢迎消息，表明你已经成功通过 SSH 密钥验证。\n当我有连个github账户时，当我用同一台电脑推送的时候如何区分是那个推送的 推荐文章\n答案：\n首先是克隆下来两个项目一个为test_A,一个为test_B，假设有一个账户是A，另一个是B，而且A账户的邮箱是设置为全局的，即用了这条命令：\ngit config --global user.name \"A\" git config --global user.email A@qq.com #假设这里的邮箱是QQ\r那么在在text_A中不作任何修改，在text_B中添加如下命令即可：\ngit config user.name \"B\" git config user.email B@qq.com #假设这里的邮箱是QQ\r遇到的一些问题 问题一\n解决Git上传代码error: failed to push some refs to ‘xxx‘hint:(e.g., ‘git pull …‘) before pushing again错误\n推荐文章\n问题二\n【Git】错误：权限被拒绝（公钥）(Permission denied (publickey).)\n推荐文章2)\n问题三\n解决Git上传代码error: failed to push some refs to ‘xxx‘hint:(e.g., ‘git pull …‘) before pushing again错误\n推荐文章\n附件",
    "description": "一台电脑如何使用多个远程仓库？ 下载好git，并做好相关的配置 关联github仓库 创建github仓库 克隆仓库到本地 git clone \u003c你的远程仓库URL\u003e\r创建多个 SSH 密钥对涉及到在本地生成多个公钥和私钥文件，并将公钥添加到你想要访问的远程服务器上。以下是详细步骤：",
    "tags": [
      "工具",
      "Gihub",
      "Atomgit"
    ],
    "title": "3.github和atomgit的混合使用，哪些是值得注意的？",
    "uri": "/log/3.github%E5%92%8Catomgit%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%93%AA%E4%BA%9B%E6%98%AF%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: Atomgit",
    "uri": "/tags/atomgit/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别",
    "uri": "/categories/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: Gihub",
    "uri": "/tags/gihub/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签",
    "uri": "/tags/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 工具",
    "uri": "/tags/%E5%B7%A5%E5%85%B7/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 工具推荐",
    "uri": "/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "网页链接 原文章链接\n1、使用git commi -m “……“时报错： Your branch is up to date with ‘origin/master‘ 今天在提交项目的时候报了这个错误，在网上查了解决办法，有的说创建新的分支可以解决，但我的不行。\n最后我的解决办法是先退出git base here，再重新进入，下面是具体步骤：\n先使用git add .； 接着使用git status -s查看我更改的文件，也是我要推送的文件，如果前面的有M和??，那么久重新更新文件，然后重复上面的步骤； 发现前面的M是绿色的后就可以使用git commit -m \"文件备注\"； 然后推送就可以了git push origin main。 AndroidStudio中的grable下载很慢，如何解决？ 参考地址\n这里的关键命令是git status -s，我现在搞不懂这个错误产生的原因……\n虚拟机连接不上网络，没有分配ENS33 参考链接\n浏览器突然无法访问某些网站，之前可以突然不行。 解决办法： 在浏览器中关闭，使用安全的 DNS 指定如何查找网站的网络地址，然后就可以访问了，原因我还没弄清楚。\nAndroidStudio中为什么不建议使用case R.id.generate判断，而是使用if(v.getId() == R.id.generate)？ 1.当使用Switch语句写如下代码时，\nswitch (v.getId()){ case R.id.generate: break; case R.id.add: break; }\r（红色表示报错）如果报错android studio报错constant expression required， 可以把Switch语句换成if-else语句即\nIf（v.getId() == R.id.generate） { …… }else if（v.getId() == R.id.add）{ …… }\r这样就可以了。来源以及具体原因： https://blog.csdn.net/weixin_43912621/article/details/106178388\n附件",
    "description": "网页链接 原文章链接\n1、使用git commi -m “……“时报错： Your branch is up to date with ‘origin/master‘ 今天在提交项目的时候报了这个错误，在网上查了解决办法，有的说创建新的分支可以解决，但我的不行。",
    "tags": [
      "工具",
      "Github"
    ],
    "title": "2.git与github的使用",
    "uri": "/log/2.git%E4%B8%8Egithub%E7%9A%84%E4%BD%BF%E7%94%A8/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: Github",
    "uri": "/tags/github/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "代码分制表 以\u003c tabs title=\"file name\" \u003e，\u003c /tabs \u003e结尾； 然后里面写以% tab title=\"code name\" style=\"info\" color=\"blue \" %，% /tab %结尾 他们都需要用{{}}括起来 ​\r代码\r{{\u003c tabs title=\"hello.\" \u003e}} //代码块一 {{% tab title=\"py\" %}} ```markdown **这里写代码** ``` {{% /tab %}} //代码块二 {{% tab title=\"sh\" %}} ```markdown **这里写代码** ``` {{% /tab %}} {{\u003c /tabs \u003e}}\r显示附件文件 在双花括号里写：attachments color=\"fuchsia\" icon=\"fab fa-hackerrank\"，即可，\n{{% attachments color=\"fuchsia\" icon=\"fab fa-hackerrank\" %}}\r——————————————————分割线\n不论是创建首页页面，还是左边框的选项，归根结底它们都是“目录”，从根上说，你需要创建一个目录然后在目录里面创建一个.md文件来装这个目录或说显示这个目录的内容。\n首页的创建 创建首页使用了命令\nhugo new --kind home _index.md\r而后产生的页面，它自动生成头文件\n+++ archetype = \"home\" title = \"\" +++\r值得注意的是，如果你用命令\nhugo new site myblog\r创建了一个myblog的目录，那么你在里面操作hugo new –kind home _index.md的时候,用于显示首页的文件**_index.md**会自动产生在content文件里。\n创建章节的方法 使用命令：\nhugo new \u003cchapter\u003e/\u003cname\u003e/_index.md\r或者：\nhugo new \u003cchapter\u003e/\u003cname\u003e.md\r在创建章节的时候需要加上alwaysopen = false,如下面的例子：\n+++ alwaysopen = false archetype = \"chapter\" title = \"2.AndroidStudio\" weight = 20 +++\r在标题前面显示图标 +++ menuPre = \"\u003ci class='fab fa-github'\u003e\u003c/i\u003e \" +++\r添加这个后的效果如下：\nTechMind\r首页\r技术文章\r小说\rSearch\r搜索\r最新技术文章\r{{ partial \"post-card.html\" (dict \"path\" \"log/7.初次安装AD需要做哪些设置？.md\") }}\r#13 物联网网络安全论\r探讨边缘计算环境下的安全防护体系...\n发布于 2024-03-12 | 分类：网络安全\r连载小说\r#8 桑叶白鸟卷\r「殿下请看，这雕花窗棂的纹路暗合奇门遁甲之术...」\n太傅李大人手持竹简，青石地板上的光影随着日晷缓缓移动...\n继续阅读 →\r关于我们 |\r隐私政策 |\rRSS订阅\r© 2024 TechMind. 保留所有权利.\n附件",
    "description": "代码分制表 以\u003c tabs title=\"file name\" \u003e，\u003c /tabs \u003e结尾； 然后里面写以% tab title=\"code name\" style=\"info\" color=\"blue \" %，% /tab %结尾 他们都需要用{{}}括起来 ​\r代码\r{{\u003c tabs title=\"hello.\" \u003e}} //代码块一 {{% tab title=\"py\" %}} ```markdown **这里写代码** ``` {{% /tab %}} //代码块二 {{% tab title=\"sh\" %}} ```markdown **这里写代码** ``` {{% /tab %}} {{\u003c /tabs \u003e}}",
    "tags": [
      "前端",
      "Hugo主题博客"
    ],
    "title": "1.博客优化笔记",
    "uri": "/log/1.%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: Hugo主题博客",
    "uri": "/tags/hugo%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 踩坑日记",
    "uri": "/categories/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 前端",
    "uri": "/tags/%E5%89%8D%E7%AB%AF/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "理解GLFW和GLAD GLFW（） GLFW是一个开源的、跨平台的库，用于创建窗口、处理输入和渲染图形。它提供了一种简单的方式来与OpenGL进行交互，使得开发图形应用程序变得更加容易。\nGLFW的主要功能包括：\n创建窗口 定义上下文 处理用户输入 GLAD（） GLAD是一个开源的、跨平台的库，用于管理OpenGL的函数指针。它提供了一种简单的方式来获取OpenGL的函数指针，使得开发OpenGL应用程序变得更加容易。\n相关说明：\nOpenGL本身知识规范/标准 各个厂家具体实现方式可以不同 不同操作系统处理方式也可以不同 主要功能：\n获取OpenGL函数指针 处理OpenGL版本兼容性问题 处理OpenGL扩展函数 …… 如果没有GLAD库，在Windows下：\ntypedef void (*GL_GENBUFFER) (GLsizei,GLuint*);//声明函数指针 GL_GENBUUFFER glGenBuffer = (GL_GENBUFFER)wglGetProcAddress('glGenBuffer');//获取函数指针 unsigned int buffer;//声明缓冲区对象 glGenBuffer(1,\u0026buffer);//调用函数 有了GLAD库，只需要：\nunsigned int buffer; glGenBuffer(1,\u0026buffer);\r附件",
    "description": "理解GLFW和GLAD GLFW（） GLFW是一个开源的、跨平台的库，用于创建窗口、处理输入和渲染图形。它提供了一种简单的方式来与OpenGL进行交互，使得开发图形应用程序变得更加容易。",
    "tags": [
      "C++",
      "计算机图形学",
      "OpenGL"
    ],
    "title": "15.计算机图形学OpenGL与C++",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/15.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6opengl%E4%B8%8Ec%E5%8A%A0%E5%8A%A0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "15.计算机图形学OpenGL与C++理解GLFW和GLAD GLFW（） GLFW是一个开源的、跨平台的库，用于创建窗口、处理输入和渲染图形。它提供了一种简单的方式来与OpenGL进行交互，使得开发图形应用程序变得更加容易。\n14.新标准C加加程序设计内存分区模型 内存代码区的意义：程序代码放在不同的区域，有程序自动管理的代码，也有程序员管理的代码，灵活管理；\n一、程序执行前\n1.代码区 存放二进制指令，就是代码，特点：\n13.从C到C++指针 指针的声明： 数组 数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义： 2.字符串文字量\n指的是用 ““括起来的字符串。\n12.其他库的介绍为什么需要哈希函数？ 哈希函数在计算机科学中扮演着重要的角色，其主要作用包括：\n数据检索：哈希函数可以将键（key）映射到哈希表中的一个位置，从而快速检索数据。这是哈希表（如 C++ 中的 std::unordered_map 和 std::unordered_set）的基础。\n11.STL库学习之适配器整体框架的回顾 存在多种适配器-adapters 一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知道该容器需要迭代器，也就是一些智能指针来确定容器的头尾，以及内容位置，目的是方便后续的算法的怎删改查等操作，假设算法现在要做拿到位置8的数据，那么vector的指针要怎么移动呢？已知指针移动上，vector是随机访问指针，也就是前后都可以跑，而这个操作实际上是迭代器的其中一个内容，而这一内容就需要一个适配器去做适配。\n10.STL库学习之仿函数仿函数的个人理解 仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了operate()，当调用这个类的()时就会返回响应的数据。\n9.STL库学习之迭代器与算法标准库常用算法 迭代器 迭代器-的分类 struct input_iterator_tag {}； struct output_iterator_tag {}; struct forward_iterator_tag:public input_iterator_tag{}; struct bidirectional_iterator_tag:public forward_iterator_tag{}; struct random_access_tag:public bidirectional_iterator_tag {};\r以上5中迭代器的继承关系，如下图所示。 1.Input Iterator（输入迭代器）： 输入迭代器是最基本的迭代器类型，支持单向遍历，只能向前移动。\n8.STL库学习之容器list vector deque deque的迭代器 deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用push_front()（push_back()）,否则借助insert_aux()迭代器，实现如果欲插入位置靠近前端使用，就让前端的数据往前挪，否则往后挪。\n7.STL库学习之分配器分配器源代码位置：xmemory.h 除了array和vector外，其他容器的适配器必须是一个类， 附件\r6.STL库学习之筑基概要STL程序源代码位置 了解自身编译器STL程序源代码位置。\nOOP 与 GP 面向对象编程（OOP）：\n面向对象编程是一种编程范式，它将数据和处理这些数据的方法封装在对象中。这种方法强调了数据和函数的捆绑，使得代码更加模块化，易于理解和维护。对象可以包含属性（数据）和方法（函数），它们一起工作来模拟现实世界的行为。\n5.STL库之观其大略一下主要讲STL组件的测试用例，特别是容器的测试 学习资料 CPLusPlus.com CppReference.com gcc.gnu.org 《STL源码剖析》 STL六大组件 容器-Containers，申请内存用于存储数据 分配器-Allocators，配合容器分配内存 算法- Algorithms，处理某一数据的最优办法 迭代器- Iterators，指针的泛型，本质与指针类似 适配器- Adapters， 仿函数-Functors，类似函数。 六者的关系\n4.C++2.0特性的使用VS 2022的设置 首先你可以先用下面的代码测试使用可以执行：\n#include \u003ciostream\u003e void printTypes() { } template \u003ctypename T, typename... U\u003e void printTypes(const T\u0026 t, const U\u0026... u) { std::cout \u003c\u003c t \u003c\u003c std::endl; printTypes(u...); } int main() { printTypes('a', 1.5, 'b'); }\r如果报错了，如typename…未定义，那么请你按照如下步骤操作， 3.导读书籍推荐 《C++ Premier》 《C++ Programming Language》 《Effective Modern C++》 《Efficient C++》 《The C++ standard library》 《STL C++》 《STL源码剖析》 《算法+数据结构=程序》 “网站CPLusPlus” “网站CppReference” “网站gcc.gnu” 学习路线 2.组合与继承类与类的三种关系 Composition-复合 以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构函数运行次序是，构造函数有内到外依次运行，析构函数则相反。可以使用下图表示这种关系\n1.代码编写规范如何写一个标准的.h文件 以下内容来自B站。\n接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：\nclass complex { private: /* data */ double re,im; friend complex\u0026 __doapl (complex*,const complex\u0026); public: complex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {}; complex\u0026 operator += (complex operator\u0026); double read () const {return re;} //这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型 double imag () const {return im;} };\r构造函数的特性 这一点需要关注下面的代码：",
    "description": "15.计算机图形学OpenGL与C++理解GLFW和GLAD GLFW（） GLFW是一个开源的、跨平台的库，用于创建窗口、处理输入和渲染图形。它提供了一种简单的方式来与OpenGL进行交互，使得开发图形应用程序变得更加容易。",
    "tags": [
      "C++"
    ],
    "title": "17.C加加编程",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: C++",
    "uri": "/tags/c\u0026#43;\u0026#43;/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: OpenGL",
    "uri": "/tags/opengl/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 编程语言",
    "uri": "/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 计算机图形学",
    "uri": "/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 自学编程语言",
    "uri": "/categories/%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说",
    "content": "第一章\n年轻男子身姿挺拔，一臂甲乌金臂鞲泛着冷光，乌金皂罗袍衣甲裹身，褪甲乌金行缠束腿，站在那，自有一股英气逼人。 他望着四周破败之景，剑眉微蹙，开口问道：\n“此处妖怪横行，怎的清源百姓还在此苦守？何不逃离，免受这无尽惊扰？”\n一旁壮汉闻声，叹息摇头，操着浓重口音回道：\n“好汉有所不知，此地离黄风岭和黄金佛国近得很哩，哪能说走就走。”\n“此间有何说法？”男子上前问道。\n“此间还真有说法！！”壮汉用手微微撑起，舒了口气，这才继续说道：\n“想当年，哈咇国国王年事已高，怕得要命，四处寻长生仙方。有方士献言，说长期服用石英能长生不老。那国王一听， 立马张贴榜文，重金悬赏石英。不少采石人为了赏金，深入黄风岭荒漠。那时候，这还没叫清源，只是个采矿人入山前歇脚的地儿。 采矿人进山后，瞧见山里有石精，那石精脑袋里露着晶莹白矿，正是石英。可采矿人哪是石精对手，只能灰溜溜回来禀告国王。 国王心急，派太子带着军队去开采。军队到这儿，就在这安营扎寨，为保采矿顺利，还修了城墙，这清源城才有了雏形……”\n壮汉说到这，仰头望天，似陷入回忆。他深吸一口气，见男子正认真听着，他接着道：\n“太子带兵入山后，黄风迷道，尘沙蔽日，石精们更是狡猾危险，时常埋伏土中，瞅准机会成群结队窜出来，左右夹击。没多久， 军队就损兵折将，别说采矿，保命都难。”\n说到这壮汉拳头紧握，关节泛白，他接着道：\n“太子无奈，派人送千里急信回都城，哭诉此行凶险，将士们苦不堪言，求国王收回成命。可那国王，一心只想长生，硬是下旨让 军队继续开采……”壮汉说了很多，见一旁的男子不语，正要起身道谢男子，不想男子开口道：“壮士说得这般生动，莫不是亲身经历过这惨事？”\n壮汉苦涩一笑，看那天也还未明朗，示意男子坐下。\n“你若是对此有兴趣，倒也不妨与你说说，”壮汉缓缓道：\n“不瞒你说，昔年在下也在那支军队里头，还是太子前带刀侍卫的徒弟。入山之后，军队对那石精毫无办法，伤亡极为惨重，时刻都有被团团围住、 全军覆没的危险。国王那边又催得十分急切。正当大家一筹莫展的时候，有位姓齐的将军提议去黄风岭的土地庙拜一拜，祈求土地神助军脱局。 太子和几位将军起初都反对，说这法子过于荒唐。可齐将军斩钉截铁的认为可以一试。他原本是斯哈哩国的一名说客，后来游说到了哈咇国， 国王觉得他很有才能便将他招纳麾下，也不知怎的，后来就成了太子麾下的将军。齐将军用了一段往事并立下军令状，又经过一番辩论，大家这才信服。 可紧接着问题也来了，谁去土地庙哩？当时咱们在黄风岭沙门村附近，去土地庙虽算不上远，但黄风迷道，妖怪横行，石精挡道，路也确不好走。”\n男子听罢，眉头微拧，等着壮汉继续。\n“后来齐将军自荐，自己提议自己前往土地庙。”壮汉喝了口水，接着道：“许是老天可怜，齐将军去后一日，土地神竟托梦于太子，告知其脱困之法。 不过那法子只有太子和几位将军知晓。我和师傅那夜只是守在太子帐外，一炷香后，前线传来捷报，说石精已被击败，石英取得可以返程。 夜里，咱们正要动身，师傅发现齐将军自去沙门村后就没了踪影。师傅放心不下，护送太子出了黄风岭后，又折返回去寻齐将军。当时太子和师傅还起了争执， ，或是师傅说服了太子，太子后面又同意了。师傅走后，我被安排保护太子回都城。回城后，军队早已九死一生，带着石英返回，随太子出征的大军已伤亡过半。”\n壮汉说到这，眼神黯淡，“那夜，太子借送石英给老国王之机，发动兵变，把抱着长寿秘药的老国王刺死在龙床上。那后我也升迁，暂替师傅成了太子的带刀侍卫。 这二十年来，我一直打听师傅下落，这才来到这住下。清源城陈老太爷富贵且消息灵通，我拜入他府中做了这一带的庄头，替他收租，一边收租一边打探师傅消息。”\n男子听完，道：“壮士为寻师傅不息二十年寻找，实在令人敬佩。”\n庄头摆摆手，“好汉过奖了”\n男子道：“还不知如何称呼？”\n“在下姓赵单字一个铁，不知好汉哪方人士，叫我如何称呼……原来是傲来国人士，哦，孙好汉有礼了，”见男子再次询问黄金佛国之事，赵铁继续道：“黄金佛国？对对对， 再说那黄金佛国，盛产黄金，多少商客眼馋。可如今那地儿鼠妖遍野，去的商客怕是没等寻到黄金，就进了妖怪肚子。不过，有些不怕死的商客，这些年一直住在清源城， 屯兵储粮，就盼着有朝一日去黄金佛国淘金哩。”\n话说那天命人，曾在黑风山救下一猴，那猴子为表谢意，不仅传授泡酒之法，还赠予一瓶椰儿酿。天命人告别黑风山，一路奔着清源城而来。 这一日，夜幕低垂，天命人瞧见一背着背篓、身穿黄衣的道士正在山间采摘草药。天命人本欲悄然离去，却见那道士摘的小灵芝突然从土里钻出， 瞬间化作一只精怪，将道士打倒在地，满地药材散落一地。天命人见状，心生怜悯，使出戳棍之术，远远将那精怪打飞数丈远，那精怪随后化作一缕灰烬， 消散于夜色之中。\n天命人赶忙上前搀扶那道士，却不想，那哪是什么道士，分明是一只生着狗模样、身着道服的妖精。那妖精定睛一看，眼前这人臂甲乌金臂鞲闪烁，身披乌金皂罗袍衣甲， 褪甲乌金行缠束腿，腰间还挂着个葫芦，正是个猴子模样。那妖精暗自欣喜，嘟囔道：“哎呦，只知炼丹不练神功，今日竟栽在这小妖手里，晦气晦气……”\n天命人一时愣在原地，原以为是妖怪要害人，这才出手相救，不想这俩都是妖。这似与救那申猴极为相似，在救下申猴那时他也想，纵使这次是救对了，但是下次会不会救错。\n小时候，天命人也曾问老猴子：“师傅，以后我也当天命人了，下山遇到那些修道者该不该救。”\n“自是要救，但修道者既有善仁者，也有奸恶者。”老猴子说道。\n“我自是救善仁者……”天命人犹豫了会儿，又问道：“师傅，你说这世道是恶人多，还是善人多？”\n“自是善人多。”老猴子答道。\n“那为何这世间从未太平，恶人总是横行无忌。”\n“因为不分好歹的善是恶的帮凶，一霹雳手段，显菩萨心肠，这就是你的天命……”\n天命人谨记教诲，如今又救下了个妖，心中虽五味杂陈，但有些事似乎已渐渐明了。\n那妖精却开口道：“多谢好汉救命之恩。”说着，还咳嗽了几声，似乎很是难受。天命人从腰间取下葫芦，让其饮下，那椰儿酿内含灵蕴，又混有上等的泡酒物， 饮后片刻可恢复如初。那妖精饮罢，眼睛一亮，说道：“此物唯有申猴才能泡出这般味道！”\n“你认识申猴？”天命人好奇问道。\n“何止认识，我们还曾共事过，不过那都是以前的事了…… 不提也罢，不提也罢。” 妖精神色黯然，不愿多说。\n一番询问后，天命人才得知，这原来是六丁六甲之一的戌狗，与申猴同是天上神仙，曾一同被遣护送取经团队。戌狗为表感谢，赠予天命人化形丹和腰牌， 天命人知这与申猴路数如出一辙，便收下。临别前，戌狗还告诫天命人，善用化形丹，善用腰牌到道观好生习炼丹之术，以备后用。\n天命人暗自记下，继续赶路，离清源城越来越近，四周村镇也多了起来。天命人用了化形丹，化作人形，继续前行。走着走着，听见左边传来乒乒乓乓的打斗声， 只见一个农夫正持着大刀与一只蝙蝠精打得难解难分，一时间难分上下。天命人见那确是个农夫壮汉正遭只妖精扑来飞去，妖精嘴里嘟囔道要吃人哩， 好说要是也学了大圣的火眼金睛定也不必这么麻烦，天命人左右观之稍许，也是识得了哪是妖哪是人，便上前助拳。农夫见天命人出手，便退到一旁。 天命人不知从哪抽出一根兽棍，重重砸向蝙蝠精。那精一跃而上，得意地盘旋于空中。天命人正要一个立棍将其拿下，农夫喊道：“好汉，接刀斩它翅膀！” 说话间，那精侧身欲躲，不想天命人跃起一个横刀，那精的头便飞了出去。\n天命人正要扶那农夫，农夫却示意不用。\n临近城镇妖怪如此猖獗，天命人不忍问问了农夫，不想农夫却与之谈起了一段往事。\n农夫便是那赵铁，赵铁说完黄风岭与那黄金佛国的故事后，见那天命人在一旁嘀咕着什么，猴模猴样的，他又看了看即白的东方，\n“孙好汉！”赵三起身对天命人说道：“多谢刚才帮我杀了只疾蝠，若没有你我恐遭那精怪毒手。与你交谈也好事快活，你这朋友我认定了，以后若有机会定与你把酒言欢， 介时可到陈府找我。咋们就此别过！”\n天命人作别庄头后，便往城中而去。庄头见目送其天命人后，收拾好疾蝠尸首，往村庄去，走到村民腾出的大屋，庄头将疾蝠尸首丢在门前，径直往屋里去。\n这年秋收后，赵铁来村中收租。村民把村头那栋空置许久的大屋收拾出来，腾给赵铁暂住，并为他置办了丰盛的筵席，洗尘接风。酒足饭饱后，村长对赵铁坦言道：\n“田租实在太高了，能不能减少一些。”\n赵铁道：“田租是你们与主家定的，我既拿了月俸，只管来向你们要债。你与我商量此事，我也没有办法呀。”\n大家争来吵去，谈不出个结果，眼看天色渐晚，便都草草告辞。走在最后的老鳏夫对农夫道：\n“小村鄙陋，没什么好消遣的地方，倒是后山亭，是个赏月的好去处。农夫若是烦闷，可以去那处散散心。”\n言罢，这才告辞离去。于是昨夜赵铁挑灯正要去后亭赏月，不想遇到了两只妖精。\n次日，村民来大屋给庄头准备饭食，却见他坐在门前，腿旁的地上插着柄大刀，刀下钉着两具没有脑袋的蝠尸。一人上前作揖，问道：\n“这……这是……”\n庄头瞅了瞅那人，又恶狠狠地看了那疾蝠，说道：“昨晚山后亭砍杀的，山后亭可谓景色宜人啊！”\n说者无意，听者有心，其后几日，村民们缴齐了足额的田租，又置办了丰厚的酒席，恭敬地送庄头回城里去了。\n天命人在戌狗的指引下，带着腰牌去了清虚道观。也不知为何，道士自见到腰牌起，就很敬重天命人，还给他安排了住处。听天命人说想学些炼丹之术，那些道士便忙前， 忙后的帮着找丹书，传炼丹之法，负责此事的是观主的大弟子和三弟子，大弟子唤清空，三弟子唤明净。\n几日后，陈府派人来请求道士们去府上除妖，说府上派出去的仆人无缘无故失踪。道士们自是不愿意去，因为上一次因为摊上陈府事的师兄已经被丹炉炸死了， 道士们便相互推脱。天命人在房内看着丹书，听到有人吵闹，便循声出门看看，见他们在议论被丹炉炸死的道士，他这才想起戌狗之前对他说过的一段往事。\n那夜戌狗示意天命人一旁坐下，似有事想告，他说道。\n“清虚巷东头的小道观里，住着个道士。他自称得了海上仙方，是个妙手回春的道医。我盘算着在凡间学些凡人手段，于是便跟随了他，毕竟我也是个喜炼丹之术。 道士的丹药，生病的人吃了，不见大好，没病的人吃了，只如寻常，不曾出过什么差错。若有人来问，他便道：“世上哪有什么起死回生灵丹妙药， 只有体内的精、气、神调和舒畅，才是真的身体康泰。”大家都认为这道士不甚厉害，所以门庭冷落，求医者极少。\n城中有个陈老太爷，富比王侯，如今花甲之年，染了重疾，显出下世的光景来。他的儿子寻至观中，请道士去给老太爷治病。道士为老太爷特制了许多丹药， 府中人虽觉得道士不过胡来应付，却也不敢多言，只敢在旁瞧个热闹，岂料，老太爷自服了那些药丸，渐渐竟能进些饮食，气也顺畅了，似有痊愈之兆。 偏巧，道士某次炼丹，炉子却炸了开来，连带着他一起送了命。这世道，有大才，反到是烧身之难哟！”\n看见来访的是陈府的人，天命人便上前自荐自己去除妖。众人将信将疑，说话间一人从人群中走来，来的是前几天遇到的庄头，庄头向众人讲述了那晚的天命人的事迹， 陈府上下知道庄头的身份以及他的厉害，自然无人怀疑，道士们见说话的是陈府的人，便与之商量，收了一袋银钱后，天命人这才同陈府的人去府上。",
    "description": "这是一个关于黑神话悟空之黄风岭的故事，天命人是如何进入黄风岭，在这路上又会发生什么，真如游戏所展示的一样吗？实则不然。",
    "tags": [],
    "title": "黑神话悟空之黄沙迷障",
    "uri": "/story/9.%E9%BB%91%E7%A5%9E%E8%AF%9D%E6%82%9F%E7%A9%BA%E4%B9%8B%E9%BB%84%E9%A3%8E%E5%B2%AD/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r21.C语言程序设计（含面试）",
    "content": "网站 “语言网【基础】” “大学慕课对应习题【算法基础】” “牛客竞赛【中等】” “LeetCode【较难】” 课程学习 “书籍” “大学慕课” Github项目 “C/C++面试总结项目” “书籍：Github项目” “C/C++面试总结” “系统设计” 题目笔记 1.cahr *s = \"AAAA\"指针接受一个字符串（右值），当想通过s[0] = ‘B’修改时是无法修改成功的，因为\"AAAA\"只能读，不能写。 2.一般函数内如果返回char s[] = {“abcd”};那么一般会报错，因为这是一个局部变量，但s[]修改为*s就不会有问题。因为 *s指向的地址是固定的。 3.在自动类型转换中：\nunsiged int a = 9; int b = 1; printf(\"%d\", b+a);\r此处会触发隐式转换——int类型转为uniged int 类型。\n4.大端模式和小端模式的作用是什么，为什么会出现这两种模式？\n作用： **大端模式：**在这种模式下，数据的高字节（最重要的字节）保存在内存的低地址处，而数据的低字节（最不重要的字节）保存在内存的高地址处。这种方式类似于人类读写数值的习惯，即从高位到低位 。 **小端模式：**在这种模式下，数据的低字节保存在内存的低地址处，而数据的高字节保存在内存的高地址处。这种方式在进行数据类型转换时不需要调整字节内容，直接截取低字节即可\n测试代码：\n#include \u003cstdio.h\u003e int main(){ int i; union test{ unsigned int n; char arr[4]; }; union test num; num.n = 0x12345678;//注意:12所在位置是高位 for(i = 0; i\u003c4; i++){ printf(\"\u0026arr[%d] = %p, arr[%d] = %#x\\n\",i,\u0026num.arr[i],i,num.arr[i]); } return 0; } /* 代码解释： 代码中，%x表示输出16进制，x前加 # 标志表示，如果使用 %ox（八进制）， 则输出的数前面会加上前缀 0；如果使用 %#x 或 %#X（十六进制）， 则输出的数前面会加上前缀 0x 或 0X。这样做可以明确地表示数值的进制， 便于阅读和理解。 结果： \u0026arr[0] = 000000000062FE10, arr[0] = 0x78 \u0026arr[1] = 000000000062FE11, arr[1] = 0x56 \u0026arr[2] = 000000000062FE12, arr[2] = 0x34 \u0026arr[3] = 000000000062FE13, arr[3] = 0x12 结论： 高位存储在高地址，所以是小端模式。 */ 5.printf的返回值类型是变量的字符个数。 6.#和##运算符的使用\n#include \u003cstdio.h\u003e #define T(x) printf(\"\"#x\" square is the \",(x)*(x)) #define TEST(n) X##n int main(void){ T(4); int TEST(0) = 10; int TEST(1) = 20; printf(\"%d\",X1); }\r结果：\n4 square is the 16 X1 = 10\r7.结构体中存储字符串时我们可以使用字符指针或者字符数组，但是一般推荐字符数组。选择字符数组还是字符指针取决于具体的应用场景和需求。如果字符串长度固定或较短，且对性能和内存连续性有要求，字符数组可能是更好的选择。如果需要灵活处理不同长度的字符串，或者字符串长度可能非常大，使用字符指针可能更合适，但需要更加小心地管理内存。\n8.strlen()和strcpy()\nstrlen() 和 strcpy() 是 C 语言标准库中的两个常用函数，它们用于处理字符串。下面分别解释它们的用途和使用时需要注意的事项。\nstrlen() 函数 用途： strlen() 函数用于计算一个以空字符（'\\0'）结尾的字符串的长度。它返回字符串的长度，不包括最后的空字符。\n函数原型：\nsize_t strlen(const char *str);\r使用注意事项：\n参数必须是以空字符结尾的字符串：如果传入的参数不是以空字符结尾的字符串，strlen() 会一直读取内存直到遇到空字符，这可能导致程序读取到未分配的内存区域，造成越界错误。 返回值类型：strlen() 返回的是 size_t 类型，它是一个无符号整数类型，用于表示大小或长度。在比较时，需要注意不要与有符号整数类型进行比较，以避免潜在的负值问题。 效率问题：strlen() 需要遍历整个字符串直到找到空字符，因此对于非常长的字符串，可能会有一定的性能开销。 strcpy() 函数 用途： strcpy() 函数用于将源字符串（包括空字符）复制到目标字符串中。它会覆盖目标字符串原有的内容。\n函数原型：\nchar *strcpy(char *dest, const char *src);\r使用注意事项：\n目标字符串必须足够大：在使用 strcpy() 之前，必须确保目标字符串 dest 有足够的空间来存储源字符串 src 的内容，包括最后的空字符。否则，可能会导致缓冲区溢出，这是常见的安全漏洞。 不检查目标字符串大小：strcpy() 不会自动检查目标字符串的大小，如果目标字符串空间不足，会发生溢出。 不进行类型检查：strcpy() 不会对传入的参数类型进行检查，因此传入的参数必须是字符数组或字符指针。 返回值：strcpy() 返回目标字符串的指针，通常用于链式操作，但需要注意不要因此覆盖了重要的指针值。 安全性问题：由于上述原因，strcpy() 在很多情况下被认为是不安全的。在实际编程中，推荐使用 strncpy() 或其他更安全的字符串复制函数，这些函数允许指定最大复制的字符数，从而避免溢出。 9.修改字节对齐方式 ：#pragma pack(n) //n表示字节对起数，如2，4，8，\n10.不同位数电脑的字节对齐方式\n解释代码含义：\n#define offsetof(TYPE, MEMBER) ((size_t ) \u0026((TYPE *)0)-\u003eMEMBER)\r(TYPE *)0:将0强制转换为TYPE类型指针，p = (TYPE *)0; ((TYPE *)0)-\u003e MEMNER:通过指针访问MEMBER成员， \u0026((TYPE *)0)-\u003e MEMNER：取得成员地址 ((size_t ) \u0026((TYPE *)0)-\u003eMEMBER)：将成员地址转为size_t类型 总结：该宏定义的作用是求出MEMBER成员变量在TYPE中的偏移量。 示例：\n//#pragma pack(4) #include \u003cstdio.h\u003e #define offsetof(TYPE, MEMBER) ((size_t ) \u0026((TYPE *)0)-\u003eMEMBER) typedef struct s { /* data */ union { int a;//4字节 char str[10];//10字节 }; struct s* next; }S; int main(){ printf(\"%ld\",offsetof(S, next)); return 0; }\r结果为16，因为电脑是64位的，所以以8字节对齐，联合体字节大小以最大的成员变量为准，故联合体的字节大小是10个字节\n12.返回二进制数中1的个数（经典题目） 13.求2的n次方 14.操作符[]的重载，代码实现读和写。 15.与操作与位操作\n#include \u003cstdio.h\u003e int main(){ int a = 0; a |= (1\u003c\u003c3);//将a的第3位设置为1 printf(\"%d\\n\",a); a \u0026= ~(1\u003c\u003c3);//将a的第3位设置为0 printf(\"%d\\n\",a); return 0; }\r知识点：\n只要出现置1：或操作 只要出现置0：与操作 16.sizeof的使用\n#include \u003cstdio.h\u003e int main(){ int a = 10; printf(\"%d\\n\",a); printf(\"%d\\n\",sizeof(a++)); printf(\"%d\\n\",a); return 0; }\r结果为：10,4,10,为什么最后不是11呢？ 17.指向地址的指针加一个整数\n#include \u003cstdio.h\u003e int main(){ unsigned char *p1 = (unsigned char *)0x08000010;//指向地址的指针 unsigned long *p2 = (unsigned long *)0x08000010;//指向地址的指针 printf(\"%#x\\n\",p1+5); printf(\"%#x\\n\",p2+5); return 0; }\r结果是0x08000015和0x08000024，\n对于前一个答案我们很清楚，因为一个unsigned char占一个字符，加5则是加5个字符； 后一个答案则是加5个long，一个long占4个字符，所以加5个long就是加20个字符，那么应该是0x08000030才对，为什么是0x08000024呢？因为使用的是16进制计算，20的十六进制就是14，所以是0x08000024。 18.volatile关键字\n#include \u003cstdio.h\u003e int squere(volatile int *pt){ //正确写法如下： //int a = *pt; //return a*a; return (*pt)*(*pt);//这样写可能会出错，因为编译器可能会优化代码，认为*pt的值没有改变，所以直接返回上一次的值 } int main(){ int a = 10; printf(\"%d\\n\",squere(\u0026a)); return 0; }\r19.假设有两个变量a,b，不借助第三个变量交换两个变量的值。\n#include \u003cstdio.h\u003e int main(){ a=2;b=3; a=a^b;//0010^0011=0001 b=a^b;//0001^0011=0010 a=a^b;//0001^0010=0011 printf(\"%d,%d\\n\",a,b); return 0; }\r还可以使用减法的思想：\n#include \u003cstdio.h\u003e int main(){ a=2;b=3; a=a+b;//a=5 b=a-b;//b=2 a=a-b;//a=3 printf(\"%d,%d\\n\",a,b); return 0; }\r20.左移右移运算符和条件运算符的优先级\n#include \u003ciostream\u003e using namespace std; int main(){ int a = 99; int b = 100; cout\u003c\u003c(a\u003eb)?a:b; return 0; }\r结果输出为0，因为条件运算符的优先级低于左移运算符，所以先执行了左移运算符，结果为0。\n21.交换地址的高位和地位\n#include \u003cstdio.h\u003e void convert(unsigned int *); int main(){ unsigned int a; printf(\"请输入一个整数：\"); scanf(\"%x\",\u0026a); convert(\u0026a); printf(\"转换后的整数为：%x\\n\",a); return 0; } void convert(unsigned int *a){ unsigned int temp; temp = *a \u0026 0x0f; *a \u0026= 0xf0; *a = (*a \u003e\u003e 4) | (temp \u003c\u003c 4); } 结果： ```c 请输入一个整数：0x3A 转换后的整数为：0xa3\r22.一级指针和二级指针 23.如果从数组x复制50个字节到数组y,最简单的方法是什么？\n#include \u003cstdio.h\u003e int main(){ char x[50] = \"hello world\"; char y[50]; memcpy(y,x,50); printf(\"%s\\n\",y); return 0; }\rmemcpy 是一个用于在内存中复制数据的函数，定义在 C 标准库中的 \u003cstring.h\u003e 头文件中。它的原型如下：\nvoid *memcpy(void *dest, const void *src, size_t n);\r参数说明\ndest：指向目标内存位置的指针，即数据将被复制到的位置。 src：指向源内存位置的指针，即数据将从哪里复制。 n：要复制的字节数。 返回值\n返回指向目标内存位置的指针 dest。\n用途\nmemcpy 函数主要用于在内存中复制数据块，常用于以下场景：\n字符串复制：复制字符串内容。 结构体复制：复制结构体数据。 数组复制：复制数组元素。 使用注意事项\n目标内存必须足够大：确保目标内存区域足够大，能够容纳从源内存复制过来的数据，否则会导致缓冲区溢出。 源和目标内存不能重叠：如果源和目标内存区域有重叠，memcpy 的行为是未定义的。如果需要处理重叠的情况，可以使用 memmove 函数。 类型安全：memcpy 是一个低级别的内存操作函数，不进行类型检查，因此在使用时需要确保数据类型的一致性。 性能考虑：memcpy 通常比手动循环复制更高效，因为它利用了底层硬件的优化。 24.将字符数字转为整形数字\n思路：使用指针取出字符串中的每个字符，然后减去字符'0’的ASCII码值，即可得到对应的整形数字。 编写一个函数来实现这个操作，函数原型如下：\nint ascii_to_integer(const char *str);\r其中，str 是一个指向字符数字字符串的指针，函数返回对应的整形数字。\n#include \u003cstdio.h\u003e int ascii_to_integer(const char *str){ int digit = 0; while(*str \u003e= '0' \u0026\u0026 *str \u003c= '9'){ digit = digit * 10 + (*str - '0'); str++; } if(*str != '\\0') return 0; return digit; } int main(int argc, char *argv[]){ // int digit = ascii_to_integer(argv[1]);//在Linux中可以尝试这样写 char str[100]; printf(\"请输入一串数字字符：\"); scanf(\"%s\",str); printf(\"The digit is: %d\\n\", ascii_to_integer(str)); return 0; }\r24.百钱买百鸡问题\n解题思路如下图： #include \u003cstdio.h\u003e int main(){ int x, y, z; int t; for(t = 0;t\u003c=4;t++){ x = 4 * t; y = 25 - 7 * t; z = 75 + 3 * t; printf(\"cock:%d,hen:%d,chicken:%d-----sum:%d\\n\",x,y,z,x+y+z); } return 0; } 结果： cock:0,hen:25,chicken:75-----sum:100 cock:4,hen:18,chicken:78-----sum:100 cock:8,hen:11,chicken:81-----sum:100 cock:12,hen:4,chicken:84-----sum:100\r25.*和++运算符优先级 二者的运算优先级是一样的。\n#include \u003cstdio.h\u003e int main(){ int arr[10] = {1,2,3,4,5,6,7,8,9}; int *p = arr; for (int i = 0; i \u003c 3; i++){ printf(\"%d\",*p++); } p = arr; printf(\"\\n-------------------------------------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"%d\",*++p); } p = arr; printf(\"\\n-------------------------------------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"%d\",++(*p)); } return 0; }\r26.函数指针类型 27.编写函数实现整数四舍五入 思路：对于正数我们可以加0.5，然后取整； 对于负数则减去0.5，然后取整。\n#include \u003cstdio.h\u003e int round(int num){ if(num \u003e= 0){ return num + 0.5; }else{ return num - 0.5; } } int main(){ int num = 3.6; printf(\"round(%d) = %d\\n\",num,round(num)); return 0; }\r28.下图代码运行结果 29.函数指针数组 附件",
    "description": "网站 “语言网【基础】” “大学慕课对应习题【算法基础】” “牛客竞赛【中等】” “LeetCode【较难】” 课程学习 “书籍” “大学慕课” Github项目 “C/C++面试总结项目” “书籍：Github项目” “C/C++面试总结” “系统设计” 题目笔记 1.cahr *s = \"AAAA\"指针接受一个字符串（右值），当想通过s[0] = ‘B’修改时是无法修改成功的，因为\"AAAA\"只能读，不能写。 2.一般函数内如果返回char s[] = {“abcd”};那么一般会报错，因为这是一个局部变量，但s[]修改为*s就不会有问题。因为 *s指向的地址是固定的。 3.在自动类型转换中：",
    "tags": [
      "C++面试",
      "C++",
      "面经"
    ],
    "title": "1.在线题库练习",
    "uri": "/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "1.在线题库练习网站 “语言网【基础】” “大学慕课对应习题【算法基础】” “牛客竞赛【中等】” “LeetCode【较难】” 课程学习 “书籍” “大学慕课” Github项目 “C/C++面试总结项目” “书籍：Github项目” “C/C++面试总结” “系统设计” 题目笔记 1.cahr *s = \"AAAA\"指针接受一个字符串（右值），当想通过s[0] = ‘B’修改时是无法修改成功的，因为\"AAAA\"只能读，不能写。 2.一般函数内如果返回char s[] = {“abcd”};那么一般会报错，因为这是一个局部变量，但s[]修改为*s就不会有问题。因为 *s指向的地址是固定的。 3.在自动类型转换中：",
    "description": "1.在线题库练习网站 “语言网【基础】” “大学慕课对应习题【算法基础】” “牛客竞赛【中等】” “LeetCode【较难】” 课程学习 “书籍” “大学慕课” Github项目 “C/C++面试总结项目” “书籍：Github项目” “C/C++面试总结” “系统设计” 题目笔记 1.cahr *s = \"AAAA\"指针接受一个字符串（右值），当想通过s[0] = ‘B’修改时是无法修改成功的，因为\"AAAA\"只能读，不能写。 2.一般函数内如果返回char s[] = {“abcd”};那么一般会报错，因为这是一个局部变量，但s[]修改为*s就不会有问题。因为 *s指向的地址是固定的。 3.在自动类型转换中：",
    "tags": [
      "C语言程序"
    ],
    "title": "21.C语言程序设计（含面试）",
    "uri": "/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: C++面试",
    "uri": "/tags/c\u0026#43;\u0026#43;%E9%9D%A2%E8%AF%95/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: C语言程序",
    "uri": "/tags/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: M1-面试",
    "uri": "/categories/m1-%E9%9D%A2%E8%AF%95/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 面经",
    "uri": "/tags/%E9%9D%A2%E7%BB%8F/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 自学课程",
    "uri": "/categories/%E8%87%AA%E5%AD%A6%E8%AF%BE%E7%A8%8B/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "内存分区模型 内存代码区的意义：程序代码放在不同的区域，有程序自动管理的代码，也有程序员管理的代码，灵活管理；\n一、程序执行前\n1.代码区 存放二进制指令，就是代码，特点：\n共享：多个进程的代码区是共享的，因为代码是相同的，所以只需要加载一份到内存中即可，节省内存空间。 只读：代码是只读的，防止程序意外地修改了代码。 2.全局区 全局变量和静态变量存储在全局区，还包括常量区、字符串常量和其他常量（如：const）,特点：\n全局区是程序结束后由系统释放。 全局变量和静态变量在程序结束后系统会自动释放，而局部变量在函数结束后由系统自动释放。 例子：\n#include \u003ciostream\u003e using namespace std; //全局变量 int g_a = 10; int g_b; //const 修饰的全局变量 const int c_g_a = 10; int main(int argc,char *argv[]){ //局部变量 int a = 10; int b = 20; //静态变量 static int s_a = 10; static int s_b; //字符串常量 char *P = \"hello world\"; //const修饰的局部变量 const int c_l_a = 10; cout\u003c\u003c\"局部变量a的地址：\"\u003c\u003c\u0026a\u003c\u003cendl; cout\u003c\u003c\"局部变量b的地址：\"\u003c\u003c\u0026b\u003c\u003cendl; cout\u003c\u003c\"全局变量a的地址：\"\u003c\u003c\u0026g_a\u003c\u003cendl; cout\u003c\u003c\"全局变量b的地址：\"\u003c\u003c\u0026g_b\u003c\u003cendl; cout\u003c\u003c\"静态变量a的地址：\"\u003c\u003c\u0026s_a\u003c\u003cendl; cout\u003c\u003c\"静态变量b的地址：\"\u003c\u003c\u0026s_b\u003c\u003cendl; cout\u003c\u003c\"字符串常量P的地址：\"\u003c\u003cP\u003c\u003cendl; cout\u003c\u003c\"const修饰的局部变量c_l_a的地址：\"\u003c\u003c\u0026c_l_a\u003c\u003cendl; cout\u003c\u003c\"const修饰的全局变量c_g_a的地址：\"\u003c\u003c\u0026c_g_a\u003c\u003cendl; return 0; }\r3.总结\n代码区：存放二进制指令，共享，只读。 全局区：存放全局变量和静态变量，程序结束后由系统释放。 二、程序运行后\n1.栈区\n由编译器自动分配释放，存放函数的参数值，局部变量等。\n注意： 不要返回局部变量的地址，因为局部变量在函数结束后会被系统释放，再次访问会导致程序崩溃。\n例子：\n#include \u003ciostream\u003e using namespace std; int *GetAddr(int b){//形参数据也放在栈区 b = 10; int a = 10; return \u0026a;//返回局部变量的地址 } int main(){ int *p = GetAddr(); cout\u003c\u003c*p\u003c\u003cendl;//第一次可以打印正确的数据，是因为编译器做了保留， cout\u003c\u003c*p\u003c\u003cendl;// 但是第二次访问将不再保留 return 0; }\r2.堆区\n由程序员分配释放，如果程序员不释放，程序结束时由系统回收。\n在C++中主要利用new和delete操作符进行动态内存管理。\n例子1-在堆上开辟空间：\n#include \u003ciostream\u003e using namespace std; int* getAddr(){ //在堆上开辟空间，并初始化为10 int *p = new int(10);//new出来的数据返回的是一个指针 //使用存在栈区的局部指针指向堆区的数据，栈区的内容会被程序自动释放，但是指向堆区的数据不会被释放 return p; } int main(){ int *p = getAddr(); cout\u003c\u003c*p\u003c\u003cendl;//输出10 delete p;//释放空间 return 0; }\r图解： 例子2-堆区上的数据开辟与释放\n#include \u003ciostream\u003e using namespace std; void test(){ int *P = new int(10); cout\u003c\u003c*P\u003c\u003cendl; delete P; } void test2(){ int *arr = new int[10]; for(int i = 0;i\u003c10;i++){ arr[i] = i+10; } for(int i = 0;i\u003c10;i++){ cout\u003c\u003carr[i]\u003c\u003c\" \"; } delete[] arr; } int main(){ test(); }\r引用 给变量取别名。\n一、变量引用\n引用注意事项：\n引用必须初始化，int \u0026b;//这样是不正确的 引用初始化后不能改变 通过引用参数产生的效果与指针地址传递效果一样，引用语法更清楚； 测试代码：\n//值传递 void test1(int a,int b) { } //地址传递 void test2(int *a,int *b) { int temp = *a; *a = *b; *b = temp; } //引用传递 void test3(int \u0026a,int \u0026b) { int temp = a; a = b; b = temp; }\r二、应用做函数的返回值\n不要返回局部变量的引用 函数返回值是引用，那么这个函数调用可以作为左值 测试代码：\n// 二、引用做函数返回值 //1.不能返回应用返回值 int\u0026 test04()//以引用的方式返回b,相当于给这个b起了一个别名 { int b = 10;//局部变量存放在栈区，函数结束后会被释放 return b; } //2. 函数的调用可以作为左值 int\u0026 test05() { static int b = 10;//静态变量存放在全局区，程序结束后由系统自动释放 return b; } int main() { int\u0026 ret04 = test04(); int\u0026 ret05 = test05(); std::cout \u003c\u003c \"ret04= \"\u003c\u003cret04 \u003c\u003c std::endl; std::cout \u003c\u003c \"ret04= \" \u003c\u003c ret04 \u003c\u003c std::endl;//第二次访问返回的是乱码 std::cout \u003c\u003c \"ret05= \" \u003c\u003c ret05 \u003c\u003c std::endl; test05() = 130;//函数的返回是引用，函数的调用可以作为左值 std::cout \u003c\u003c \"ret05= \" \u003c\u003c ret05 \u003c\u003c std::endl; system(\"pause\"); return 0; }\r测试代码结果 三、引用的本质\n引用的本质在C++内部实现是一个指针常量，引用类型必须和引用实体是同类型。\n四、常量引用\n作用：用来修饰形参，防止误操作。\n代码说明：\n//四、常量引用 //int \u0026ref = 10; 这样的操作是不被允许的，因为赋值给引用的是一个字面量,引用需要一个合法的空间， // 程序运行时没有专门为其分配可修改的内存空间 // 但是如果在前面在上const，这条代码就通过 // const int \u0026ref = 10; //用来修饰形参，防止误操作 void test06(const int \u0026val) { //val = 100;不被允许修改 std::cout \u003c\u003c \"val = \" \u003c\u003c val \u003c\u003c std::endl; }\r函数进阶 一、函数默认参数\n返回值 函数名(参数 = 默认值){}\n注意事项：\n1.如果某个位置已经有了默认参数，那么该位置往后都必须有默认参数\n//函数默认参数 void test(int a ,int b = 20,int c = 30) { std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c std::endl; std::cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c std::endl; std::cout \u003c\u003c \"c = \" \u003c\u003c c \u003c\u003c std::endl; }\r2.函数的声明有默认参数，函数实现不能有默认参数,声明和实现只能有一个有默认值\n#include \u003ciostream\u003e //函数声明 void test(int a=10,int b = 20);// //函数实现 void test(int a ,int b) { std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c std::endl; std::cout \u003c\u003c \"b = \" \u003c\u003c b \u003c\u003c std::endl; }\r二、函数占位参数\n作用：为了函数声明和定义的统一 语法：返回类型 函数名(数据类型){}\n//函数占位参数 void test(int a,int)//第二个参数为占位参数 { std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c std::endl; } int main() { test(10,10);//占位参数必须填补,否则无法运行 }\r注意：占位参数可以有默认参数，此时调用时就不用在传值\n//函数占位参数 void test(int a,int = 10)//第二个参数为占位参数，含默认值 { std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c std::endl; } int main() { test(10);//不需要传站位参数 }\r三、函数重载\n满足条件：\n在同一个作用域下。 函数名相同， 参数类型不同， 参数个数不同， 参数顺序不同。 作用： 提高复用性\n注意：\n1.返回值不能作为重载的条件\n2.引用作为重载的条件\n加const和不加是可以重载的\nvoid fun(int \u0026a){ std::cout\u003c\u003c\"fun(int \u0026a)\"\u003c\u003cstd::endl; } void fun(const int \u0026a){ std::cout\u003c\u003c\"fun(const int \u0026a)\"\u003c\u003cstd::endl; } int main(){ int a = 10; const int \u0026b = 20; fun(a);//调用fun(int \u0026a) fun(b);//调用fun(const int \u0026a) fun(10);//调用fun(const int \u0026a) return 0; }\r3.函数重载遇到默认参数\nvoid fun2(int a,int b = 10){ std::cout\u003c\u003c\"fun(int \u0026a)\"\u003c\u003cstd::endl; } void fun2(int a){ std::cout\u003c\u003c\"fun(const int \u0026a)\"\u003c\u003cstd::endl; } int main(){ fun2(10);//此时程序出现二义性，无法确定调用哪个函数 return 0; }\r类和对象的基本概念 C++的特性：封装、多态、继承\n一、基本概念\n抽象：将事物所能进行的的行为归纳出来，形成函数，这些函数可以操作事物归纳后的数据结构。 类： 、 封装 将事物归纳的数据结构和操作该数据结构的算法呈现显而易见的紧密关系，叫封装。\n一、 封装的意义\n1.将属性和行为作为一个整体，表现生活中的事物。\nnamespace test_class { //设计一个圆的类 #define PI 3.14 class Circle { //访问权限 public: //属性 int m_r; //行为 double calculateZC() { return 2 * PI * m_r; } }; void test() { Circle c1; c1.m_r = 10; cout \u003c\u003c \"圆的周长 = \" \u003c\u003c c1.calculateZC() \u003c\u003c endl; } }\r2.访问权限\npublic 公共权限 protected 保护权限 private 私有权限 二、访问权限说明\npublic修饰的成员，可以在类内或者类外直接访问 protected修饰的成员，只能在类内和子类中访问 private修饰的成员，只能在类内访问 继承 多态 类 将数据结构和操作该数据结构的函数捆绑在一起形成一个类。\n在类中使用缺省函数 需要注意避免二义性： 构造函数 类中为什么需要构造函数 构造函数在数组中的使用 class A{ int a; public: A(){std::cout\u003c\u003c\"hello\\n\";}//1 A(int b){std::cout\u003c\u003c\"value: \"\u003c\u003cb\u003c\u003cstd::endl;}//2 } int main(){ A arr[2] = {1}; }\r上面的语句就调用了第1，2个构造函数，首先数据里的1会调用2，而数组的第二个是空值那么就会调用第1个。\n复制构造函数-copy constructor 函数名与类名相同，参数为A(A\u0026 a)或A(const A\u0026 a)（二选一）。\n三种情况下复制构造函数起作用\n同类对象a,b，将a的值初始化b； A a; A b(a); 将类当作参数传入函数； 将类作为返回值； 注意：对象之间的复制是不会导致复制构造函数的\n转换构造函数 什么是转换构造函数 示例代码： 在上面的例子当中，c1 = 9;会被自动转换为调用转换构造函数，如果不想让这样的事情发生，可以在转换构造函数前面加上修饰字段 explicit，这样再次使用c1 = 9;时程序会报错。\n析构函数-destructors 这里补充几点，一个类只能有一个析构函数；\n析构函数与数组：\n数组成员的每一次结束时都会调用析构函数，假设类A数组array[2]，则生命周期结束时会调用两次析构函数。\n析构函数什么时候被调用呢？\nclass CMyclass { public: ~CMyclass() { cout \u003c\u003c \"destructor\" \u003c\u003c endl; } }; CMyclass obj; CMyclass fun(CMyclass sobj ) { //参数对象消亡也会导致析 //构函数被调用 return sobj; //函数调用返回时生成临时对象返回 } int main(){ obj = fun(obj); //函数调用的返回值（临时对象）被 return 0; //用过后，该临时对象析构函数被调用 }\r上面结果输出三个destructor，在fun(CMyclass sobj)参数对象消亡调用析构函数（具体可以联想复制构造函数），会调用一次析构函数；当函数返回赋值给obj后，再次调用析构函数；整个程序结束再次调用析构函数。 this指针 静态成员函数中可以直接使用this指针来代表指向该函数作用的对象的指针\n示例1：\nclass Complex { public: double real, imag; void Print() { cout \u003c\u003c real \u003c\u003c \",\" \u003c\u003c imag ; } Complex(double r,double i):real(r),imag(i) { } Complex AddOne() { this-\u003ereal ++; //等价于 real ++; this-\u003ePrint(); //等价于 Print return * this; } }; int main() { Complex c1(1,1),c2(0,0); c2 = c1.AddOne();//调用AddOne函数后内部this指针变为c1，所以是c1中的read++ return 0; } //输出 2,1 示例2：\nclass A { int i; public: void Hello() { cout \u003c\u003c i \u003c\u003c \"hello\" \u003c\u003c endl; } }; // 翻译为void Hello(A * this ) { cout \u003c\u003c this-\u003ei \u003c\u003c \"hello\"\u003c\u003c endl; } int main() { A * p = NULL; p-\u003eHello(); //翻译为Hello(p); } //编译报错 报错的原因是p指针式一个空指针，它并不指向任何A的对象，所以编译到 this-\u003ei 会报错。\n静态成员变量和函数 基本特点：\n普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。因此静态成员不需要通过对象就能访问。 对第二句话的理解，如下代码示例：\nclass Dog { public: // 普通成员函数 void bark() { std::cout \u003c\u003c \"Woof!\" \u003c\u003c std::endl; } // 静态成员函数 static std::string getSpecies() { return \"Canine\"; } };\r要调用bark我们需要先创建一个Dog的类对象，然后通过 . 调用，也就是非静态成员作用于对象的意思，但是对于 getSpecies 就不需要，可以直接 Dog::getSpecies调用。\n如何访问静态成员？\n类名::成员名 CRectangle::PrintTotal();\n对象名.成员名 CRectangle r; r.PrintTotal();\n指针-\u003e成员名 CRectangle * p = \u0026r; p-\u003ePrintTotal();\n引用.成员名 CRectangle \u0026 ref = r; int n = ref.nTotalNumber;\n设置静态成员变量的目的是什么？\n设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。比如，考虑一个需要随时知道矩形总数和总面积的图形处理程序，可以用全局变量来记录总数和总面积，用静态成员将这两个变量封装进类中，就更容易理解和维护。\n注意事项：\n必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。 成员对象和封闭类 有成员对象的类叫 封闭(enclosing)类。 任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。具体的做法就是：通过封闭类的构造函数的初始化列表。 封闭类的复制构造函数:\nclass A { public: A() { cout \u003c\u003c \"default\" \u003c\u003c endl; } A(A \u0026 a) { cout \u003c\u003c \"copy\" \u003c\u003c endl;} }; class B { A a; }; int main() { B b1,b2(b1);//b2调用自生默认复制构造函数，而内部的A a也会调用默认的复制构造函数 return 0; }\r友元 友元函数: 一个类的友元函数可以访问该类的私有成员。 可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元。 友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。 友元类之间的关系不能传递，不能继承。 常量成员 常量成员函数：内部不能改变属性的值，也不能调用非常量成员函数。\n**注意：**如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，那么，最好将其写成常量成员函数。 mutable成员变量 可以在const成员函数中修改的成员变量\nclass CTest { public: bool GetData() const { m_n1++;//这个值更可以更改 return m_b2; } private: mutable int m_n1; bool m_b2; };\r运算符重载函数 浅拷贝与深拷贝： 为解决这个问题，我们需要修改赋值运算符重载：\nString \u0026 operator = (const String \u0026 s){ if( this == \u0026 s) return * this; delete [] str; str = new char[strlen(s.str)+1]; strcpy( str,s.str); return * this; }\r自增自减运算法重载 class CDemo { private : int n; public: CDemo(int i=0):n(i) { } CDemo \u0026 operator++(); //用于前置形式 CDemo operator++( int ); //用于后置形式 operator int ( ) { return n; } friend CDemo \u0026 operator--(CDemo \u0026 ); friend CDemo operator--(CDemo \u0026 ,int); }\roperator int ( ) {return n;}\n这里，int 作为一个类型强制转换运算符被重载, 此后\nDemo s; (int) s ; //等效于 s.int(); 类型强制转换运算符被重载时不能写返回值类型，实际上其返回值类型就是该类型强制转换运算符代表的类型。\n继承和派生 **注意：**在派生类的各个成员函数中，不能访问基类中的private成员。\n派生类的内存空间 类之间的关系 继承：“是”关系。\n基类 A，B是基类A的派生类。 逻辑上要求：“一个B对象也是一个A对象”。 复合：“有”关系。\n类C中“有”成员变量k，k是类D的对象，则C和D是复合 关系 一般逻辑上要求：“D对象是C对象的固有属性或组成部 分” 复合关系的示例： 基类与派生类名字重名的情况 一般来说，基类和派生类不定义同名成员变量。但如果要方位可以使用基类::基类成员来访问。\n访问权限 • 基类的private成员：可以被下列函数访问\n基类的成员函数 基类的友元函数 • 基类的public成员：可以被下列函数访问\n基类的成员函数 基类的友元函数 派生类的成员函数 派生类的友元函数 其他的函数 • 基类的protected成员：可以被下列函数访问\n基类的成员函数 基类的友元函数 派生类的成员函数可以访问当前对象和其它对象的基类的保护成 举一个例子：\nclass Father { private: int nPrivate; //私有成员 public: int nPublic; //公有成员 protected: int nProtected; // 保护成员 }; class Son :public Father{ void AccessFather () { nPublic = 1; // ok; nPrivate = 1; // wrong nProtected = 1; // OK，访问从基类继承的protected成员 Son f; f.nProtected = 1; //ok，派生类的成员函数可以访问当前对象和其它对象的基类的保护成 } }; int main(){ Father f; Son s; f.nPublic = 1; // Ok s.nPublic = 1; // Ok f.nProtected = 1; // error，因为只能在派生类（或友元类）中访问 f.nPrivate = 1; // error s.nProtected = 1; //error s.nPrivate = 1; // error return 0; }\r派生类构造函数中包含成员变量时该如何写？ class Bug { private : int nLegs; int nColor; public: int nType; Bug ( int legs, int color); void PrintBug (){ }; }; class Skill { public: Skill(int n) { } }; class FlyBug: public Bug { int nWings; Skill sk1, sk2; public: FlyBug( int legs, int color, int wings); }; FlyBug::FlyBug( int legs, int color, int wings): Bug(legs,color),sk1(5),sk2(color) ,nWings(wings) { }//注意这种写法。 private 和 protected的继承 • protected继承时，基类的public成员和protected成员成为派生类的protected成员。 • private继承时，基类的public成员成为派生类的private成员，基类的protected成员成 为派生类的不可访问成员。 • protected和private继承不是“是”的关系。\n问题：\n即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有，而派生类中有的成员。\n解决办法：\n通过强制指针类型转换，可以把ptrBase转换成Derived类的指针\nBase * ptrBase = \u0026objDerived; Derived *ptrDerived = (Derived * ) ptrBase;\r程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会出错。\n虚函数和多态 多态的表现形式 派生类的指针（或引用）可以给基类赋值。 当指针指向基类时调用，基类的函数，当指针指向派生类时，调用调用派生类的函数，这叫做多态。 另外，在非虚函数和非构造、析构函数中调用虚函数，也叫做多态。 例子： 如果在构造、析构函数中调用虚函数，那么会怎么样呢？\n如果这么做，那么编译器只会调用当前的虚函数，如果当前没有重写虚函数，则会从基类中找进行调用，为什么要这么做呢？其实这是为了防止未初始化就调用派生类的虚函数的情况。\n你想想啊，一类的初始化先从基类的构造函数开始，如果这个时候构造函数具有多态性，那么此时将调用派生类的对应虚函数，但是派生类这个时候都还没有初始化。\n例子： `\n补充：在上面的图例子中，派生类写了与基类虚函数相同的名字，但是没有在前面加修饰符virtual，这种情况编译器认为是虚函数。 多态的作用 在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。\n虚函数的访问权限 动态联编的实现机制 “多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定 —- 这叫“动态联编”。\n每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的。 下面一段代码将验证，对象的首地址是存了虚函数表的地址的：\n#include \u003ciostream\u003e using namespace std; class A { public: virtual void Func() { cout \u003c\u003c \"A::Func\" \u003c\u003c endl; } }; class B:public A { public: virtual void Func() { cout \u003c\u003c \"B::Func\" \u003c\u003c endl; } }; int main() { A a; A * pa = new B(); pa-\u003eFunc(); //64位程序指针为8字节 long long * p1 = (long long * ) \u0026 a; long long * p2 = (long long * ) pa; * p2 = * p1; pa-\u003eFunc(); return 0; }\r纯虚函数和抽象类 纯虚函数：没有函数体的虚函数 抽象类：有纯虚函数的类 注意：\n包含纯虚函数的类叫抽象类 抽象类只能作为基类来派生新类使用，不能创建独立的抽象类的对象 抽象类的指针和引用可以指向由抽象类派生出来的类的对象 A a ; // 错，A 是抽象类，不能创建对象 A * pa ; // ok,可以定义抽象类的指针和引用 pa = new A ; //错误, A 是抽象类，不能创建对象 在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。 附件",
    "description": "内存分区模型 内存代码区的意义：程序代码放在不同的区域，有程序自动管理的代码，也有程序员管理的代码，灵活管理；\n一、程序执行前\n1.代码区 存放二进制指令，就是代码，特点：",
    "tags": [
      "C++",
      "C",
      "基础知识",
      "基本概念"
    ],
    "title": "14.新标准C加加程序设计",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: C",
    "uri": "/tags/c/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: R1-编程语言",
    "uri": "/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 基本概念",
    "uri": "/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 基础知识",
    "uri": "/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r20.C++面试",
    "content": "网络编程 网络原理 数据库 C++基础 1.左值引用和右值引用\n数据湖结构与算法 附件",
    "description": "网络编程 网络原理 数据库 C++基础 1.左值引用和右值引用\n数据湖结构与算法 附件",
    "tags": [
      "C++面试",
      "C++",
      "面经"
    ],
    "title": "1.网络编程",
    "uri": "/class/20.c%E5%8A%A0%E5%8A%A0%E9%9D%A2%E8%AF%95/1.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "1.网络编程网络编程 网络原理 数据库 C++基础 1.左值引用和右值引用\n数据湖结构与算法 附件",
    "description": "1.网络编程网络编程 网络原理 数据库 C++基础 1.左值引用和右值引用\n数据湖结构与算法 附件",
    "tags": [
      "C++面试"
    ],
    "title": "20.C++面试",
    "uri": "/class/20.c%E5%8A%A0%E5%8A%A0%E9%9D%A2%E8%AF%95/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "指针 指针的声明： 数组 数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义： 2.字符串文字量\n指的是用 ““括起来的字符串。\n长字符串编写： 带有L的字符是宽字符，如L\"sddsf”，类型是const wchar_t. 3.指向数组的指针\n4.常量 5.指针和常量\n使用一个指针时涉及到两个对象:该指针本身和被它所指的对象。将一个指针的声明用cons“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，我们必须使用声明运算符*const，而不能只用简单的const。\n定义常量指针的声明运算符是const。并没有cons** 声明符，所以出现在之前的conr是作为基础类型的一部分。例如\n// 到char的hconst指针 char *const cp; char const* pc; // 到const char的指针 const char* pc2; //到const char的指针 有人发现从右向左读这种定义很有帮助。例如，“cp是一个conse指针到char”，以及“pe2是一个指针措到const chor”\n引用 void f(){ int ii=1; int \u0026rr = ii; rr++;//实际上是ii++,rr不能像指针一样操作。 int *pp = \u0026ii; }\r附件",
    "description": "指针 指针的声明： 数组 数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义： 2.字符串文字量\n指的是用 ““括起来的字符串。",
    "tags": [
      "C++",
      "C",
      "基础知识",
      "基本概念"
    ],
    "title": "13.从C到C++",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "为什么需要哈希函数？ 哈希函数在计算机科学中扮演着重要的角色，其主要作用包括：\n数据检索：哈希函数可以将键（key）映射到哈希表中的一个位置，从而快速检索数据。这是哈希表（如 C++ 中的 std::unordered_map 和 std::unordered_set）的基础。\n快速比较：在数据库和各种数据结构中，哈希函数可以快速比较字符串或对象，常用于检查两个字符串是否相等。\n数据分布：在分布式系统中，哈希函数可以将数据均匀地分布到多个节点上，以实现负载均衡。\n密码学应用：在密码学中，哈希函数用于生成数据的摘要，用于数据完整性验证和数字签名。\n缓存实现：哈希函数可以用于实现缓存机制，通过快速定位缓存中的数据。\n负载均衡：在网络流量管理中，哈希函数可以用于将请求分配到不同的服务器上。\nC++ 库中哈希函数的实现和底层逻辑 在 C++11 及以后的版本中，标准库提供了一个专门的哈希函数库 \u003cfunctional\u003e，其中包含了 std::hash 模板类。std::hash 为基本数据类型（如 int、double、std::string 等）提供了特化版本。\n实现底层逻辑： 整数类型：对于整数类型，std::hash 直接返回数值本身或其变体。例如，对于 int 类型，std::hash\u003cint\u003e()(10) 可能直接返回 10 或者 10 的一个简单变换。\n浮点类型：对于浮点类型，std::hash 通常会将浮点数的位表示转换为整数，然后应用整数的哈希函数。\n字符串类型：对于字符串，std::hash 通常会遍历字符串中的每个字符，将每个字符的哈希值组合起来，生成最终的哈希值。这可以通过位操作和数学函数（如乘法、加法、异或等）来实现。\n自定义类型：对于自定义类型，如果需要使用 std::hash，则需要为该类型提供自定义的哈希函数。\n组合哈希：对于复合类型（如结构体或类），哈希函数需要将各个成员的哈希值组合起来。这通常通过将成员的哈希值进行某种形式的数学运算（如加权求和、异或等）来实现。\n均匀分布：一个好的哈希函数应该能够产生均匀分布的哈希值，以减少哈希冲突。\n确定性：哈希函数应该是确定性的，即对于同一个输入总是产生相同的哈希值。\n快速计算：哈希函数的计算应该尽可能快，以减少对性能的影响。\n在 C++ 中，std::hash 的实现可能因编译器和平台而异，但基本原理是相似的。正确实现哈希函数对于哈希表的性能至关重要，因为它直接影响到哈希表的冲突率和检索效率。\nhash function-哈希函数 如果要自己给自己的数据写一个哈希函数，那又该怎么写呢？能否基于这些数据计算出hash code的呢？\n编写模版规范 ​\r类型1\r类型1示例\r类型2\r类型3\r#include \u003cfunctional\u003e namespace test_hash_function { class Customer { private: string fname; string lname; int on; public: Customer( string fn, string ln, int id) : fname(fn), lname(ln), on(id) {} bool operator==(const Customer\u0026 other) const {//需要重载== return fname == other.fname \u0026\u0026 lname == other.lname \u0026\u0026 on == other.on; } friend class CustomerHash; }; class CustomerHash { public: std::size_t operator()(const Customer\u0026 c) const { return ...; } }; unordered_set\u003cCustomer, CustromerHash\u003e custsct; }\r#include \u003cfunctional\u003e namespace test_hash_function { template \u003ctypename T\u003e inline void hash_combine(size_t\u0026 seed, const T\u0026 val) { seed ^= hash\u003cT\u003e()(val) + 0x9e3779b9 + (seed \u003c\u003c 6) + (seed \u003e\u003e 2); } template \u003ctypename T\u003e inline void hash_val(size_t\u0026 seed, const T\u0026 val) { hash_combine(seed, val); } template \u003ctypename T, typename... Types\u003e inline void hash_val(\tsize_t\u0026 seed, const T\u0026 val, const Types\u0026... args) { hash_combine(seed, val); hash_val(seed, args...); } template \u003ctypename... Types\u003e inline size_t hash_val(const Types\u0026... args) { size_t seed = 0; hash_val(seed, args...); return seed; } class Customer { private: string fname; string lname; int on; public: Customer( string fn, string ln, int id) : fname(fn), lname(ln), on(id) {} bool operator==(const Customer\u0026 other) const { return fname == other.fname \u0026\u0026 lname == other.lname \u0026\u0026 on == other.on; } friend class CustomerHash; }; class CustomerHash { public: size_t operator()(const Customer\u0026 c) const { return hash_val(c.fname, c.lname, c.on); } }; void test() { unordered_set\u003cCustomer, CustomerHash\u003e s; s.insert(Customer(\"Asd\", \"dfw\", 1L)); s.insert(Customer(\"Dfg\", \"kjt\", 2L)); s.insert(Customer(\"VVB\", \"ert\", 3L)); s.insert(Customer(\"TgR\", \"uik\", 4L)); s.insert(Customer(\"Gdf\", \"pii\", 5L)); s.insert(Customer(\"Gdf\", \"pii\", 6L)); s.insert(Customer(\"Gdf\", \"pii\", 7L));//8 cout \u003c\u003c s.bucket_count() \u003c\u003c endl; CustomerHash hh; cout \u003c\u003c hh(Customer(\"Asd\", \"dfw\", 1L)) % 8 \u003c\u003c endl;//4 cout \u003c\u003c hh(Customer(\"Dfg\", \"kjt\", 2L)) % 8 \u003c\u003c endl;//0 cout \u003c\u003c hh(Customer(\"VVB\", \"ert\", 3L)) % 8 \u003c\u003c endl;//3 cout \u003c\u003c hh(Customer(\"TgR\", \"uik\", 4L)) % 8 \u003c\u003c endl;//7 cout \u003c\u003c hh(Customer(\"Gdf\", \"pii\", 5L)) % 8 \u003c\u003c endl;//2 cout \u003c\u003c hh(Customer(\"Gdf\", \"pii\", 6L)) % 8 \u003c\u003c endl;//7 cout \u003c\u003c hh(Customer(\"Gdf\", \"pii\", 7L)) % 8 \u003c\u003c endl;//4 for (unsigned i = 0; i \u003c s.bucket_count(); i++) { cout \u003c\u003c \"bucked #\" \u003c\u003c i \u003c\u003c \"has\" \u003c\u003c s.bucket_size(i) \u003c\u003c \"element\\n\"; } } } // bucked #0has1element // bucked #1has0element // bucked #2has1element // bucked #3has1element // bucked #4has2element // bucked #5has0element // bucked #6has0element // bucked #7has2element #include \u003cfunctional\u003e namespace test_hash_function { class Customer { private: string fname; string lname; int on; public: Customer( string fn, string ln, int id) : fname(fn), lname(ln), on(id) {} bool operator==(const Customer\u0026 other) const {//需要重载== return fname == other.fname \u0026\u0026 lname == other.lname \u0026\u0026 on == other.on; } friend class CustomerHash; }; class CustomerHash { public: size_t customer_hash_func(const Customer\u0026 c) const { return ...; } }; unordered_set\u003cCustomer, size_t(*)(const Custromer\u0026)\u003e custsct(20,customer_hash_func);//注意与类型1的不同写法 }\r第三种方式是对类里面的hash进行偏特化，比如你使用了unordered_set那么对于它的Hash，可以单独进行偏特化。 tuple 在C++中，tuple 是一个标准库模板类，它提供了一种方式来存储不同类型数据的集合。tuple 类似于一个固定大小的数组，但是数组中的每个元素可以是不同的类型。这个特性使得 tuple 非常灵活，可以用于多种场景。\n附件",
    "description": "为什么需要哈希函数？ 哈希函数在计算机科学中扮演着重要的角色，其主要作用包括：\n数据检索：哈希函数可以将键（key）映射到哈希表中的一个位置，从而快速检索数据。这是哈希表（如 C++ 中的 std::unordered_map 和 std::unordered_set）的基础。",
    "tags": [],
    "title": "12.其他库的介绍",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "整体框架的回顾 存在多种适配器-adapters 一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知道该容器需要迭代器，也就是一些智能指针来确定容器的头尾，以及内容位置，目的是方便后续的算法的怎删改查等操作，假设算法现在要做拿到位置8的数据，那么vector的指针要怎么移动呢？已知指针移动上，vector是随机访问指针，也就是前后都可以跑，而这个操作实际上是迭代器的其中一个内容，而这一内容就需要一个适配器去做适配。\n下面做一个模拟问答，来加以了解：\n—c 模拟问答 算法：你好，vector的迭代器，我需要知道你的迭代器类别，这样我才能正确地进行操作。\nvector的迭代器：好的，我先问一下我的适配器。\rvector的迭代器：适配器，算法想知道 iterator_traits\u003cInputIterator\u003e::iterator_category 是什么类型的迭代器？\rvector_iterator的适配器：你好，我们这里是随机访问迭代器（Random Access Iterator）。\r算法：太好了，随机访问迭代器可以让我进行更高效的操作。那么，如果我想访问第8个元素，我该怎么做？\rvector_iterator的适配器：很简单，你可以直接通过加上偏移量来访问第8个元素。比如，如果你有一个指向第一个元素的迭代器 first，那么 first + 7（因为迭代器是从0开始计数的）就会给你第8个元素的迭代器。\r算法：明白了，那我可以直接使用 *(first + 7) 来获取第8个元素的值了。\rvector_iterator的适配器：是的，完全正确。\r算法：如果我需要反向迭代器，或者插入迭代器，你们能提供吗？\rvector_iterator的适配器：当然可以。我们 vector 提供了多种迭代器适配器，包括反向迭代器（reverse_iterator）、插入迭代器（insert_iterator）等，以满足不同的需求。\r算法：那太好了，这样我可以更灵活地处理 vector 中的数据了。谢谢你的帮助！\rSTL中适配器的重要特性 对于容器、迭代器和仿函数它们第二次迭代器都有一个重要的特性，就是适配器会包含（也有继承）对应的类，比如stack包含了deque，然后使用了deque的某些功能，屏蔽了deque的某些某能，实现了先进后出的功能。\n仿函数适配器 binder2nd适配器 该适配器是用于绑定的，比如对于一个容器，需要操作比88小于数，这使用可以用binder2nd，第一个参数可以传入比较大小的less仿函数，第二个传入比较的数值x，本质上在binder2nd中，less的第二个参数传入就是x,这样就达到比较的目的了。 小结：把A类和数值a传入另一个类B中，在B中再操作A和a.这样就实现了绑定。\nnot1 对结果取反 一些新的适配器 bind 迭代器适配器 reverse——iterator 三个细节：\n1.begin=rend,end=rbigin 2.取值是取后一个，所以内部实现的*是做–操作； 3.operate ++()操作重载后内部实现为–，operate –()重载后内部实现++操作。 具体图下图所示 insert_iterator 在下面的案例中copy(bar.begin(),bar.end(),inserter(foo,it));欲将list的bar数据从it指向的位置 开始插入，但是foo的空间不够，为什么还能成功？\n设计的小技巧，当传入copy中时，因为inserter对operate =()做了重载，重载中调用了insert()该函数能决绝以上问题， 因此不会因为foo的内存不足导致插入失败。 ostream_iterator 下面通过一个案例说明该迭代器的一些特性和使用方法：\n1.当执行初始化操作std::ostream_iterator out_it(std::cout,\",\")时调用构造函数，并初始化。 2.执行copy操作时，因为ostream_iterator对operate =()重载，所以会将值value传给*out_stream，通过这个方法把数据打印在屏幕上。 istream_iterator 下面也是两个例子说明istream_iterator的特性：\n1.std::istream_iterator\u003cdouble\u003e iit(std::cin);时同样会调用对应的构造函数，并且此处会调用operate ++()重载，在该重载中，*in_stream接收按键输入的一个值，也就是说才定义时，就已经在准备接收一个值，如果此时在该语句下写一段打印操作没见无法看到输出！ 2.下面是copy操作，对于这个操作，我们可以观察是否有对*和=的操作符进行重载，对于=的重载上述已经介绍， *的重载是将value返回，也就是 *first的操作取得的是容器中的值。 附件",
    "description": "整体框架的回顾 存在多种适配器-adapters 一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知道该容器需要迭代器，也就是一些智能指针来确定容器的头尾，以及内容位置，目的是方便后续的算法的怎删改查等操作，假设算法现在要做拿到位置8的数据，那么vector的指针要怎么移动呢？已知指针移动上，vector是随机访问指针，也就是前后都可以跑，而这个操作实际上是迭代器的其中一个内容，而这一内容就需要一个适配器去做适配。",
    "tags": [],
    "title": "11.STL库学习之适配器",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "仿函数的个人理解 仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了operate()，当调用这个类的()时就会返回响应的数据。\n你的理解是正确的，仿函数（functor）是 C++ 中的一个概念，它指的是那些可以像函数一样被调用的对象。这些对象通常重载了函数调用操作符 operator()，使得对象可以被当作函数来使用。以下是对你描述的一些补充说明：\n仿函数的特点 重载 operator()：仿函数类必须重载函数调用操作符 operator()，这样对象就可以被像函数那样调用。\n可以携带状态：与普通函数不同，仿函数可以拥有成员变量，这意味着它们可以携带状态。这些状态可以是私有的，也可以是公开的，取决于仿函数的设计。\n可以进行重载：仿函数可以重载 operator()，以接受不同数量和类型的参数。\n可以定义在类中：仿函数可以是类的成员函数，也可以是独立的类。\n可以有返回值：当仿函数被调用时，可以返回一个值，就像普通函数那样。\n可以作为参数传递：由于仿函数可以像函数一样被调用，它们可以作为参数传递给接受函数作为参数的函数。\n仿函数的应用 算法的参数：仿函数经常用作 STL 算法的参数，例如 std::sort 和 std::find_if，因为这些算法需要一个可以被调用的实体来比较元素或测试条件。\n回调函数：在事件驱动的编程中，仿函数可以作为回调函数，响应特定的事件。\n策略模式：在设计模式中，仿函数可以用于实现策略模式，允许算法的行为在运行时动态改变。\n简化代码：通过使用仿函数，可以减少函数指针和全局函数的使用，使得代码更加简洁和易于管理。\n示例代码 struct Max { // 重载()操作符，使其可以被调用 int operator()(int a, int b) const { return (a \u003e b) ? a : b; } }; int main() { Max max_functor; int result = max_functor(10, 20); // 使用仿函数对象调用 std::cout \u003c\u003c \"Max value: \" \u003c\u003c result \u003c\u003c std::endl; return 0; }\r在这个例子中，Max 是一个仿函数，它重载了 operator() 来比较两个整数并返回最大值。然后，我们可以像调用函数一样调用 max_functor 对象。\n仿函数内部一般设计什么？ 仿函数一般重载operate()后，会在内部设计运算操作，如算数、逻辑、相对关系等运算。如下图所示。 从上面一张图也可以发现，plus,minus,logical_and,equal_to,less类都集成了binary_function，该类的作用是什么呢？\nstd::binary_function 的主要作用是：\n泛型框架：提供一个泛型框架，允许函数对象接受任意类型的参数。 类型转换：允许参数类型和返回类型的转换，使得函数对象可以用于不同的数据类型。 模板编程：支持模板编程，使得可以创建通用的算法和函数。 原型 std::binary_function 的原型如下：\ntemplate \u003cclass Arg1Type, class Arg2Type, class ResultType\u003e struct binary_function { typedef Arg1Type first_argument_type; typedef Arg2Type second_argument_type; typedef ResultType result_type; };\rArg1Type：第一个参数的类型。\nArg2Type：第二个参数的类型。\nResultType：函数返回值的类型。\n继承和使用\n函数对象如 std::plus, std::minus, std::logical_and, std::equal_to, std::less 等都继承自 std::binary_function。这意味着这些函数对象都定义了 first_argument_type, second_argument_type, 和 result_type 这三个类型别名，它们分别表示函数对象接受的第一个参数类型、第二个参数类型和返回值类型。\n关于 std::binary_function的具体细节在适配器一节会重点讲到。\n下图是是否继承binary_function的一些示例，如果不继承会怎么样呢？以我个人的理解，继承会让仿函数的扩展性更高，它将来可以扩展出更好的功能。如下图所示。 除了上面讲到的binary_function还有unary_function，该类是针对单个变量的操作，比如取反，加加。如下图： 关于binary_function的细节此处先不介绍，下一节将着重说明。\n对于仿函数，鲜明的特点就是对operate()做了重载，这样的类创建出来的对象叫仿函数对象，具有函数的行为。如果要对重载做更多操作需要结合一些仿函数适配器，比如相面讲到的binary_function和unary_funtion。\n附件",
    "description": "仿函数的个人理解 仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了operate()，当调用这个类的()时就会返回响应的数据。",
    "tags": [],
    "title": "10.STL库学习之仿函数",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "标准库常用算法 迭代器 迭代器-的分类 struct input_iterator_tag {}； struct output_iterator_tag {}; struct forward_iterator_tag:public input_iterator_tag{}; struct bidirectional_iterator_tag:public forward_iterator_tag{}; struct random_access_tag:public bidirectional_iterator_tag {};\r以上5中迭代器的继承关系，如下图所示。 1.Input Iterator（输入迭代器）： 输入迭代器是最基本的迭代器类型，支持单向遍历，只能向前移动。\n用法示例：\nstd::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; std::input_iterator\u003cint\u003e it = vec.begin(); while (it != vec.end()) { std::cout \u003c\u003c *it \u003c\u003c \" \"; ++it; }\r2.Forward Iterator（前向迭代器）： 前向迭代器支持双向遍历，可以向前和向后移动。\n用法示例：\nstd::list\u003cint\u003e lst = {1, 2, 3, 4, 5}; std::forward_iterator\u003cint\u003e it = lst.begin(); while (it != lst.end()) { std::cout \u003c\u003c *it \u003c\u003c \" \"; ++it; }\r3.Output Iterator（输出迭代器）： 输出迭代器允许对容器中的元素进行写操作，但不支持读操作。\n用法示例：\nstd::vector\u003cint\u003e vec; std::back_insert_iterator\u003cstd::vector\u003cint\u003e\u003e it(vec); *it = 1; // 写操作 ++it; *it = 2; // 写操作 4.Bidirectional Iterator（双向迭代器）： 双向迭代器支持双向遍历，可以向前和向后移动。\n用法示例：\nstd::list\u003cint\u003e lst = {1, 2, 3, 4, 5}; std::bidirectional_iterator\u003cint\u003e it = lst.end(); while (it != lst.begin()) { --it; std::cout \u003c\u003c *it \u003c\u003c \" \"; }\r5.Random Access Iterator（随机访问迭代器）： 随机访问迭代器支持任意位置的快速访问，类似于指针操作。\n用法示例：\nstd::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; std::random_access_iterator\u003cint\u003e it = vec.begin(); it += 2; // 随机访问 std::cout \u003c\u003c *it \u003c\u003c \" \";\r各种容器的迭代器类型 测试代码：\n#include \u003citerator\u003e namespace test_iterator_category { template \u003ctypename T\u003e void display_category(T itr) { typename iterator_traits\u003cT\u003e::iterator_category cagy; // 使用 std::iterator_traits 获取迭代器类别 // 这里不需要递归调用 display_iterator 函数 cout \u003c\u003c typeid(cagy).name() \u003c\u003c endl; } void test() { cout \u003c\u003c \"\\ntest_iterator_category....................\\n\"; display_category(array\u003cint, 10\u003e::iterator()); display_category(vector\u003cint\u003e::iterator()); display_category(list\u003cint\u003e::iterator()); display_category(forward_list\u003cint\u003e::iterator()); display_category(deque\u003cint\u003e::iterator()); display_category(set\u003cint\u003e::iterator()); display_category(map\u003cint, int\u003e::iterator()); display_category(multiset\u003cint\u003e::iterator()); display_category(multiset\u003cint, int\u003e::iterator()); display_category(istream_iterator\u003cint\u003e()); display_category(ostream_iterator\u003cint\u003e(cout,\"\")); } }\r此处可以参考一下display_category(array\u003cint, 10\u003e::iterator());中传递array\u003cint, 10\u003e::iterator()的方法。\n测试结果：\ntest_iterator_category.................... struct std::random_access_iterator_tag struct std::random_access_iterator_tag struct std::bidirectional_iterator_tag struct std::forward_iterator_tag struct std::random_access_iterator_tag struct std::bidirectional_iterator_tag struct std::bidirectional_iterator_tag struct std::bidirectional_iterator_tag struct std::bidirectional_iterator_tag struct std::input_iterator_tag struct std::output_iterator_tag\r迭代器对算法的影响 例子1-distance 迭代器如何计算容器元素之间的距离呢？当调用迭代器时，迭代器是如何操作以协助算法完成后续的增删改查的？\n在计算距离方面，我们可以看到调用接口需要传入容器的头，以及容器尾部，接着使用：\n... typedef typename iterator_traits\u003cInputIterator\u003e::itrerator_category category; return __distance(first,last, category);\rtypedef typename iterator_traits\u003cInputIterator\u003e::itrerator_category category;这一句会判断迭代器的类型，进而执行加操作或一步一步加操作。详细如下图所示。 例子2-copy copy的动作也不仅仅是对迭代器类型的判断，还做了许多特化、偏特化。如下图所示。 例子3-destroy 例子4-__unique_copy 对传入的迭代器类型的暗示 在调用一些需要传入迭代器的函数时，从函数的形参名可以判断传入的迭代器类型，如InputIterator，由于forward_iterator_tag、bidirection_iterator_tag、random_asccess_iterator_tag与input_iterator的继承关系可知，前三者都可以传入，以此类推如果形参是forward_iterator_tag那么除了其本身，bidirection_iterator_tag、random_asccess_iterator_tag也可传入。\n算法源码剖析 accumulate-累计 测试用例：\n#include \u003cfunctional\u003e//std::minus #include \u003cnumeric\u003e//std::accumulate namespace test_accumulate { int myfcn(int x, int y) { return x + 2 * y; } struct myclass { int operator()(int x, int y) { return x + 3 * y; } } myobj; } void test(){ int init = 10; int nums[] = {10,10,10}; cout \u003c\u003c accumulate(nums, nums + 3, init)\u003c\u003cendl;//40 cout \u003c\u003c accumulate(nums, nums + 3, init, test_accumulate::myfcn)\u003c\u003cendl;//70 cout \u003c\u003c accumulate(nums, nums + 3, init, test_accumulate::myobj) \u003c\u003c endl;//100 }\rfor_each 拿到每一个元素时都对该元素执行某一操作。 测试用例：\nnamespace test_for_each { void myfcn(int i) { cout\u003c\u003ci\u003c\u003c\"-\"; } struct myclass { void operator()(int i) { cout \u003c\u003c \"[\" \u003c\u003c i\u003c\u003c\"] \"; } } myobj; void test() { vector\u003cint\u003e c; c.push_back(10); c.push_back(20); c.push_back(30); for_each(c.begin(), c.end(), test_for_each::myfcn);//10-20-30- cout \u003c\u003c \"\\n\"; for_each(c.begin(), c.end(), test_for_each::myobj);//[10] [20] [30] } }\rreplace,replace_if,rreplace_copy replace用于将新值替换为旧值，例如将数组中所有的8替换为9.详细源码如下图所示。 replace、replace_if 和 replace_copy 是 C++ 标准库中的算法，它们用于在容器或数组中替换元素。这些函数属于 \u003calgorithm\u003e 头文件。下面是每个函数的详细介绍和作用：\n1. replace replace 函数用于将容器中所有满足特定条件的元素替换为另一个值。这个函数直接在原容器上操作，不创建新的容器。\n函数原型:\nvoid replace(ForwardIterator first, ForwardIterator last, const T\u0026 old_value, const T\u0026 new_value);\rfirst, last：定义了要替换元素的范围。 old_value：要被替换的值。 new_value：替换后的值。 示例:\nvector\u003cint\u003e v = {1, 2, 3, 4, 3, 2}; replace(v.begin(), v.end(), 2, 5); // v 变为 {1, 5, 3, 4, 3, 5} 2. replace_if replace_if 函数用于将容器中满足特定条件的元素替换为另一个值。与 replace 不同，replace_if 需要一个谓词（条件函数），只有满足这个条件的元素才会被替换。这个函数也直接在原容器上操作。\n函数原型:\nvoid replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T\u0026 new_value);\rfirst, last：定义了要替换元素的范围。 pred：一个谓词函数，返回 true 表示替换，false 表示不替换。 new_value：替换后的值。 示例:\nvector\u003cint\u003e v = {1, 2, 3, 4, 3, 2}; replace_if(v.begin(), v.end(), [](int i) { return i == 2; }, 5); // v 变为 {1, 5, 3, 4, 3, 5} 3. replace_copy replace_copy 函数用于将容器中所有满足特定条件的元素复制到另一个容器中，并替换为另一个值。这个函数不会改变原容器，而是创建一个新的容器，其中包含替换后的元素。\n函数原型:\ntemplate \u003cclass InputIterator, class OutputIterator\u003e OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T\u0026 old_value, const T\u0026 new_value);\rfirst, last：定义了要替换元素的范围。 result：指向目标容器的迭代器，用于存储替换后的元素。 old_value：要被替换的值。 new_value：替换后的值。 示例:\nvector\u003cint\u003e v = {1, 2, 3, 4, 3, 2}; vector\u003cint\u003e v2(v.size()); replace_copy(v.begin(), v.end(), v2.begin(), 2, 5); // v 保持不变，v2 变为 {1, 5, 3, 4, 3, 5} count，count_if 源代码如下： 小结： find，find_if sort binary_search 算法原理：\n二分查找的基本思想是将一个有序序列分为两半，通过比较中间元素和目标值来缩小搜索范围。如果中间元素正好是目标值，则查找成功；如果目标值小于中间元素，则在序列的左半部分继续查找；如果目标值大于中间元素，则在右半部分继续查找。这个过程不断重复，直到找到目标值或搜索范围为空。\n函数原型：\nbinary_search 的函数原型如下：\ntemplate \u003cclass ForwardIterator, class T\u003e bool binary_search(ForwardIterator first, ForwardIterator last, const T\u0026 value);\rfirst, last：定义了要搜索的范围，first 是序列的开始迭代器，last 是序列的结束迭代器（指向序列末尾的下一个位置）。 value：要查找的值。 返回值：\n如果在序列中找到 value，则返回 true。 如果没有找到，则返回 false。 示例代码：\n#include \u003calgorithm\u003e #include \u003cvector\u003e #include \u003ciostream\u003e int main() { std::vector\u003cint\u003e data = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int target = 5; bool found = std::binary_search(data.begin(), data.end(), target); if (found) { std::cout \u003c\u003c \"Element found in the array.\" \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"Element not found in the array.\" \u003c\u003c std::endl; } return 0; }\r注意事项：\n有序序列：binary_search 要求序列必须是有序的，否则查找结果将不可预测。 效率：二分查找的时间复杂度为 O(log n)，其中 n 是序列中的元素数量。这使得它比线性查找（O(n)）更高效，尤其是在大数据集上。 稳定性：如果存在多个相同的目标值，binary_search 将返回第一个匹配的位置。如果需要找到所有匹配项，可能需要使用其他方法。 附件",
    "description": "标准库常用算法 迭代器 迭代器-的分类 struct input_iterator_tag {}； struct output_iterator_tag {}; struct forward_iterator_tag:public input_iterator_tag{}; struct bidirectional_iterator_tag:public forward_iterator_tag{}; struct random_access_tag:public bidirectional_iterator_tag {};\r以上5中迭代器的继承关系，如下图所示。 1.Input Iterator（输入迭代器）： 输入迭代器是最基本的迭代器类型，支持单向遍历，只能向前移动。",
    "tags": [],
    "title": "9.STL库学习之迭代器与算法",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "list vector deque deque的迭代器 deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用push_front()（push_back()）,否则借助insert_aux()迭代器，实现如果欲插入位置靠近前端使用，就让前端的数据往前挪，否则往后挪。\ndeque中+=的实现：1.先计算+=后是否超过缓冲区，如果没有则直接+=，否则需要判断需要跨几个缓冲区，然后再去确定前进几个缓冲区。 Vector的内存扩充：\nstd::vector 在需要更多空间时，通常会将容量增加到当前大小的两倍（这是最常见的增长策略，但不是唯一的，具体实现可能有所不同）。\n当发生扩充时，std::vector 会分配一个新的更大的内存块，然后将所有元素从旧内存块复制到新内存块，最后释放旧内存块。\nDeque的内存扩充：\nstd::deque（双端队列）的内存管理机制与 std::vector 不同。std::deque 是一个使用多个固定大小的内存块来存储元素的容器，这些内存块被称为“chunks”或“maps”。\n当 std::deque 需要更多空间时，它可能会在已有的内存块之后添加新的内存块，或者在前面添加，这取决于哪个方向上的空间更紧张。 std::deque 不会像 std::vector 那样将所有元素复制到一个新的连续内存块中，而是在多个内存块之间分配元素。\nstack和queue stack和queue默认使用deque的功能来分别实现先进后出和先进先出的功能，除此之外还可以使用list，stack还可以使用vector，但是deque就不能用vector，以我的理解，是因为vector不提供后端操作。\nRb-tree 在C++中，set和map的底层实现都是基于红黑树（RB-tree）。红黑树是一种自平衡的二叉搜索树，能够保证在最坏情况下，插入、删除和查找操作的时间复杂度均为O(log n)。\ntemplate \u003c int key, int value, identity\u003cint\u003e, less\u003cint\u003e, alloc \u003e class rb_tree;\rset 和 map 的区别：\nset：set中的元素是唯一的键值，即Key和Value是同一个。插入时使用insert_unique()方法，确保键值不重复。\nmap：map中的元素是键值对（Key-Value），键值用于索引，值表示与索引相关联的数据。插入时使用insert_equal()方法，允许键值重复。\n红黑树的结构：\n红黑树的结构包括节点、根节点、最左节点和最右节点等。根节点通过header.parent保存，最左节点通过header.left保存，最右节点通过header.right保存。\n插入操作 set：插入操作调用insert_unique()，确保键值唯一。 map：插入操作调用insert_equal()，允许键值重复。 迭代器 set：迭代器是RB-tree的const_iterator，不允许修改元素值。 map：迭代器也是RB-tree的const_iterator，但允许修改元素的值（因为值部分不是键）。 set和multiset set与map的底层实现基本可以参考下面的源码图，\n需要说明的一点是，在不允许更改键值上，二者的设计还是有区别，主要体现在set使用const_iterator,这样迭代器指向的键值就无法更改，而map在设计上在传进来的Key设置为const，确保键值不会被更改。\nhashtable-哈希表 在C++中，hash_set、hash_map、hash_multiset和hash_multimap等数据结构的底层实现确实采用了哈希表的思想。具体来说，这些数据结构的设计核心是通过哈希函数将键（key）映射到数组的索引位置，从而实现高效的插入、删除和查找操作。\n数据存储的设计思想 每个键值通过一个哈希函数计算出一个哈希值。这个哈希值通常是一个整数，用于确定键值在数组中的存储位置。例如，对于一个整数键值12，哈希函数可能会直接返回12，这样12就会被存储在数组的第12个位置。\n哈希表的核心是一个数组（通常是一个vector），数组的每个元素（即每个位置）可以存储一个指针。这个指针指向一个单向链表的头节点。如果多个键值通过哈希函数计算出相同的哈希值，它们会被存储在同一个位置的链表中。参考下图： 当多个键值映射到同一个哈希值时，这些键值会被存储在一个链表中。链表的每个节点包含一个键值和指向下一个节点的指针。这种设计允许在发生哈希冲突时，通过遍历链表来查找或插入特定的键值。 为了保持高效的性能，哈希表通常会有一个动态扩容机制。当哈希表中的元素数量超过一定阈值时，哈希表会自动重新分配更大的数组，并重新计算所有键值的哈希值，以减少链表的长度，从而提高查找效率。\n在实际应用中，哈希函数可能会导致不同的键值计算出相同的哈希值，这种现象称为哈希冲突。常见的解决策略包括链地址法（即使用链表存储冲突的元素）和开放地址法（即在数组中寻找下一个空闲位置）。\n具体实现过程 当插入一个新键值时，首先通过哈希函数计算出其哈希值，然后根据哈希值找到对应的数组位置。如果该位置已经有元素（即发生冲突），则将新元素插入到该位置的链表中。 查找操作同样通过哈希函数计算出键值的哈希值，然后根据哈希值找到对应的数组位置。如果该位置有元素，则遍历链表，直到找到匹配的键值或链表结束。 删除操作首先通过哈希函数计算出键值的哈希值，然后根据哈希值找到对应的数组位置。如果该位置有元素，则遍历链表，找到并删除匹配的键值。 实现代码 hashtable类的实现提供了六个模板参数。\ntemplate \u003cclass value, class key, class hashFcn,//计算编号 class extractKey,//取出键值 class EqualKey,//判断类型是否相等 class Alloc=alloc \u003e\r如果要自己使用这个哈希表，需要写hashFcn()的重载，对齐进行偏特化等操作,如下图： 如果传入的是字符串，那么字符串的编号计算可以参考下图计算方法： 附件",
    "description": "list vector deque deque的迭代器 deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用push_front()（push_back()）,否则借助insert_aux()迭代器，实现如果欲插入位置靠近前端使用，就让前端的数据往前挪，否则往后挪。",
    "tags": [],
    "title": "8.STL库学习之容器",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "分配器源代码位置：xmemory.h 除了array和vector外，其他容器的适配器必须是一个类， 附件",
    "description": "分配器源代码位置：xmemory.h 除了array和vector外，其他容器的适配器必须是一个类， 附件",
    "tags": [
      "C++"
    ],
    "title": "7.STL库学习之分配器",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "STL程序源代码位置 了解自身编译器STL程序源代码位置。\nOOP 与 GP 面向对象编程（OOP）：\n面向对象编程是一种编程范式，它将数据和处理这些数据的方法封装在对象中。这种方法强调了数据和函数的捆绑，使得代码更加模块化，易于理解和维护。对象可以包含属性（数据）和方法（函数），它们一起工作来模拟现实世界的行为。\n补充说明：OOP 通过类（Class）来定义对象的蓝图，支持继承、封装和多态等特性，从而提高代码的重用性和灵活性。例如list中有自己的sort()函数，专门为list而设计，比::sort()的算法更优。\n泛型编程（GP）：\n泛型编程是一种编程范式，它允许开发者定义操作类型数据结构的函数和类，而不需要在编译时指定具体的数据类型。这种方法强调了数据和处理方法的分离，提供了更高的代码复用性和类型安全性。\n补充说明：GP 通过模板（Templates）或泛型容器（如 std::vector、std::map）来实现，允许开发者写出与数据类型无关的代码，从而在不同的数据类型间共享相同的算法逻辑。例如vector和deque没有为自身设计sort(),在做排序操作时，需要调用::sort()来实现。\n操作符重载 STL源码程序中会包含很多的操作符重载，一般你会看到operate修饰符，后面就紧跟着操作符。注意：::、.、.*和 :?不能进行操作符重载。\n在我看来操作符重载是一个重要的特性，它可以让你实现任何类的运算法则，这些法则有你自己规定，操作空间还是比较宽泛。\n模版-template 最常见的写法如下：\ntemplate \u003ctypename T\u003e class FOO{ ... }\r类模板 最常见的写法如下：\ntemplate \u003cclass T\u003e class FOO{ ... }\r成员模版 泛化、特化和偏特化 以我个人的理解，泛化是为了应对大部分的情况，特化是为了应对特殊的情况，或使用单独的方法处理对某些情况而言更好，偏特化比偏特化更近一步，把处理的手段限定在一定范围内，举个简单的例子，假设为设计计算两种情况的相加做如下定义：\n1.泛化\n泛化编程在C++中通过模板实现。以下是一个泛化编程的示例，其中 AND 类是一个模板类，可以处理任何类型的数据。\ntemplate \u003cclass T,class U\u003e class AND{ ... }\r2.特化\n特化是对模板类或函数的特定实例化。以下是特化的示例，其中 AND 类被特化为处理 string 和 Text 类型：\ntemplate \u003cclass T, class U\u003e class AND { // ... 类的泛型实现 }; template \u003c\u003e class AND\u003cstring, Text\u003e { // ... 类的特化实现 };\r3.偏特化\n偏特化允许对模板类的部分参数进行特化。以下是偏特化的示例，其中 AND 类被偏特化为处理第一个类型为 int 的情况：\ntemplate \u003cclass T, class U\u003e class AND { // ... 类的泛型实现 }; template \u003cclass U\u003e class AND\u003cint, U\u003e { // ... 类的偏特化实现 };\r附件",
    "description": "STL程序源代码位置 了解自身编译器STL程序源代码位置。\nOOP 与 GP 面向对象编程（OOP）：\n面向对象编程是一种编程范式，它将数据和处理这些数据的方法封装在对象中。这种方法强调了数据和函数的捆绑，使得代码更加模块化，易于理解和维护。对象可以包含属性（数据）和方法（函数），它们一起工作来模拟现实世界的行为。",
    "tags": [
      "C++"
    ],
    "title": "6.STL库学习之筑基概要",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/6.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AD%91%E5%9F%BA%E6%A6%82%E8%A6%81/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "一下主要讲STL组件的测试用例，特别是容器的测试 学习资料 CPLusPlus.com CppReference.com gcc.gnu.org 《STL源码剖析》 STL六大组件 容器-Containers，申请内存用于存储数据 分配器-Allocators，配合容器分配内存 算法- Algorithms，处理某一数据的最优办法 迭代器- Iterators，指针的泛型，本质与指针类似 适配器- Adapters， 仿函数-Functors，类似函数。 六者的关系\nbegin()和end() 以迭代器为例，begin()指向迭代器的首地址，而end()指向迭代器尾地址的下一位，可以用前闭后开区间来表示，即**[ )**\n容器的分类 数组容器的使用 array 的使用 示例1\r.h文件\rtestCode\r结果\r#ifndef __AUXFUN__ #define __AUXFUN__ #include \u003ciostream\u003e #include \u003cstring\u003e #define RAMD_MAX 32767 using namespace std; long get_a_target_long() { long target = 0; cout \u003c\u003c \"target (0--\" \u003c\u003c RAMD_MAX \u003c\u003c \"):\"; cin \u003e\u003e target; return target; } //将数值转为string，这样可以测试类似object的情况 string get_a_target_string() { long target = 0; char buf[10]; cout \u003c\u003c \"target (0--\" \u003c\u003c RAMD_MAX \u003c\u003c \"):\"; cin \u003e\u003e target; snprintf(buf, 10, \"%d\", target); return string(buf); } int compareLongs(const void* a, const void* b) { return (*(long*)a - *(long*)b); /* 1.类型转换：因为参数是const void* 类型，你需要将它们转换为具体的数据类型指针（在这个例子中是long* ），以便可以解引用并获取它们的值。 2.解引用：在转换之后，通过在类型转换的结果前使用* 操作符来获取指针指向的实际值。 3.强制转换的结果：* (long*)a实际上是一个long值，它是通过解引用转换后的指针得到的。*/ } int compareString(const void* a, const void* b) { if (*(long*)a \u003e *(long*)b) return 1; else if (*(long*)a \u003c *(long*)b) return -1; else return 0; } #endif // !__ENTRY__ #include \"TestHeardFiles/AuxFun.h\" #include \u003cctime\u003e #include \u003ccstdlib\u003e//qsort()、 bsearch()、 NULL #include \u003carray\u003e const size_t ASIZE = 50000; namespace t01 { void test_array() { cout \u003c\u003c \"\\ntest_array().............. \\n\"; array\u003clong, ASIZE\u003e c;//使用数组容器 clock_t timeStart = clock(); for (long i = 0; i \u003c ASIZE; ++i) { c[i] = rand();//可以产生随机数的函数 } cout \u003c\u003c \"milli_seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"array.size(): \" \u003c\u003c c.size() \u003c\u003c endl;//返回数组大小 cout \u003c\u003c \"array.back(): \" \u003c\u003c c.back() \u003c\u003c endl;//返回数组最后一个数 cout \u003c\u003c \"array.data: \" \u003c\u003c c.data() \u003c\u003c endl;//返回第一个数的地址 long target = get_a_target_long(); timeStart = clock();//clock()返回毫秒数 qsort(c.data(), ASIZE, sizeof(long), compareLongs);//数组排序 long* pItem = (long*)bsearch(\u0026target, (c.data()), ASIZE, sizeof(long), compareLongs);//数组查找 cout \u003c\u003c \"qsort()+bsearch(),milli-seconds:\" \u003c\u003c clock() - timeStart \u003c\u003c endl; if (pItem != NULL) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else cout \u003c\u003c \"Not found!\" \u003c\u003c endl; } } int main() { t01::test_array(); }\rvector 的使用 vector是一种向后自动以2次方增加的内存的容器，一般使用push_back向后添加数据；\nvector也有一定的缺点，假设我只需要5个内存空间，但是vector分配的是8个，剩下的3个后面如果不使用就会浪费。\n示例2\r代码\r结果\r#include \u003cvector\u003e #include \u003cstdexcept\u003e //obort() #include \u003ccstdio\u003e\t//snprintf() #include \u003calgorithm\u003e//sort() namespace t02 { void test_vector(long\u0026 value) { cout \u003c\u003c \"\\ntest_vector()..............\\n\"; vector\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_back(string(buf));//将随机数转为string类型，并使用push_back()将数据存入容器尾部，这是vector的特性 //同时值得注意，当空间不足时，内存会自动增加，怎么加方式是2的平方 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"vector.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"vector.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"vector.back(): \" \u003c\u003c c.back() \u003c\u003c endl; cout \u003c\u003c \"vector.data(): \" \u003c\u003c c.data() \u003c\u003c endl; cout \u003c\u003c \"vector.capacity(): \" \u003c\u003c c.capacity() \u003c\u003c endl;//返回的是向量当前分配的存储空间可以容纳的元素个数 string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //进行排序后使用bsearch查找。 { timeStart = clock(); sort(c.begin(), c.end());//该算法将任何类型进行排序，需要提供相应的比较函数 string* pItem = (string*)bsearch(\u0026target, (c.data()), c.size(), sizeof(string), compareString); cout \u003c\u003c \"sort()+bsearch(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != NULL) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } } }\r从上面的结果来看，排序后使用二分查找反而比循环查找慢，原因在于排序话费了很多时间，因为string类型是一个object，其本身大小比较大，所以面对一个object进行查找时不建议使用排序后二分查找。\n在实际应用中，选择排序加二分查找还是直接线性查找，需要根据具体情况来决定：\n如果容器已经排序，或者数据量不大，直接使用二分查找可能更简单、更快。 如果容器未排序，且数据量很大，那么可能需要考虑是否值得为了一次查找而进行排序，或者是否可以通过其他方式（如使用更高效的数据结构，如哈希表）来提高查找效率。 如果查找操作非常频繁，而插入和删除操作不频繁，那么维护一个已排序的容器可能是合理的，这样每次查找都可以利用二分查找的效率。 总之，选择哪种方法取决于具体的应用场景和性能要求。在某些情况下，可能需要通过实验或性能分析来确定最佳的策略。\n链表容器-list std::list 是 C++ 标准库中的一个容器，它提供了双向链表的实现。\nstd::list 容器的特点：\n双向链表结构：std::list 由一系列节点组成，每个节点包含一个元素和两个指针，分别指向前一个节点和后一个节点。 动态内存分配：std::list 中的每个节点都是独立分配内存的。这意味着当你添加或删除元素时，std::list 会为新元素分配内存，或释放不再使用的元素所占用的内存。 内存空间利用：由于 std::list 的元素是单独分配的，因此不存在像 std::vector 那样的连续内存块，也就不会有额外的内存浪费。每个元素恰好占用它所需的空间，加上一些指针存储开销。 查询操作效率：\n查询效率较低：与 std::vector 或 std::array 这样的随机访问容器相比，std::list 的查询操作通常较慢。这是因为 std::list 没有提供快速的随机访问能力。 顺序访问：在 std::list 中，要访问一个特定位置的元素，你需要从头开始遍历，直到到达那个位置。这意味着访问时间与列表的大小成正比，最坏情况下的时间复杂度为 O(n)。 没有跳跃访问：与数组或 std::vector 不同，std::list 没有提供直接跳到任意位置的能力。在数组中，你可以通过简单的指针算术来访问任意位置的元素，而在 std::list 中，你必须遍历链表。 测试代码：\n示例3\r代码\r结果\r#include \u003clist\u003e namespace t03 { void test_list(long\u0026 value) { cout \u003c\u003c \"\\ntest_list()..............\\n\"; list\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_back(string(buf));//将随机数转为string类型，并使用push_back()将数据存入容器尾部，这是vector的特性 //同时值得注意，当空间不足时，内存会自动增加，怎么加方式是2的平方 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"list.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"list.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"list.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"list.back(): \" \u003c\u003c c.back() \u003c\u003c endl; string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //测试排序花费的时间 { timeStart = clock(); c.sort();//使用list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。 cout \u003c\u003c \"list.sort(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; } } }\rHow much memory space you need: 1000000 test_list().............. milli-seconds: 1073 list.size(): 1000000 list.max_size(): 329406144173384850 list.front(): 41 list.back(): 12679 target (0--32767):12345 ::find(),milli-seconds: 4 found,12345 list.sort(),milli-seconds: 1611\r总结： std::list 的优点在于它的灵活性和高效的插入/删除操作，这些操作可以在 O(1) 时间内完成，因为它们只需要修改几个指针。然而，这种灵活性的代价是牺牲了快速随机访问的能力。因此，如果你的应用场景中需要频繁地在序列中间插入或删除元素，而不太关心随机访问性能，std::list 是一个很好的选择。反之，如果随机访问是一个关键操作，那么可能需要考虑使用其他类型的容器。\n链表容器-forward_list std::forward_list 是 C++ 标准库中的一个容器，它提供了单向链表的实现。\nstd::forward_list 容器的特点：\n单向链表结构：std::forward_list 由一系列节点组成，每个节点包含一个元素和一个指向下一个节点的指针。 内存分配：与 std::list 类似，std::forward_list 的元素也是动态分配内存的。但是，由于它是单向链表，所以只能从链表的前端（头部）开始进行内存分配。 操作限制：由于 std::forward_list 的单向特性，它只提供了 push_front() 和 pop_front() 操作来在链表的前端添加或删除元素。不支持快速的随机访问，也不支持在链表的中间或末尾进行插入和删除操作。 内存使用效率：\n无尾插法：std::forward_list 没有 push_back() 方法，只能使用 push_front() 在链表的头部插入元素。这意味着，如果你需要在链表的末尾添加元素，你将不得不遍历整个链表以到达末尾，这在大型数据集中可能效率较低。 节省空间：与 std::list 相比，std::forward_list 每个节点只需要存储一个指向下一个节点的指针，因此它的内存开销比 std::list 小。 适用场景：\n空间敏感的应用：如果你的应用对内存使用非常敏感，且需要从链表的前端进行频繁的插入和删除操作，std::forward_list 是一个不错的选择。 单向遍历：如果你的应用只需要从链表的前端开始遍历元素，那么 std::forward_list 可以提供良好的性能。 测试代码\n示例3\r代码\r结果\r#include \u003cforward_list\u003e namespace t04 { void test_forward_list(long\u0026 value) { cout \u003c\u003c \"\\nforward_list()..............\\n\"; forward_list\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_front(string(buf));//将随机数转为string类型，并使用push_frond()将数据存入容器头部，forward_list没有push_back() } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"forward_list.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"forward_list.front(): \" \u003c\u003c c.front() \u003c\u003c endl; //cout \u003c\u003c \"forward_list.back(): \" \u003c\u003c c.back() \u003c\u003c endl;\t没有该函数 //cout \u003c\u003c \"forward_list.size(): \" \u003c\u003c c.size() \u003c\u003c endl;\t没有该函数 string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //测试排序花费的时间 { timeStart = clock(); c.sort();//使用forward_list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。 cout \u003c\u003c \"forward_list.sort(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; } } }\rHow much memory space you need: 1000000 forward_list().............. milli-seconds: 965 forward_list.max_size(): 384307168202282325 forward_list.front(): 12679 target (0--32767):12345 ::find(),milli-seconds: 3 found,12345 forward_list.sort(),milli-seconds: 1595\r值得注意的是： std::forward_list 专为高效的前端插入和删除操作设计，std::forward_list 没有 push_back() 是因为它是单向链表， 只能高效地从前面操作。它没有 size() 函数，因为计算链表长度需要遍历整个链表，这与它优化前端操作的设计目标不符。\n总结：\nstd::forward_list 是一个轻量级的容器，它在内存使用上比 std::list 更为高效，但在功能上也更为有限。它适合于那些只需要单向遍历和操作的场景。由于其单向链表的特性，std::forward_list 在进行元素插入和删除时，只能从链表的前端进行，这限制了它的使用场景。在选择 std::forward_list 时，需要根据应用的具体需求来权衡其优势和局限性。\n链表容器-slist slist容器与forward_list容器一样，只是slis容器存在于ext\\slist头文件中。\n测试代码：\n示例3\r代码\r结果\r#include \u003cforward_list\u003e namespace t04 { void test_forward_list(long\u0026 value) { cout \u003c\u003c \"\\nforward_list()..............\\n\"; forward_list\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_front(string(buf));//将随机数转为string类型，并使用push_frond()将数据存入容器头部，forward_list没有push_back() } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"forward_list.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"forward_list.front(): \" \u003c\u003c c.front() \u003c\u003c endl; //cout \u003c\u003c \"forward_list.back(): \" \u003c\u003c c.back() \u003c\u003c endl;\t没有该函数 //cout \u003c\u003c \"forward_list.size(): \" \u003c\u003c c.size() \u003c\u003c endl;\t没有该函数 string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //测试排序花费的时间 { timeStart = clock(); c.sort();//使用forward_list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。 cout \u003c\u003c \"forward_list.sort(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; } } }\rHow much memory space you need: 1000000 forward_list().............. milli-seconds: 965 forward_list.max_size(): 384307168202282325 forward_list.front(): 12679 target (0--32767):12345 ::find(),milli-seconds: 3 found,12345 forward_list.sort(),milli-seconds: 1595\r双向容器-deque std::deque（双端队列）是一种容器，它允许在序列的前端和后端快速插入和删除元素。尽管从概念图上看， std::deque 似乎是一个连续的存储空间，但实际上它并不是连续的。std::deque 的实现通常是由一个或多个固定大小的连续内存块 （通常称为“节点”或“块”）组成的，这些块通过指针连接在一起。\n以下是对您提供内容的整理：\n存储机制：std::deque 由多个指针组成，每个指针指向一个具有一定容量的连续内存块。这些内存块被组织在一起，形成一个能够从两端快速增长的容器。 内存管理：当 std::deque 中的一个内存块满了，需要更多的空间时，它会“自动跳转”到下一个空闲的内存块的开始位置。如果所有现有的内存块都已满，std::deque 会分配一个新的内存块，并更新指针以指向这个新的块。 内存效率：使用固定容量的内存块可以减少内存浪费。例如，如果每个内存块的大小为8个元素，那么即使只存储一个元素，也只会浪费7个元素的空间（因为第一个块始终被使用）。这与 std::vector 相比，后者可能会因为频繁的内存重新分配而导致更多的内存浪费。 动态增长：当 std::deque 需要更多内存时，它会动态地增加新的内存块。这种设计使得 std::deque 能够在不牺牲太多内存的情况下，提供快速的插入和删除操作。 连续性：尽管 std::deque 在内部不是完全连续的，但它提供了随机访问的能力，这意味着你可以像访问 std::vector 或数组一样，通过索引来访问 std::deque 中的任何元素。 总的来说，std::deque 是一个灵活且高效的容器，适用于需要在序列的两端进行频繁插入和删除操作的场景。它的设计既考虑了性能， 也考虑了内存使用效率。\n测试代码：\n示例3\r代码\r结果\r#include \u003cdeque\u003e namespace t05 { void test_deque(long\u0026 value) { cout \u003c\u003c \"\\ntest_deque()..............\\n\"; deque\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push_back(string(buf));//将随机数转为string类型，并使用push_back()将数据存入容器尾部 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"deque.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"deque.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"deque.back(): \" \u003c\u003c c.back() \u003c\u003c endl; cout \u003c\u003c \"deque.size(): \" \u003c\u003c c.size() \u003c\u003c endl; string target = get_a_target_string();//获取输入的数字，并转为string类型返回 //使用算法find查找 { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//返回类型是：使用全局::find()寻找目标，这是循环寻找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; //判断有没有找到 if (pItem != c.end()) { cout \u003c\u003c \"found,\" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"Not fount!\" \u003c\u003c endl; } } //测试排序花费的时间 { timeStart = clock(); sort(c.begin(), c.end());//使用全局的sort,deque没有自己的sort。 cout \u003c\u003c \"deque.sort(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; } } }\rHow much memory space you need: 1000000 test_deque().............. milli-seconds: 1055 deque.max_size(): 461168601842738790 deque.front(): 41 deque.back(): 12679 deque.size(): 1000000 target (0--32767):12345 ::find(),milli-seconds: 4 found,12345 deque.sort(),milli-seconds: 3838\r特殊容器-stack和queue std::stack（栈） 定义：\nstd::stack 是一个遵循后进先出（LIFO，Last In First Out）原则的容器适配器。它只能在序列的一端（栈顶）进行添加（push）和移除（pop）操作。\n主要操作：\npush()：在栈顶添加一个元素。 pop()：移除栈顶元素。 top()：返回栈顶元素的引用，不移除它。 特点：\n只能单端操作，即只能在栈顶进行操作。 没有提供直接的迭代器支持，但提供了 top() 方法来访问栈顶元素。 std::queue（队列） 定义：\nstd::queue 是一个遵循先进先出（FIFO，First In First Out）原则的容器适配器。它只能在序列的一端（队尾）进行添加（push）操作，在另一端（队首）进行移除（pop）操作。\n主要操作：\npush()：在队尾添加一个元素。 pop()：移除队首元素。 front()：返回队首元素的引用，不移除它。 back()：返回队尾元素的引用，不移除它。 特点：\n双端操作，即在队首进行移除操作，在队尾进行添加操作。 提供了迭代器支持，允许遍历队列中的所有元素。 与 std::deque 的不同.\n操作限制：std::stack 和 std::queue 限制了操作的位置，而 std::deque 允许在两端自由操作。 迭代器支持：std::stack 不支持迭代器，std::queue 支持迭代器但只能访问队列中的元素，而 std::deque 提供了随机访问迭代器，可以高效地访问序列中的任何位置。 使用场景：如果你需要一个简单的后进先出或先进先出的数据结构，std::stack 或 std::queue 可能更适合。如果你需要一个能够在两端快速操作且支持随机访问的容器，std::deque 是更好的选择。 测试代码：\n示例4\rstack代码\rqueue代码\r结果\r#include \u003cstack\u003e namespace t06 { void test_stack(long\u0026 value) { cout \u003c\u003c \"\\ntest_stack()..............\\n\"; stack \u003cstring\u003e c;//stack又叫栈，特点是先进后出 char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push(string(buf));//将随机数转为string类型，并使用push()将数据压入容器 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"stack.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"stack.top(): \" \u003c\u003c c.top() \u003c\u003c endl; c.pop(); cout \u003c\u003c \"stack.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"stack.top(): \" \u003c\u003c c.top() \u003c\u003c endl; //与前面的容器不同，stack不可以进行查找操作 } }\r#include \u003cqueue\u003e namespace t07 { void test_queue(long\u0026 value) { cout \u003c\u003c \"\\ntest_queue()..............\\n\"; queue \u003cstring\u003e c;//queue又叫队列，特点是先进先出 char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.push(string(buf));//将随机数转为string类型，并使用push()将数据压入容器 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"queue.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"queue.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"queue.back(): \" \u003c\u003c c.back() \u003c\u003c endl; c.pop(); cout \u003c\u003c \"queue.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"queue.front(): \" \u003c\u003c c.front() \u003c\u003c endl; cout \u003c\u003c \"queue.back(): \" \u003c\u003c c.back() \u003c\u003c endl; //与前面的容器不同，queue也不提供查找操作 } }\rHow much memory space you need: 1000000 test_stack().............. milli-seconds: 1050 stack.size(): 1000000 stack.top(): 12679 stack.size(): 999999 stack.top(): 17172 test_queue().............. milli-seconds: 1027 queue.size(): 1000000 queue.front(): 21384 queue.back(): 1461 queue.size(): 999999 queue.front(): 10793 queue.back(): 1461\r红黑树-multiset容器 multiset容器结构类似二叉树，准确说是红黑树，这种结构的的查找会快很多，但是插入则会耗费一定时间，这些时间都花费在了排序上。\n测试代码：\n示例8\rmultiset代码\rmultimap代码\r结果\r#include \u003cset\u003e namespace t08 { void test_multiset(long\u0026 value) { cout \u003c\u003c \"\\ntest_multiset()..............\\n\"; multiset \u003cstring\u003e c;//multiset结构式红黑树 char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(string(buf));//将随机数转为string类型，并使用insert()将数据存入容器 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"multiset.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"multiset.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; string target = get_a_target_string(); { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//使用全局::fingd()查找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } { timeStart = clock(); auto pItem = c.find(target);//使用multiset自身的fingd()查找 cout \u003c\u003c \"c.find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } } }\r#include \u003cmap\u003e namespace t09 { void test_multimap(long\u0026 value) { cout \u003c\u003c \"\\ntest_multimap()..............\\n\"; multimap \u003clong,string\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(pair\u003clong,string\u003e(i,buf));//此处使用了pair设置键值对 //值得注意，multimap不可以用[]做insert，这一点可以结合map容器理解, //另外key是不会重复的，因为接收的是0-1000000，而值可能会重复，因为值是通过随机数函数rand()产生，范围为0-32767 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"multimap.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"multimap.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout \u003c\u003c \"c.find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, (\" \u003c\u003c (*pItem).first \u003c\u003c\", \" \u003c\u003cpItem-\u003esecond\u003c\u003c\")\" \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } }\rHow much memory space you need: 1000000 test_multiset().............. milli-seconds: 3235 multiset.size(): 1000000 multiset.max_size(): 256204778801521550 target (0--32767):23456 ::find(),milli-seconds: 59 found, 23456 c.find(),milli-seconds: 0 found, 23456 test_multimap().............. milli-seconds: 1843 multimap.size(): 1000000 multimap.max_size(): 230584300921369395 target (0--32767):23456 c.find(),milli-seconds: 1 found, (23456, 31622)\r从测试结果看，因为不会抛弃重复的值，multiset的元素个数与大小相等，且存值会话费很多时间。 相比之下multimap存值时间会话费少一些。\nunordered_multiset和unordered_multimap std::unordered_map 和 std::unordered_set 是 C++ 标准库中的两种容器，它们基于哈希表实现。这两种容器提供平均时间复杂度为 O(1) 的快速访问，插入和删除操作。下面简单解释它们的概念图，包括桶和负载因子的说明。\n概念图简述：\n桶（Buckets）：\n在 std::unordered_map 和 std::unordered_set 中，哈希表被分为多个“桶”。 每个桶存储指向一个链表的指针（在 std::unordered_map 的情况下）或直接存储元素（在 std::unordered_set 的情况下）。 当元素被插入时，它们的哈希值决定了它们将被存储在哪个桶中。\n链表（Chaining）：\n如果多个元素具有相同的哈希值（哈希冲突），它们将被存储在同一个桶中，并通过链表连接起来。 在 std::unordered_map 中，每个桶可能包含一个链表，链表中的每个节点存储一个键值对。 在 std::unordered_set 中，每个桶可能包含一个链表，链表中的每个节点存储一个元素。\n负载因子（Load Factor）：\n负载因子是哈希表中已存储元素数量与桶数量的比率。 负载因子影响哈希表的性能。较高的负载因子可能导致更多的哈希冲突，从而增加链表的长度，降低性能。 当负载因子超过一个预设的最大值时，哈希表可能会进行重新哈希（rehashing），即增加桶的数量并重新分配所有元素到新的桶中。\n概念图说明：\n桶：哈希表被分为多个桶，每个桶可以存储一个链表的头部指针。 指针：在 std::unordered_map 中，每个指针指向一个链表节点，该节点包含一个键值对。在 std::unordered_set 中，每个指针直接指向存储的元素。 元素：链表中的元素，可能是键值对或单个值。 负载因子说明：\n重新哈希（Rehashing）：当负载因子超过 max_load_factor() 时，哈希表会进行重新哈希，增加桶的数量，并将所有元素重新分配到新的桶中。 动态调整：这种动态调整机制使得 std::unordered_map 和 std::unordered_set 能够根据元素数量的变化自动调整大小，以保持操作的性能。 通过这种结构，std::unordered_map 和 std::unordered_set 能够在大多数情况下提供快速的访问和修改操作，但需要注意，极端情况下（如所有元素哈希到同一个桶中）性能可能会退化到 O(n)。\n测试代码：\n示例9\runordere_multiset代码\runordere_multiset结果\runordere_multimap代码\runordere_multimap结果\r#include \u003cunordered_set\u003e namespace t10 { void test_unordered_multiset(long\u0026 value) { cout \u003c\u003c \"\\ntest_unordered_multiset()..............\\n\"; unordered_multiset \u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(string(buf));//将随机数转为string类型，并使用insert()将数据存入容器 } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"unordered_multiset.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl;// 打印 unordered_multiset 能存储的最大元素数量 cout \u003c\u003c \"unordered_multiset.bucket_count(): \" \u003c\u003c c.bucket_count() \u003c\u003c endl;// 打印 unordered_multiset 中桶的数量，即存储指向一定长度链表的指针的个数 cout \u003c\u003c \"unordered_multiset.max_load_factor(): \" \u003c\u003c c.max_load_factor() \u003c\u003c endl;// 打印 unordered_multiset 可以使用的最大负载因子，它影响桶中链表的最大长度 cout \u003c\u003c \"unordered_multiset.max_bucket_count(): \" \u003c\u003c c.max_bucket_count() \u003c\u003c endl;// 打印 unordered_multiset 可以使用的最大桶的数量，这个值通常由桶的增长策略和哈希表的容量决定 for (unsigned i = 0; i \u003c 20; i++) { cout \u003c\u003c \"bucket # \" \u003c\u003c i \u003c\u003c \" has \" \u003c\u003c c.bucket_size(i) \u003c\u003c \" element.\\n\"; } string target = get_a_target_string(); { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target);//使用全局::fingd()查找 cout \u003c\u003c \"::find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } { timeStart = clock(); auto pItem = c.find(target);//使用multiset自身的fingd()查找 cout \u003c\u003c \"c.find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } } }\rHow much memory space you need: 1000000 test_unordered_multiset().............. milli-seconds: 1867 unordered_multiset.max_size(): 329406144173384850 unordered_multiset.bucket_count(): 1048576 unordered_multiset.max_load_factor(): 1 unordered_multiset.max_bucket_count(): 1152921504606846975 bucket # 0 has 0 element. bucket # 1 has 0 element. bucket # 2 has 0 element. bucket # 3 has 0 element. bucket # 4 has 0 element. bucket # 5 has 0 element. bucket # 6 has 0 element. bucket # 7 has 0 element. bucket # 8 has 0 element. bucket # 9 has 0 element. bucket # 10 has 0 element. bucket # 11 has 0 element. bucket # 12 has 0 element. bucket # 13 has 0 element. bucket # 14 has 0 element. bucket # 15 has 0 element. bucket # 16 has 0 element. bucket # 17 has 0 element. bucket # 18 has 0 element. bucket # 19 has 0 element. target (0--32767):12345 ::find(),milli-seconds: 108 found, 12345 c.find(),milli-seconds: 0 found, 12345\r#include \u003cunordered_map\u003e namespace t11 { void test_unordered_multimap(long\u0026 value) { cout \u003c\u003c \"\\ntest_unordered_multimap()..............\\n\"; multimap \u003clong, string\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(pair\u003clong, string\u003e(i, buf)); } catch (exception\u0026 p) { cout \u003c\u003c \"i=\" \u003c\u003c i \u003c\u003c \" \" \u003c\u003c p.what() \u003c\u003c endl; abort();//发生异常使用该函数退出程序 } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"unordered_multimap.size(): \" \u003c\u003c c.size() \u003c\u003c endl; cout \u003c\u003c \"unordered_multimap.max_size(): \" \u003c\u003c c.max_size() \u003c\u003c endl; long target = get_a_target_long(); timeStart = clock(); auto pItem = c.find(target); cout \u003c\u003c \"c.find(),milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, (\" \u003c\u003c (*pItem).first \u003c\u003c \", \" \u003c\u003c pItem-\u003esecond \u003c\u003c \")\" \u003c\u003c endl; } else { cout \u003c\u003c \"not found!\" \u003c\u003c endl; } } }\rHow much memory space you need: 1000000 test_unordered_multimap().............. milli-seconds: 1942 unordered_multimap.size(): 1000000 unordered_multimap.max_size(): 230584300921369395 target (0--32767):12345 c.find(),milli-seconds: 0 found, (12345, 5839)\rset和map容器 测试代码：\n示例10\rset\rmap\r结果\rnamespace t12 { void test_set(long\u0026 value){ cout \u003c\u003c \"\\ntest-set()............................\\n\" \u003c\u003c endl; set\u003cstring\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c.insert(string(buf)); } catch (exception\u0026 p) { cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c p.what() \u003c\u003c endl; abort(); } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"set.max_size() \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"set.size() \" \u003c\u003c c.size() \u003c\u003c endl; string target = get_a_target_string(); { timeStart = clock(); auto pItem = ::find(c.begin(), c.end(), target); cout \u003c\u003c \"::find(), milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else cout \u003c\u003c \"not fount!\" \u003c\u003c endl; } { timeStart = clock(); auto pItem = c.find(target); cout \u003c\u003c \"find(), milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found, \" \u003c\u003c *pItem \u003c\u003c endl; } else cout \u003c\u003c \"not fount!\" \u003c\u003c endl; } } }\rnamespace t13 { void test_map(long\u0026 value) { cout \u003c\u003c \"\\ntest_map()............................\\n\" \u003c\u003c endl; map\u003clong,string\u003e c; char buf[10]; clock_t timeStart = clock(); for (long i = 0; i \u003c value; ++i) { try { snprintf(buf, 10, \"%d\", rand()); c[i] = string(buf);//注意这种使用方式 } catch (exception\u0026 p) { cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c p.what() \u003c\u003c endl; abort(); } } cout \u003c\u003c \"milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; cout \u003c\u003c \"map.max_size() \" \u003c\u003c c.max_size() \u003c\u003c endl; cout \u003c\u003c \"map.size() \" \u003c\u003c c.size() \u003c\u003c endl; long target = get_a_target_long(); { timeStart = clock(); auto pItem = c.find(target); cout \u003c\u003c \"::find(), milli-seconds: \" \u003c\u003c (clock() - timeStart) \u003c\u003c endl; if (pItem != c.end()) { cout \u003c\u003c \"found value, \" \u003c\u003c pItem-\u003esecond \u003c\u003c endl; } else cout \u003c\u003c \"not fount value!\" \u003c\u003c endl; } } }\rHow much memory space you need: 1000000 test-set()............................ milli-seconds: 2133 set.max_size() 256204778801521550 set.size() 32768 target (0--32767):12345 ::find(), milli-seconds: 1 found, 12345 find(), milli-seconds: 0 found, 12345 test_map()............................ milli-seconds: 1937 map.max_size() 230584300921369395 map.size() 1000000 target (0--32767):12345 ::find(), milli-seconds: 0 found value, 5839\r分配器测试程序 附件",
    "description": "一下主要讲STL组件的测试用例，特别是容器的测试 学习资料 CPLusPlus.com CppReference.com gcc.gnu.org 《STL源码剖析》 STL六大组件 容器-Containers，申请内存用于存储数据 分配器-Allocators，配合容器分配内存 算法- Algorithms，处理某一数据的最优办法 迭代器- Iterators，指针的泛型，本质与指针类似 适配器- Adapters， 仿函数-Functors，类似函数。 六者的关系",
    "tags": [
      "C++",
      "STL库"
    ],
    "title": "5.STL库之观其大略",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: STL库",
    "uri": "/tags/stl%E5%BA%93/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说",
    "content": "在宋朝末年的一个春日午后，阳光透过雕花窗棂，洒在了御书房的青石地板上。太傅李大人正站在书架旁，耐心地教导着最受宠爱的柒公主学习《论语》。公主虽然天资聪颖，但今日却显得心不在焉，她的目光不时飘向窗外的花园，那里的蝴蝶正在花间翩翩起舞。\r太傅李大人轻声咳嗽，试图引起公主的注意，但柒公主却只是懒洋洋地翻了一页书，完全没有将心思放在学习上。李大人心中微微叹息，他知道这位公主自小受到皇上的宠爱，性格难免有些任性。他决定采取一些措施，于是他从桌上拿起了一根精致的戒尺。\n“公主殿下，”李大人的声音温和而坚定，“学习之道，贵在专注。今日若不专心，恐怕难以领悟圣人之言。”\n柒公主抬头，眼中闪过一丝不满，但还没等她反驳，戒尺已经轻轻地落在了她的手心。虽然力道不大，但足以让公主感到一丝疼痛。她惊讶地看着太傅，随即眼眶一红，泪水开始在眼眶中打转。\n就在这时，皇上恰好路过御书房，听到了公主的哭声。他急忙推门而入，看到这一幕，眉头紧锁。皇上推开了一旁的内侍，快步走到公主身边，轻声安慰。\n“是谁如此大胆，竟敢对朕的女儿动手？”皇上的声音中带着一丝怒气。\n内侍们吓得纷纷跪地，太傅李大人也急忙跪下，低声说道：“陛下，臣有罪。”\n皇上转头看向太傅，眼中闪过一丝复杂。他知道李大人是位尽职尽责的太傅，但看到女儿受委屈，心中难免有些不忍。他轻轻拍了拍公主的背，然后示意内侍将她送回寝宫。\n待公主离开后，皇上坐在了御书房的椅子上，示意太傅起身。他的声音平静，但带着一丝不容置疑的威严：“李爱卿，你有何解释？”\n太傅李大人站起身，他的额头上已经渗出了细密的汗珠。他知道，自己的举动可能会触怒皇上，但他坚信这是为了公主好。他深吸了一口气，然后缓缓开口：“陛下，臣此举虽有失礼之嫌，但实在是出于对公主学业的关心。”\n皇上微微点头，他知道李大人的忠心，但他也需要考虑到皇室的颜面。他沉思了片刻，然后说道：“李爱卿，朕知道你是出于好意，但公主毕竟是皇室中人，她的身份不容有失。今后，你还是要注意方式方法。”\n太傅李大人急忙应道：“陛下英明，臣铭记在心。”\n皇上挥了挥手，让太傅退下。他独自一人坐在御书房中，目光落在了窗外的花园上。他知道，在这个动荡的时代，皇室的每一个成员都必须更加小心谨慎。他决定过几天再去看望柒公主，亲自教导她一些治国之道。\n内侍们轻手轻脚地收拾着御书房，没有人敢打扰皇上的沉思。阳光渐渐西斜，御书房内弥漫着一种宁静而深沉的气氛。",
    "description": "在宋朝末年的一个春日午后，阳光透过雕花窗棂，洒在了御书房的青石地板上。太傅李大人正站在书架旁，耐心地教导着最受宠爱的柒公主学习《论语》。公主虽然天资聪颖，但今日却显得心不在焉，她的目光不时飘向窗外的花园，那里的蝴蝶正在花间翩翩起舞。\r太傅李大人轻声咳嗽，试图引起公主的注意，但柒公主却只是懒洋洋地翻了一页书，完全没有将心思放在学习上。李大人心中微微叹息，他知道这位公主自小受到皇上的宠爱，性格难免有些任性。他决定采取一些措施，于是他从桌上拿起了一根精致的戒尺。",
    "tags": [],
    "title": "桑叶白鸟卷",
    "uri": "/story/8.%E6%A1%91%E5%8F%B6%E7%99%BD%E9%B8%9F%E5%8D%B7/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "VS 2022的设置 首先你可以先用下面的代码测试使用可以执行：\n#include \u003ciostream\u003e void printTypes() { } template \u003ctypename T, typename... U\u003e void printTypes(const T\u0026 t, const U\u0026... u) { std::cout \u003c\u003c t \u003c\u003c std::endl; printTypes(u...); } int main() { printTypes('a', 1.5, 'b'); }\r如果报错了，如typename…未定义，那么请你按照如下步骤操作， C++语言标准选择预览 - 最新 C++ 工作草案中的功能 (/std:c++latest) 启用实验性C++标准库模块–是 生成ISO C++23标准库模块 – 是 const补充 const 参数 non-const 参数 const 函数 可执行 可执行 non-const 函数 报错 可执行 使用const需要注意两个问题，参数是否需要修改，参数进入函数内后数据是都会修改。解决这两个问题，在需要的地方加上const\n还有一种情况，\ntemplate\u003ctypename T\u003e class foo { public: T fooTo(T str) const { return str; }; T fooTo(T str) {return str;}; }; int main() { foo \u003c char \u003e f; const char x = 'a'; char y = 'c'; std::cout \u003c\u003c f.fooTo(x) \u003c\u003c std::endl; std::cout \u003c\u003c f.fooTo(y) \u003c\u003c std::endl; }\r运行结果如下: 在这个例子中，带const的参数只会执行带const的函数，而不带const的参数会只会执行不带const的函数，这就是带const和不带const函数出现时的情况。 但是这个结果我并不是很满意，应为我试着在不带const函数内部修改传入的参数，代码执行时将不会以我上面说的结论出现。或许还需要在研究研究……\n附件",
    "description": "VS 2022的设置 首先你可以先用下面的代码测试使用可以执行：\n#include \u003ciostream\u003e void printTypes() { } template \u003ctypename T, typename... U\u003e void printTypes(const T\u0026 t, const U\u0026... u) { std::cout \u003c\u003c t \u003c\u003c std::endl; printTypes(u...); } int main() { printTypes('a', 1.5, 'b'); }\r如果报错了，如typename…未定义，那么请你按照如下步骤操作，",
    "tags": [
      "C++"
    ],
    "title": "4.C++2.0特性的使用",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "书籍推荐 《C++ Premier》 《C++ Programming Language》 《Effective Modern C++》 《Efficient C++》 《The C++ standard library》 《STL C++》 《STL源码剖析》 《算法+数据结构=程序》 “网站CPLusPlus” “网站CppReference” “网站gcc.gnu” 学习路线 慕课C++学习 练习网站 conversion function-转换函数 接下来以一个分数的代码例子说明转换函数。\n情况1：让值转为其他类型\nclass Fraction { private: int m_num, m_den; public: Fraction(int num, int den = 1) : m_num(num),m_den(den){} opertaor double() const { return (double)(m_num/m_den); } }; //使用示例： Fraction f(2,5); double d = 4+f;\r在上述的示例中，d = 4+f;程序会先判断有没有写opertaor +，如果没有会试着将f通过opertaor double()转为double类型。\n情况2：non-explicit-one-argument-ctor，不带explicit的一个参数的构造函数，将其他类型转为预所写类的类型\nclass Fraction { private: int m_num, m_den; public: Fraction(int num, int den = 1) : m_num(num),m_den(den){} opertaor double() const { return (double)(m_num/m_den); } }; //使用示例： Fraction f1(2,5); Fraction f2 = 4+f1;\r同样在这个地方会先将4转为Fraction，然后在进行相加，转换函数使用的是构造函数，构造函数默认第二个参数是1，也就一个参数时也可用，但这个意思并不是说f1(2)你不写第二个参数。\n虽然向上面的情况可行，但是当你把两个情况结合在一起时，就会报错，例如你如下写：\nclass Fraction { private: int m_num, m_den; public: Fraction(int num, int den = 1) : m_num(num),m_den(den){} opertaor double() const { return (double)(m_num/m_den); } Fraction operator + (const Fraction\u0026 f){ return Fraction(……); } };\r情况3：explicit-one-argument-ctor，带explicit的一个参数的构造函数 这个时候再使用刚才的例子，程序就会报错，因为此时是两种情况的结合，意味着两种情况都可以实现，编译器此时就不知道该使用哪个方法，为了解决这个问题，你可以使用关键字explicit来约束构造函数，让其他类型如法转为所写类，这个时候编译器会报错说无法将double类型转为Fraction。如下：\nclass Fraction { private: int m_num, m_den; public: explicit Fraction(int num, int den = 1) : m_num(num),m_den(den){} opertaor double() const { return (double)(m_num/m_den); } Fraction operator + (const Fraction\u0026 f){ return Fraction(……); } }; //示例 Fraction f1(2,5); Fraction f2 = 4+f1;\r编写的类大两个大方向 智能指针 伪函数 这样的类会像函数一样接收参数，返回某一类型的值通常会看到类中重载operate() (……){……}函数。\n特化 偏特化–对应泛化 个数上的偏 以我的理解就是假设原先设计的模版为\ntemplate \u003ctypename a, typename b……\u003e class A {……}\r现在我使用偏特化，写为\ntemplate \u003ctypename b\u003e class A\u003cbool, typename b……\u003e {……}\r也就是第一个参数已经确定是bool类型了。（大概先这么理解吧:smile: :smile: :smile:）\n范围上的偏特化 一般我们的类模版你可以任意指定类型，但是现在我想写一个用指针指向的类模板，那么他就被限制在一定的范围内了\ntemplate \u003ctypename a\u003e class A {……} //范围偏特化 template \u003ctypename a\u003e class A\u003ctypename* a\u003e {……}\r模板模板类 假设我要创建一个容器，并指定这个容器内容的类型，这个时候可以使用模版模版类，详细看下图： 附件\rFraction.hpp (355 B)",
    "description": "书籍推荐 《C++ Premier》 《C++ Programming Language》 《Effective Modern C++》 《Efficient C++》 《The C++ standard library》 《STL C++》 《STL源码剖析》 《算法+数据结构=程序》 “网站CPLusPlus” “网站CppReference” “网站gcc.gnu” 学习路线",
    "tags": [
      "C++"
    ],
    "title": "3.导读",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "类与类的三种关系 Composition-复合 以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构函数运行次序是，构造函数有内到外依次运行，析构函数则相反。可以使用下图表示这种关系\ndelegation-委托 当一个类欲用一个指针指向另一个类，以达到想使用时就指向这个类的这种关系就叫delegation，假设我要实现一个计算，此时指针指向这个函数，让函数去做这个计算。这有些类似于复合，但是这里重点在于指针的使用。在写一些功能的时候也建议使用这种关系的特性，因为这样就将两者隔开，起到一定的保护作用。参考下图： Inheritance-继承 在C++有三种继承方式，其中public是常用的一种，继承表示从一个类中集成某些属性成为 另外一种 类。\nInheritance关系的两个类它们的构造函数与析构函数执行次序与之前描述复合时一样。如下图是这种关系的表示方法： 构造函数（constructor）：由内到外，代码表示为SunFunction::SunFunction(…):base(){…}; 析构函数（destructor）：由外到内，代码表示为SunFunction::SunFunction(…){……~base();}; 值得注意的是，如果一个类将来可能是父类，那么需要在析构函数前加virtual关键字，否则会报错undefine behavior。\n设计模式 **参考书籍：**Design PatternsExplained Simply\n附件",
    "description": "类与类的三种关系 Composition-复合 以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构函数运行次序是，构造函数有内到外依次运行，析构函数则相反。可以使用下图表示这种关系",
    "tags": [
      "C++"
    ],
    "title": "2.组合与继承",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "如何写一个标准的.h文件 以下内容来自B站。\n接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：\nclass complex { private: /* data */ double re,im; friend complex\u0026 __doapl (complex*,const complex\u0026); public: complex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {}; complex\u0026 operator += (complex operator\u0026); double read () const {return re;} //这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型 double imag () const {return im;} };\r构造函数的特性 这一点需要关注下面的代码：\ncomplex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {};\r关于const修饰符 如上面说到的，函数返回最好是加const，这样可以应付下面情况的发生。\nconst的使用\r加const\r不加const\rdouble read () const {return re;} double imag () const {return im;}\r此时做如下两种使用都是正确的\ncomplex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl;\rconst complex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl;\rdouble read () {return re;} double imag () {return im;}\r此时做如下两种使用只有第一种可以被执行，第二种会报错。\ncomplex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl;\rconst complex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl;\r函数传递和返回值的两种方式 pass by values:传值。在传输的事单字节或者字节数较少的情况下使用，比如传一个字符。\npass by reference:传引用。在C++中引用的底层逻辑就是传指针，也就是类似穿了地址，也就是只传输4个字节， 在这种情况下你可以使用const修饰符，迫使函数不能修改值，如果希望函数对值进行处理则可以不加\nvoid re(const classname\u0026 cl){};//加了const void re(classname cl){};//没有加const 对于返回值，我们可以返回值，也可以返回引用，但什么情况下返回的是引用呢？\n在设计类中的函数时，可以先考虑返回类型适不适合引用,如果返回的是已经存在的地址，那么可以选择返回类型为引用，否则不使用。\ninline complex\u0026 __ap(complex * this ,const complex \u0026 c){ this-\u003ere += c.re; this-\u003eim += c.im; return *this; }\r向上面的函数就是使用了引用返回。\n操作符重载-1：成员函数 操作符重载-2：非成员函数 假设现在要计算复数的加减，如下：\ncomplex com1(1,0); complex com2(2,9); complex com3; com3 = com1 + com2; com3 = com1 + 2; com3 = 0 + com2; ……\r对于这段代码在库文件中，要对加法做非成员函数重载，以应付 不同的情况。\n接下来在考虑一个问题，就是如果我们只是做cout\u003c\u003ccom1;那么对于«函数返回值可以是void类,但是如果我们做的是cout\u003c\u003ccom1\u003c\u003ccom2\u003c\u003cendl; 这样的操作返回类型为void类型，那么当运行cout\u003c\u003ccom1后就无法运行\u003c\u003ccom2\u003c\u003cendl的代码.\n很显然要让代码继续运行，我们还需要返回iostream类型，而且使用return by reference返回方法，也就是返回引用。如下图： 小结 通过以上的简单讲解，我们可以总结一下，再写一个类的时候，我们需要注意以下几点：\n确定类的数据并写在private中; 对于构造函数要善于使用初始化数据方法； 对于函数要想一想，返回类型是否可以改变，要不要写const； 对于函数类型和返回值，要传值还是传引用，要返回值还是返回引用。 是否返回引用最最好的判断标准就是，值在经过函数运算后存储在函数外，或说是一个以存在的存储地址，否则不返回引用\n接下来通过学习string.h库，进一步了解指针的使用 一般有指针的类需要写三个特殊函数拷贝构造、拷贝析构、拷贝赋值，\n有时候还需要用到new 和 delete。\nstack（栈）和heap（堆） 如下代码：\nclass String{……}; …… { String str(\"hello\"); String str1 = new String(); …… }\r上面的{}内的代码就是存储在stack中，而经过new的变量存在heap中；\nstack object 的生命周期 在{}内的代码执行结束后，自动调用析构函数将变量清理掉，如下代码，\nclass String{……}; …… { String str(\"hello\"); …… }\rstatic local object 的生命周期 添加关键字static的变量成为静态变量，在作用于如下面代码的{}结束后不会被析构函数清理掉， 变量会存储直到程序结束。\nclass String{……}; …… { static String str(\"hello\"); …… }\rglobal objects 生命周期 全局变量在程序接收后才会被清理掉。\nclass String{……}; String str(\"hello\"); …… { …… }\r调用new和delete的过程 在使用new的地方需要使用delete清理内存，防止内存泄露。\n调用new过程：\n调用delete的过程：\n代码 分配内存大小左图是调试模式下的内存分配，右图是非调试模式下分配的内存\nnew与delete的搭配，在删除数组时需要加上[]否则编译器不知道你要删的是数组：\nnew和delete的补充 对new和delete的重载，用于设计内存管理，如内存池等操作。\n重载::new,::delete 重载的函数中，new操作会接收一个大小，该大小由编译器传入，而delete传入的是一个指针，如下图； 如果不想使用类中的new和delete，可以在二者之前加上:,如::new,::delete，这样在调用函数时就不会调用类设计中的new和delete重载，而是全局的。\n类中重载的new和delete //类 class F{ ... public: void* operate new(size_t);//1 void operate delete(void*,size_t);//2,size_t可不写 ... } //代码段1的内部操作 try{ void* mem = operate new(size_t); p = static_cast\u003cF*\u003e(mem);//类型转换 p-\u003eF::F();//构造函数 } //代码段2的内部操作 p-\u003e~F(); operate delete(p); // main函数调用示例 { F* p = new F(); ... delete p; }\r类中重载的new[]和delete[] 代码整体流程与上一个情况类似，区别在于new[]是申请数组内存，在销毁的时候如果不使用delete[]释放内存，delete只会执行一次，导致内存没有完全释放，详细代码如下：\n//类 class F{ ... public: void* operate new(size_t);//1 void operate delete(void*,size_t);//2,size_t可不写 ... } //代码段1的内部操作 try{ void* mem = operate new(size_t*N + 4);//指针占4个字节 p = static_cast\u003cF*\u003e(mem);//类型转换 p-\u003eF::F();//构造函数 } //代码段2的内部操作 p-\u003e~F();//析构函数 operate delete(p); // main函数调用示例 { F* p = new F[N]; ... delete[] p; }\rnew,delete使用示例 using namespace std; class Foo { private: int _id;//4个字节 long _data;//4个字节 string _str;//40个字节 public: Foo() :_id(0) { cout \u003c\u003c \"default ctor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; Foo(int i) :_id(i) { cout \u003c\u003c \"ctor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; ~Foo() { cout \u003c\u003c \"dtor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; static void* operator new(size_t size); static void operator delete(void* p, size_t size); static void* operator new[](size_t size); static void operator delete[](void* p, size_t size); }; void* Foo::operator new(size_t size) { Foo* p = (Foo*)malloc(size); cout \u003c\u003c \"new size = \" \u003c\u003c size \u003c\u003c endl; return p; } void Foo::operator delete(void* p, size_t size) { cout \u003c\u003c \"delete size = \" \u003c\u003c size \u003c\u003c endl; free(p); } void* Foo::operator new[](size_t size) { Foo* p = (Foo*)malloc(size); cout \u003c\u003c \"new[] size = \" \u003c\u003c size \u003c\u003c endl; return p; } void Foo::operator delete[](void* p, size_t size) { cout \u003c\u003c \"delete[] size = \" \u003c\u003c size \u003c\u003c endl; free(p); }\r运行结果如下：\nnew size = 48 default ctor.this = 00000191EC67A460id: 0 dtor.this = 00000191EC67A460id: 0 delete size = 48 _____________________________________________ new[] size = 104 default ctor.this = 00000191EC673438id: 0 default ctor.this = 00000191EC673468id: 0 dtor.this = 00000191EC673468id: 0 dtor.this = 00000191EC673438id: 0 delete[] size = 104\r为什么new[]操作会多出8个字节呢？ 我看课程视频，老师说new[]分配的内存块会在最前面存储计数量，占用4个字节，表示数组大小，但是我在电脑上运行会多出8个字节，查阅资料可能与系统、对齐方式、编译器等有关。\n对new的分配额外内存 假设分配内存的同时需要额外分配一定的内存，可以参考下面的代码： 小结 对于包含有指针的类，在必要时写上拷贝构造、拷贝赋值、析构函数，如下代码\n​\rclass String\rDestructor\rConstructor\rCopy Constructor\rCopy Assignment Operator\rclass String { private: char* m_data; public: String(const char* cstr = 0); //构造函数 String(const String\u0026 str); //拷贝构造函数 String\u0026 operator= (const String\u0026 str); //拷贝赋值函数 ~String(); //析构函数 char* get_c_str() const {return m_data;} };\rString::~String() { delete[] m_data; }\rinline String::String(const char* cstr = 0) { if (cstr) { m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); }else{ m_data = new char[1]; strcpy(m_data,'\\0'); } }\rinline String::String(const String\u0026 cstr){ m_data = new char[strlen(cstr.m_data) + 1]; strcpy(m_data, cstr); }\rinline String\u0026 String::operator=(const String\u0026 str) { if(this == \u0026str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str); return *this; }\r补充内容static static在private中的使用例子 class template function template member template 成员模板 类模板中，还有类模板，通常是对构造函数的操作，如下图： 如下图代码 用意就是当一个指针指向父类时，初始化让他指向子类，那么此时需要实现上图类中的代码。\nnamespace（命令空间） 使用示例：\nusing namespace std; { …… }\r使用方法：\n​\rusing direction\rusing declaration\r#include \u003ciostream\u003e using namespace std; int main() { cout\u003c\u003c……; cin\u003c\u003c……; return 0; }\r#include \u003ciostream\u003e using std::cout; int main() { cout\u003c\u003c……; std::cin\u003c\u003c……; return 0; }\r或者\n#include \u003ciostream\u003e int main() { std::cout\u003c\u003c……; std::cin\u003c\u003c……; return 0; }\r附件\rcomplex.h (546 B)\rFoo.hpp (1 KB)\rString.h (1 KB)",
    "description": "如何写一个标准的.h文件 以下内容来自B站。\n接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：\nclass complex { private: /* data */ double re,im; friend complex\u0026 __doapl (complex*,const complex\u0026); public: complex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {}; complex\u0026 operator += (complex operator\u0026); double read () const {return re;} //这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型 double imag () const {return im;} };\r构造函数的特性 这一点需要关注下面的代码：",
    "tags": [
      "C++"
    ],
    "title": "1.代码编写规范",
    "uri": "/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r17.C加加编程",
    "content": "如何写一个标准的.h文件 以下内容来自B站。\n接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：\nclass complex { private: /* data */ double re,im; friend complex\u0026 __doapl (complex*,const complex\u0026); public: complex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {}; complex\u0026 operator += (complex operator\u0026); double read () const {return re;} //这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型 double imag () const {return im;} };\r构造函数的特性 这一点需要关注下面的代码：\ncomplex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {};\r关于const修饰符 如上面说到的，函数返回最好是加const，这样可以应付下面情况的发生。\nconst的使用\r加const\r不加const\rdouble read () const {return re;} double imag () const {return im;}\r此时做如下两种使用都是正确的\ncomplex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl;\rconst complex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl;\rdouble read () {return re;} double imag () {return im;}\r此时做如下两种使用只有第一种可以被执行，第二种会报错。\ncomplex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl;\rconst complex com1(1,2); cout\u003c\u003ccom1.real()\u003c\u003cendl;\r函数传递和返回值的两种方式 pass by values:传值。在传输的事单字节或者字节数较少的情况下使用，比如传一个字符。\npass by reference:传引用。在C++中引用的底层逻辑就是传指针，也就是类似穿了地址，也就是只传输4个字节， 在这种情况下你可以使用const修饰符，迫使函数不能修改值，如果希望函数对值进行处理则可以不加\nvoid re(const classname\u0026 cl){};//加了const void re(classname cl){};//没有加const 对于返回值，我们可以返回值，也可以返回引用，但什么情况下返回的是引用呢？\n在设计类中的函数时，可以先考虑返回类型适不适合引用,如果返回的是已经存在的地址，那么可以选择返回类型为引用，否则不使用。\ninline complex\u0026 __ap(complex * this ,const complex \u0026 c){ this-\u003ere += c.re; this-\u003eim += c.im; return *this; }\r向上面的函数就是使用了引用返回。\n操作符重载-1：成员函数 操作符重载-2：非成员函数 假设现在要计算复数的加减，如下：\ncomplex com1(1,0); complex com2(2,9); complex com3; com3 = com1 + com2; com3 = com1 + 2; com3 = 0 + com2; ……\r对于这段代码在库文件中，要对加法做非成员函数重载，以应付 不同的情况。\n接下来在考虑一个问题，就是如果我们只是做cout\u003c\u003ccom1;那么对于«函数返回值可以是void类,但是如果我们做的是cout\u003c\u003ccom1\u003c\u003ccom2\u003c\u003cendl; 这样的操作返回类型为void类型，那么当运行cout\u003c\u003ccom1后就无法运行\u003c\u003ccom2\u003c\u003cendl的代码.\n很显然要让代码继续运行，我们还需要返回iostream类型，而且使用return by reference返回方法，也就是返回引用。如下图： 小结 通过以上的简单讲解，我们可以总结一下，再写一个类的时候，我们需要注意以下几点：\n确定类的数据并写在private中; 对于构造函数要善于使用初始化数据方法； 对于函数要想一想，返回类型是否可以改变，要不要写const； 对于函数类型和返回值，要传值还是传引用，要返回值还是返回引用。 是否返回引用最最好的判断标准就是，值在经过函数运算后存储在函数外，或说是一个以存在的存储地址，否则不返回引用\n接下来通过学习string.h库，进一步了解指针的使用 一般有指针的类需要写三个特殊函数拷贝构造、拷贝析构、拷贝赋值，\n有时候还需要用到new 和 delete。\nstack（栈）和heap（堆） 如下代码：\nclass String{……}; …… { String str(\"hello\"); String str1 = new String(); …… }\r上面的{}内的代码就是存储在stack中，而经过new的变量存在heap中；\nstack object 的生命周期 在{}内的代码执行结束后，自动调用析构函数将变量清理掉，如下代码，\nclass String{……}; …… { String str(\"hello\"); …… }\rstatic local object 的生命周期 添加关键字static的变量成为静态变量，在作用于如下面代码的{}结束后不会被析构函数清理掉， 变量会存储直到程序结束。\nclass String{……}; …… { static String str(\"hello\"); …… }\rglobal objects 生命周期 全局变量在程序接收后才会被清理掉。\nclass String{……}; String str(\"hello\"); …… { …… }\r调用new和delete的过程 在使用new的地方需要使用delete清理内存，防止内存泄露。\n调用new过程：\n调用delete的过程：\n代码 分配内存大小左图是调试模式下的内存分配，右图是非调试模式下分配的内存\nnew与delete的搭配，在删除数组时需要加上[]否则编译器不知道你要删的是数组：\nnew和delete的补充 对new和delete的重载，用于设计内存管理，如内存池等操作。\n重载::new,::delete 重载的函数中，new操作会接收一个大小，该大小由编译器传入，而delete传入的是一个指针，如下图； 如果不想使用类中的new和delete，可以在二者之前加上:,如::new,::delete，这样在调用函数时就不会调用类设计中的new和delete重载，而是全局的。\n类中重载的new和delete //类 class F{ ... public: void* operate new(size_t);//1 void operate delete(void*,size_t);//2,size_t可不写 ... } //代码段1的内部操作 try{ void* mem = operate new(size_t); p = static_cast\u003cF*\u003e(mem);//类型转换 p-\u003eF::F();//构造函数 } //代码段2的内部操作 p-\u003e~F(); operate delete(p); // main函数调用示例 { F* p = new F(); ... delete p; }\r类中重载的new[]和delete[] 代码整体流程与上一个情况类似，区别在于new[]是申请数组内存，在销毁的时候如果不使用delete[]释放内存，delete只会执行一次，导致内存没有完全释放，详细代码如下：\n//类 class F{ ... public: void* operate new(size_t);//1 void operate delete(void*,size_t);//2,size_t可不写 ... } //代码段1的内部操作 try{ void* mem = operate new(size_t*N + 4);//指针占4个字节 p = static_cast\u003cF*\u003e(mem);//类型转换 p-\u003eF::F();//构造函数 } //代码段2的内部操作 p-\u003e~F();//析构函数 operate delete(p); // main函数调用示例 { F* p = new F[N]; ... delete[] p; }\rnew,delete使用示例 using namespace std; class Foo { private: int _id;//4个字节 long _data;//4个字节 string _str;//40个字节 public: Foo() :_id(0) { cout \u003c\u003c \"default ctor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; Foo(int i) :_id(i) { cout \u003c\u003c \"ctor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; ~Foo() { cout \u003c\u003c \"dtor.this = \" \u003c\u003c this \u003c\u003c \"id: \" \u003c\u003c _id \u003c\u003c endl; }; static void* operator new(size_t size); static void operator delete(void* p, size_t size); static void* operator new[](size_t size); static void operator delete[](void* p, size_t size); }; void* Foo::operator new(size_t size) { Foo* p = (Foo*)malloc(size); cout \u003c\u003c \"new size = \" \u003c\u003c size \u003c\u003c endl; return p; } void Foo::operator delete(void* p, size_t size) { cout \u003c\u003c \"delete size = \" \u003c\u003c size \u003c\u003c endl; free(p); } void* Foo::operator new[](size_t size) { Foo* p = (Foo*)malloc(size); cout \u003c\u003c \"new[] size = \" \u003c\u003c size \u003c\u003c endl; return p; } void Foo::operator delete[](void* p, size_t size) { cout \u003c\u003c \"delete[] size = \" \u003c\u003c size \u003c\u003c endl; free(p); }\r运行结果如下：\nnew size = 48 default ctor.this = 00000191EC67A460id: 0 dtor.this = 00000191EC67A460id: 0 delete size = 48 _____________________________________________ new[] size = 104 default ctor.this = 00000191EC673438id: 0 default ctor.this = 00000191EC673468id: 0 dtor.this = 00000191EC673468id: 0 dtor.this = 00000191EC673438id: 0 delete[] size = 104\r为什么new[]操作会多出8个字节呢？ 我看课程视频，老师说new[]分配的内存块会在最前面存储计数量，占用4个字节，表示数组大小，但是我在电脑上运行会多出8个字节，查阅资料可能与系统、对齐方式、编译器等有关。\n对new的分配额外内存 假设分配内存的同时需要额外分配一定的内存，可以参考下面的代码： 小结 对于包含有指针的类，在必要时写上拷贝构造、拷贝赋值、析构函数，如下代码\n​\rclass String\rDestructor\rConstructor\rCopy Constructor\rCopy Assignment Operator\rclass String { private: char* m_data; public: String(const char* cstr = 0); //构造函数 String(const String\u0026 str); //拷贝构造函数 String\u0026 operator= (const String\u0026 str); //拷贝赋值函数 ~String(); //析构函数 char* get_c_str() const {return m_data;} };\rString::~String() { delete[] m_data; }\rinline String::String(const char* cstr = 0) { if (cstr) { m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); }else{ m_data = new char[1]; strcpy(m_data,'\\0'); } }\rinline String::String(const String\u0026 cstr){ m_data = new char[strlen(cstr.m_data) + 1]; strcpy(m_data, cstr); }\rinline String\u0026 String::operator=(const String\u0026 str) { if(this == \u0026str) return *this; delete[] m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str); return *this; }\r补充内容static static在private中的使用例子 class template function template member template 成员模板 类模板中，还有类模板，通常是对构造函数的操作，如下图： 如下图代码 用意就是当一个指针指向父类时，初始化让他指向子类，那么此时需要实现上图类中的代码。\nnamespace（命令空间） 使用示例：\nusing namespace std; { …… }\r使用方法：\n​\rusing direction\rusing declaration\r#include \u003ciostream\u003e using namespace std; int main() { cout\u003c\u003c……; cin\u003c\u003c……; return 0; }\r#include \u003ciostream\u003e using std::cout; int main() { cout\u003c\u003c……; std::cin\u003c\u003c……; return 0; }\r或者\n#include \u003ciostream\u003e int main() { std::cout\u003c\u003c……; std::cin\u003c\u003c……; return 0; }\r附件\rcomplex.h (546 B)\rFoo.hpp (1 KB)\rString.h (1 KB)",
    "description": "如何写一个标准的.h文件 以下内容来自B站。\n接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：\nclass complex { private: /* data */ double re,im; friend complex\u0026 __doapl (complex*,const complex\u0026); public: complex (double r,double i) :re(r),im(i) //这是一个构造函数，这种写法意思是初始化变量 {}; complex\u0026 operator += (complex operator\u0026); double read () const {return re;} //这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型 double imag () const {return im;} };\r构造函数的特性 这一点需要关注下面的代码：",
    "tags": [
      "C++"
    ],
    "title": "1.代码编写规范",
    "uri": "/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: B3-毕业设计",
    "uri": "/categories/b3-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: OneNet",
    "uri": "/tags/onenet/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r项目",
    "content": "目录\n运行环境 【ESP32学习】联网模块 ESP8266-01S上传数据到OneNet 收藏的一些资料 最终的操作结果 ESP32\u0026\u0026ESP8266-12E连接ONeNet参考资料 ONeNet云平台报错： {“protocol”:“MQTT”,“offline_time”:“2024-07-15 16:01:49.977”,“offline_reason”:“CloseDueToProtoError”}怎么解决？ APP连接ONeNet json数据解析步骤 STM32+电脑(模拟ESP32)+ESP8266通信 设备热点配网技术——WIFIManager 报错：error: ‘wifi_country_t’ does not name a type const wifi_country_t WM_COUNTRY_US{“US”,1,11,WIFI_COUNTRY_POLICY_AUTO}; 通信过程中遇到的问题 这一部分所用到的资料下载地址 【实验】SPIFFS文件系统的使用 【实验】TCP/UDP通信实验 【STM32F4学习】摄像头 参考资料 STM32F4工程代码 【服务器】NGINX 在Linux中搭建NGINX服务器 TCP/IP协议 [知识储备] NGINX架构 NGINX中master的工作原理 nginx处理HTTP请求的过程 安装NGINX 【服务器】Tomcat 【服务器】ZLMedaikit流媒体服务器 【第三方库】FFmpeg媒体流转码工具 【深度学习】飞桨paddlepaddle实战 X-CUDE—AI在线课程 相关论文参考 【机器学习】HMM模型（隐马尔科夫列） 相关论文参考 导入库 【音视频学习】 H.264编码 安卓音视频实战编程 YUV RTMP协议所在所在的网络层结构 【第三方库】LIBRTMP 【工具】类似安卓虚拟机：Total Control 采集音频数据工具 视频采集工具—MediaProjection 【安卓APP制作】 安卓的两种登录方式 安卓中集成第三方库进行登录 安卓显示ONENet提供的可视化链接 硬件系统 运行环境 【ESP32学习】联网模块 ESP8266-01S上传数据到OneNet 参考视频\n1.进入OneNet创建产品和设备（具体步骤待补充）\n2.复制产品和设备的详细信息（备份）\n目的是为了方便使用AT指令以及代码编写。\n设备名称(clientlD) : test 产品ID (username) : F1AVyfXw7l password: version=2018-10-31\u0026res=products%2FF1AVyfXw71%2Fdevices% 2Ftest\u0026et=2810313321\u0026method=md5\u0026sign=EfJtPPxHwMX6iWWf3YksbA%3D%3D.urI:mqtts.heclouds.com 端口号:1883 订阅: $sys/F1AVyfXw7I/test/thing/property/post/reply发布: $sys/F1AVyfXw7l/test/thing/property/post 设备密钥: cjFZSWRwUGNrazdRR2d6eTJ4Tm9YNXN5bTNuMGpMTIE=access key: vclTl19loOn7mcfdtT39l1eRfVffM6FfH8U/U3HhUQc= res:products/F1AVyfXw7l/devices/test et:时间戳\r收藏的一些资料 OneNet云平台 2.时间戳 OneNet文档中心 最终的操作结果 ESP32\u0026\u0026ESP8266-12E连接ONeNet参考资料 云平台调试错误码 设备之间数据交换实战项目 wifi.h库 SCND文章 代码部分唯一不同的是引用的库函数不同，\nESP8266使用的是\n#include \u003cESP8266WiFi.h\u003e\rESP32使用的是\n#include \u003cWiFi.h\u003e\r在使用时需要注意引用的库函数，如果库函数不匹配，可能会导致编译失败，这部分的代码以放在附件中。\nESP-12EConnectONenet是ESP8266-12E连接ONeNet的代码； ESP32ConnectONenet 是ESP8266-12E连接ONeNet的代码。 **注意：**我提供的代码是以onejson格式上传的，而不是数据流的格式。在云平台创建产品时需要注意这点，当然代码里博主写的就是以数据流格式上传，如果你用原来博主写的，那么创建产品时就选数据流。\n上面的代码只能实现数据上传，并不能实现命令控制，下面就介绍如何实现命令控制。 主要修改的地方是callback函数，当拿到topic的时候要解析拿到一段ID，具体可以看官方的资料,里面有提到命令下发的操作。 ONeNet云平台报错： {“protocol”:“MQTT”,“offline_time”:“2024-07-15 16:01:49.977”,“offline_reason”:“CloseDueToProtoError”}怎么解决？ 这个错误是协议格式不对，也就是用的topic不正确，通过下面的案例对这个作说明。\n当我们在云平台下发命令的时候，在callback函数里使用Serial.println(topic);会打印订阅的topic，格式为:\n$sys/584938/onenet_mqtt_dev1/cmd/request/c5a7e27e-05bb-41eb-972b-abce424ade8e\rcallback函数如下：\n/******************************************************************************** 函数：callback 功能：接收ONeNet传回的信息 返回值：无 参数： topic是消息的主题， payload是消息的有效载荷（数据部分）， length是payload的长度 *********************************************************************************/ void callback(char *topic, byte *payload, unsigned int length) { Serial.println(\"message rev:\"); Serial.println(topic); // 打印订阅的topic const char* lastSlash = strrchr(topic, '/'); if (lastSlash != NULL) { const char* cmdId = lastSlash + 1; // 命令ID位于最后一个'/'之后 msgid = String(cmdId); //将命令ID复制给msgid，msgid定义为全局变量 } Serial.println(msgid); // 打印拿到的ID if (strstr(topic, ONENET_GET_CAM_REQUEST)) //ONENET_GET_CAM_REQUEST=\"$sys/{产品ID}/{设备名}/cmd/request/\" { DynamicJsonDocument doc(100); DeserializationError error = deserializeJson(doc, payload); if (error) { Serial.println(\"parse json failed\"); return; } JsonObject setAlinkMsgObj = doc.as\u003cJsonObject\u003e(); serializeJsonPretty(setAlinkMsgObj, Serial); String cam = setAlinkMsgObj[\"cam\"].as\u003cString\u003e(); Serial.println(\"@\"+cam); //取出下发的命令并在前面加@ char RESPONSE_TOPIC[100]; sprintf(RESPONSE_TOPIC, \"$sys/{产品ID}/{设备名}/cmd/response/%s\",msgid.c_str()); client.publish(RESPONSE_TOPIC, \"OK\"); // 向平台响应OK }else { Serial.println(\"GET_CAM faile!\"); } }\r这份代码是根据一位博主的代码改的（博主文章链接），取出后面的ID用如下代码即可\nconst char* lastSlash = strrchr(topic, '/'); if (lastSlash != NULL) { const char* cmdId = lastSlash + 1; // 命令ID位于最后一个'/'之后 msgid = String(cmdId); //将命令ID复制给msgid，msgid定义为全局变量 } Serial.println(msgid); // 打印拿到的ID 而这个时候我们需要响应这个命令用的是\n$sys/584938/onenet_mqtt_dev1/cmd/response/c5a7e27e-05bb-41eb-972b-abce424ade8e\r一个是request，一个是response，所以在拿到下发命令的topic后要取出后面跟着的ID，然后再重新拼接在$sys/584938/onenet_mqtt_dev1/cmd/response/后面，然后用这个拼接的topic发送响应数据给云平台。\n这个时候就能在云平台那看到类似如下信息：\n一般格式错误返回的错误码是15，原因就是格式有问题。使用如下的格式上传响应都可能有问题：\n1.$sys/584938/onenet_mqtt_dev1/cmd/response/\n2.$sys/584938/onenet_mqtt_dev1/cmd/response/+\n3.$sys/584938/onenet_mqtt_dev1/cmd/response/+/+\n以上内容仅供参考，如果你有更好的方法，请在评论区告诉我。\nAPP连接ONeNet 1.内含demo 2.新版视频地址 3.json格式化网站 4.Android Okhttp3的使用（很全面，包含Post提交字符串、键值对、表单、上传文件、无参请求和Get有参无参请求，还有自动添加token） 从json中取出数据,结合第一点看 5.云平台调试错误码 在B站上学习OKHTTP3，我把主要的核心代码放在附件里，分别是get和post的同步和异步请求，返回的结果和视频地址2里讲的一样。\n视频地址1, 视频地址2 在编写HTTPS网络请求（post）时需要上传一些数据，这些数据有一定的上传格式，下面的网址汇总了上传格式content参数\nHTTP的content格式汇总网址 2024.8.19\njson数据解析步骤 方法一：\n方法二：\n使用第三方库Gson,在使用前需要创建一个Jsonbear，就是接收Jsons数据的格式。\n总结：\n在Android Studio中，如果你想要生成代码，例如getter和setter方法，可以使用快捷键Alt + Insert（Windows/Linux系统）或Command + N（Mac系统） 。这个快捷操作会引导你通过一个菜单来选择想要生成的代码类型，比如构造函数、toString方法、以及各种重写方法等。\n此外，如果你需要查看某个方法的参数信息，可以使用快捷键Ctrl + P（Windows/Linux系统）或Command + P（Mac系统），这将展示出当前方法的参数列表及其类型。\nSTM32+电脑(模拟ESP32)+ESP8266通信 STM32————电脑：串口1（PA 9 PA10）,手机连接指定热点，连接成功后等待一段时间把摄像头的网址发给单片机，单片机通过串口2发给ESP8266.ESP8266再传到OneNet上。\n注意：在用ESP8266最小系统通信的时，需要给板子单独供电，否则通信可能失败，原因我想可能是因为电压不够。\n设备热点配网技术——WIFIManager 这个配网技术是让开发板设置热点，然后让手机连接，连接好后配置要让开发板连接的WIFI和密码，这个技术叫设备热点技术。相比于以往的一键配网技术，我个人觉得这个设备热点配网技术成功率要要一些。\n缺点是这个技术不能用AT指令来实现，所以目前AT指令在不配合其他设备的情况下，通常都使用一键配网技术。\nESP32和ESP8266使用设备热点配网技术的区别\n区别一：使用的WiFi库不同，ESP32使用WiFi.h，而ESP8266使用ESP8266WiFi.h 区别二：使用的WiFiManager.h版本不同，ESP32使用2.0.17(目前这个版本是最新的)，而ESP8266使用0.16或0.15 在使用ESP32时，请使用目前最新版的wifimanage库，而使用ESP8266的话请使用0.15或0.16版本的WIFIManager，如果ESP8266使用最新版的可能会报错。报什么错呢？ 报错：error: ‘wifi_country_t’ does not name a type const wifi_country_t WM_COUNTRY_US{“US”,1,11,WIFI_COUNTRY_POLICY_AUTO}; 完整报错如下：\nd:\\Program Files (x86)\\arduino\\libraries\\WiFiManager/wm_consts_en.h:162:7: error: 'wifi_country_t' does not name a type const wifi_country_t WM_COUNTRY_US{\"US\",1,11,WIFI_COUNTRY_POLICY_AUTO}; ^ d:\\Program Files (x86)\\arduino\\libraries\\WiFiManager/wm_consts_en.h:163:7: error: 'wifi_country_t' does not name a type const wifi_country_t WM_COUNTRY_CN{\"CN\",1,13,WIFI_COUNTRY_POLICY_AUTO}; ^ d:\\Program Files (x86)\\arduino\\libraries\\WiFiManager/wm_consts_en.h:164:7: error: 'wifi_country_t' does not name a type const wifi_country_t WM_COUNTRY_JP{\"JP\",1,14,WIFI_COUNTRY_POLICY_AUTO}; ^\r这个错误我目前没有解决，如果你解决了还请评论区或邮件（3256149770@qq.con）告诉我。\n通信过程中遇到的问题 keil5中一点击下载就闪退或点击debug中的setting就闪退。参照文章\nKeil5编程之warning: #223-D: function “xxx“ declared implicitly.参考链接\n这一部分所用到的资料下载地址 正点原子AKT-ESP-Fwifi模块 2024.8.12(更新).\n【实验】SPIFFS文件系统的使用 参考地址\n【实验】TCP/UDP通信实验 参考地址\n【STM32F4学习】摄像头 参考资料 基于STM32F407的摄像头（不带FIFO的OV7670）图像采集及LCD显示实验-笔记整理 STM32F4驱动OV7670总结 基于stm32f407vgt6驱动ov7670的TFT实时视频显示 STM32F4工程代码 使用三个ADC通道要注意按顺序去初始化，否则可能会出现问题，运营我还不知道.\n【服务器】NGINX 在Linux中搭建NGINX服务器 TCP/IP协议 [知识储备] 在线自动生成nginx配置文件的网站\n可以自由选择所需的应用，生成nginx配置作为参考。 根据你的业务需求，自动生成复杂的nginx配置文件，提供你作为参考，非常好用 NGINX架构 NGINX中master的工作原理 nginx处理HTTP请求的过程 安装NGINX 安装路径：https://blog.csdn.net/u011715638/article/details/138670319\nserver { listen 80; listen [::]:80; server_name example.com www.example.com; root /var/www/html; index index.html index.htm; location / { try_files $uri $uri/ =404; } }\r上面是配置文件的内容，下面说明一下配置时的一些注意事项：\n把配置文件的example.com www.example.com换成172.0.0.1，这样方便在本地测试； 在Ubuntu中可以下载ifconfig来查看Ubuntu的IP地址（ip addr也可以） 每次修改配置文件记sudo systemctl reload nginx 【服务器】Tomcat 1.安装Tomcat要使用哪个版本的java？\n使用jdk8或更高版本，详细参考官方文档\n2.如何在Ubuntu安装Tomcat？\n安装jdk8或更高版本 安装 【服务器】ZLMedaikit流媒体服务器 需要掌握的知识点： 【第三方库】FFmpeg媒体流转码工具 Ubuntu上安装ffmpeg的方法 下载ffmpeg源代码地址 【深度学习】飞桨paddlepaddle实战 2024.8.18\n1.从入门到实际运用，请参考B站up主视频：点击链接\n2.学完上面的视频后学习paddlepaddle的语音识别课程：\n3.接着参考STM32cudeXM.AI的相关知识，把模型转换成onnx格式然后在但【单片机上运行：\n3.1先用一个项目练练手：https://shequ.stmicroelectronics.cn/thread-632736-1-1.html\n官网 入门手册文档 官网视频 B站视频 意外收获，这是一个学习论坛：https://www.waveshare.net/study/portal.php?mod=list\u0026catid=38\n2024.8.25\n参考文献：\n禹鑫鹏,贺庆,王世昕,.基于STM32CubeMX AI和NanoEdge AI的眼动信号分类效果对比研究【J】.传感器世界,2024,(04):6-10. 2024.8.26\nX-CUDE—AI在线课程 参考地址\n当模型验证结束后，需要修改以下内容： 相关论文参考 【github项目网址】婴儿哭声分类识别 【机器学习】HMM模型（隐马尔科夫列） 隐马尔科夫列模型定义： 相关论文参考 -【1.基于声学的婴儿哭声识别细分市场模型】(Baby Cry Recognition Based on Acoustic) -【2.使用隐马尔可夫模型自动分割婴儿哭闹信号】(Automatic segmentation of infant cry signals using hidden Markov models)\n导入库 【音视频学习】 H.264编码 所谓视频编码就是指通过特定的压缩技术，将某个视频格式文件转换成另一种视频格式文件的方式。\n视频流传输中最重要的编解码标准有国际电联(TU-T，国际电信联盟)的H.261、H.263、H.264等，运动静止图像专家组（由ISO国际标准化组织与IEC国际电子委员会于1988年联合成立)的MPEG系列标准MPEG1、MPEG2、MPEG4 AVC等。\n其中ITU-TH.264/MPEG-4 AVC是ITU-T与ISO/IEC连手合作制订的新标准。ITU-T方面称之为H.264。但ISOIEC的则将这个新标准归纳于MPEG系列,称为MPEG-4 AVC。\n而H.265则被视为是ITU-TH.264/MPEG-4AVC标准的继任者，又称为高效率视频编码(High Efficiency VideoCoding，简称HEVC)\n格式： 安卓音视频实战编程 构建预览布局-使用SurfaceView或者TextureView\n打开相机- Camera.open\n设置参数- Camera.Parameters\n设置预览数据回调- PreviewCallback\n设置预览画布并启动- setPreviewTexture/startPreview\n释放相机- stopPreview/release\nYUV YUV主要应用于优化彩色视频信号的传输，与RGB相比，YUV只需要占用极少的频宽(RGB需要三个独立的视频信号同时传输)。YUV中Y代表明亮度，也称灰阶值;U与V表示的则是色度（色调和饱和度)也可以记作:YCbCr。如果只有Y数据,那么表示的图像就是黑白的。\n使用YUV的原因：\n使用YUV格式才能极大地去除冗余信息，人眼对亮点信息更敏感，对色度敏感度不高。也就是说,可以压缩UV数据,而人眼难以发现。所以压缩算法的第一步，往往先把RGB数据转换成YUV数据。对Y少压缩一点，对UV多压缩一点，以平衡图像效果和压缩率。这也是为什么编码选择使用YUV而不是RGB。\n推算公式： YUV是一组数据的压缩格式，其下还有因为排列不同而衍生的不同格式名称\nNV21转I420 MediaCode组件： RTMP协议所在所在的网络层结构 【第三方库】LIBRTMP 【工具】类似安卓虚拟机：Total Control 采集音频数据工具 视频采集工具—MediaProjection 安卓P18\n2024.8.27\n方法一：\n安卓使用VLC库实内网播放ESPCam摄像头数据\n方法二：\nMediacode编解码\n【安卓APP制作】 1.安卓登录开发\n2024.8.21\n安卓的两种登录方式 登录可以进去就强登录，或进去后在某个页面触发登录。\n对于第一个只需要在第一个页面做登录处理即可，而第二种需要Hook AMS + APT框架实现，具体看这篇博文：文章连接\n安卓中集成第三方库进行登录 可以使用目前比较流行的第三方库实现：\nJustAuth开源组件：JustAuth是一个整合了国内外数十家知名平台的OAuth登录的开源组件，它提供了丰富的OAuth平台支持，自定义State、自定义OAuth、自定义Http接口和自定义Scope等功能，极大地简化了开发者在第三方登录功能上的工作量。\n2024.8.23\n2.数据显示\n安卓显示ONENet提供的可视化链接 参考链接\n2024.8.29\n硬件系统 一、设备选型\n1.空气质量模块设备选型：\n（1）MQ135测量空气质量和氨气PPM的计算\n附件\rESP-12ConnectOnenet.c (7 KB)\rESP32ConnectOnenet .c (7 KB)\rhttps.java (2 KB)",
    "description": "目录\n运行环境 【ESP32学习】联网模块 ESP8266-01S上传数据到OneNet 收藏的一些资料 最终的操作结果 ESP32\u0026\u0026ESP8266-12E连接ONeNet参考资料 ONeNet云平台报错： {“protocol”:“MQTT”,“offline_time”:“2024-07-15 16:01:49.977”,“offline_reason”:“CloseDueToProtoError”}怎么解决？ APP连接ONeNet json数据解析步骤 STM32+电脑(模拟ESP32)+ESP8266通信 设备热点配网技术——WIFIManager 报错：error: ‘wifi_country_t’ does not name a type const wifi_country_t WM_COUNTRY_US{“US”,1,11,WIFI_COUNTRY_POLICY_AUTO}; 通信过程中遇到的问题 这一部分所用到的资料下载地址 【实验】SPIFFS文件系统的使用 【实验】TCP/UDP通信实验 【STM32F4学习】摄像头 参考资料 STM32F4工程代码 【服务器】NGINX 在Linux中搭建NGINX服务器 TCP/IP协议 [知识储备] NGINX架构 NGINX中master的工作原理 nginx处理HTTP请求的过程 安装NGINX 【服务器】Tomcat 【服务器】ZLMedaikit流媒体服务器 【第三方库】FFmpeg媒体流转码工具 【深度学习】飞桨paddlepaddle实战 X-CUDE—AI在线课程 相关论文参考 【机器学习】HMM模型（隐马尔科夫列） 相关论文参考 导入库 【音视频学习】 H.264编码 安卓音视频实战编程 YUV RTMP协议所在所在的网络层结构 【第三方库】LIBRTMP 【工具】类似安卓虚拟机：Total Control 采集音频数据工具 视频采集工具—MediaProjection 【安卓APP制作】 安卓的两种登录方式 安卓中集成第三方库进行登录 安卓显示ONENet提供的可视化链接 硬件系统 运行环境 【ESP32学习】联网模块 ESP8266-01S上传数据到OneNet 参考视频",
    "tags": [
      "OneNet"
    ],
    "title": "毕业设计",
    "uri": "/projects/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "设置自动保存 打开程序点击系统设置，如下图：\n按照下图步骤设置自动保存，每10分钟保存一次（你也可以设置成其他的，但不建议设置太小或太大比如1分钟或者30分钟）\n设置单一’'表示负信号 按照下图设置\n设置显示对话框 我设置前\n当把上面的打钩后\n[外链图片转存中…(img-ZngLHveL-1719559556141)]\n按住shift+h可以显示和关闭\n[外链图片转存中…(img-bxjUhYCS-1719559556142)]\n[外链图片转存中…(img-qKvH9IRn-1719559556142)] [外链图片转存中…(img-HAD9BmgV-1719559556142)]",
    "description": "设置自动保存 打开程序点击系统设置，如下图：\n按照下图步骤设置自动保存，每10分钟保存一次（你也可以设置成其他的，但不建议设置太小或太大比如1分钟或者30分钟）",
    "tags": [
      "AD设置"
    ],
    "title": "7.初次安装AD需要做哪些设置？",
    "uri": "/log/7.%E5%88%9D%E6%AC%A1%E5%AE%89%E8%A3%85ad%E9%9C%80%E8%A6%81%E5%81%9A%E5%93%AA%E4%BA%9B%E8%AE%BE%E7%BD%AE/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: AD设置",
    "uri": "/tags/ad%E8%AE%BE%E7%BD%AE/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: Cortex-A9微处理器",
    "uri": "/tags/cortex-a9%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: Linux操作系统",
    "uri": "/tags/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 核心课程",
    "uri": "/categories/%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 嵌入式",
    "uri": "/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "基于Cortex-A9微处理器的硬件平台 RISC和CISC RISC是精简指令集计算机，CISC是复杂指令集计算机\nRISC（精简指令集计算机，Reduced Instruction Set Computer）和CISC（复杂指令集计算机，Complex Instruction Set Computer）是两种不同的计算机架构设计理念，它们在指令集的复杂性、指令执行方式、硬件实现等方面有所区别。以下是RISC和CISC的主要特点及其区别：\nRISC（精简指令集计算机） 指令集简单：RISC架构拥有较少的指令，通常每个指令执行一个简单的操作。 指令执行快速：由于指令简单，大多数RISC指令可以在单个时钟周期内完成。 寄存器丰富：RISC架构通常具有更多的寄存器，以减少对内存的访问次数。 流水线执行：RISC处理器设计易于实现流水线技术，提高指令吞吐率。 编译器优化：RISC架构依赖编译器将复杂操作转换为一系列简单的指令。 CISC（复杂指令集计算机） 指令集复杂：CISC架构拥有大量的指令，包括一些执行复杂操作的指令。 指令执行较慢：CISC指令可能需要多个时钟周期来完成。 寄存器较少：CISC架构通常具有较少的寄存器，更多依赖内存访问。 微指令执行：CISC处理器可能使用微指令（microcode）来实现复杂指令。 硬件复杂性：CISC处理器的硬件设计相对复杂，以支持广泛的指令集。 区别\n指令集大小：RISC的指令集较小，CISC的指令集较大。 指令复杂性：RISC指令简单，CISC指令复杂。 执行速度：RISC指令通常执行更快，CISC指令执行可能较慢。 硬件设计：RISC处理器设计相对简单，CISC处理器设计复杂。 内存访问：RISC架构倾向于减少内存访问，CISC架构可能更频繁地访问内存。 依赖编译器：RISC架构更依赖编译器优化，CISC架构则在硬件层面提供复杂操作。 ARM处理器支持的基本数据类型 数据类型：字、半字、字节。\n说明：\n一个字节占8位，半个字节占16位，一个字占32位； 在存储数据时，字要按照4个字节来存储，所以每一次存时地址都加4，地址末位是00，例如0x13FFFFF8,0x13FFFFFC， 在存储数据时，半字要按照2个字节来存，所以每一次存时地址都加2，地址末位是0，例如0x13FFFFF4,0x13FFFFF6，； ARM处理器的工作状态 主要有两种状态，主要区别就是执行的指令集位数不同；\nThumb状态，微处理器执行16位的半字对齐的Thumb指令集，Thumb指令集是从ARM微处理的第四个版本开始增加（v4T）； ARM状态，微处理器执行32位的字对齐的ARM指令集。 ARM存储格式 大端格式：高字节存储在低地址，低字节存储在低地址；\n小端格式:高字节存在高地址，低字节存储在低地址； 说明：\n对高字节和低字节可以这样理解，假设有一个32位的地址为0x13FFFFF1，它的高字节是31，也可以理解成最高那一位的下标，31这一位存了0，低字节是0存了1。把这个理解带入上面的大端格式，小端格式。\nARM处理器寄存器 共有40个32位的寄存器，其中33个通用寄存器，7个状态寄存器； 通用寄存器 未分组寄存器（R0-R7）； 分组寄存器（R8-R14）； ARM处理器的程序状态寄存器包括：CPSR（当前程序状态寄存器）和SPSR（程序状态备份寄存器） 中断 ARM工作模式 用户模式（usr）:应用程序执行状态。\n快速中断模式（fiq）：用于高速数据传输或通道处理。\n外部中断模式（irq）：用于通用的外部中断。\n特权模式（svc）：操作系统使用的保护模式。\n数据访问中止模式（abt）：当数据或指令预取终止时进入该模式，可以用于虚拟存储及存储保护。\n未定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。\n系统模式（sys）：运行具有特权的操作系统任务。\n监控模式（mon）：可在安全模式与非安全模式之间转换。\n执行程序什么模式？\n读指令并执行，读取未定义指令什么模式？\n遇到特权任务什么模式？\n遇到中断什么模式?\n指令执行结束什么模式？\n3级、5级流水线 3级流水线指令可以分解成取指令、编译、执行； 5级流水线指令可以分解成取指令、编译、执行、缓冲、写回。 程序状态寄存器 CPSR中的[31:27]为条件标志位，具体含义如下：\nN：符号标志位。当用两个补码表示的带符号数进行运算时，N=1表示运算的结果为负数；N=0表示运算的结果为正数或零。 Z：结果是否为0的标志。Z=1，表示运算结果为0；Z=0，表示运算结果为非0。 C：进位或借位标志位。加法运算结果产生了借位时C=1，减法运算产生了借位时C=1，否则为0；包含移位操作的非加/减运算指令，C为移出值的最后一位；其他运算指令，C的值通常不变。 V：溢出标志位。对于加减法运算指令，V=1表示符号位溢出，其它指令的影响V位。 CPSR中的[7:0]为控制位，具体含义如下：\nI：IRQ中断使能位； F：FIQ中断使能位； T：处理器运行状态控制位； M[4:0]：运行模式位。 其它标志位。\nARM指令集条件域 EQ：相等，（CPSR）Z=1； GT：大于，Z=0\u0026\u0026N=Z; TF：小于等于，Z=1||N=Z； 寻址指令 数据处理指令 RSB 逆向减法，例如： RSB Rd Rn op2 ;op2-Rn赋值给Rd\rMUL 32位乘法，\nCMP 比较，例如\nCMP Rn op2 ;Rn-op2\rMOV指令:它的传送指令只能是把一个寄存器的值(要能用立即数表示)赋给另一个寄存器，或者将一个常量赋给寄存器，将后边的量赋给前边的量\nADD指令:ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。\nSUB指令:SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中\nSUB r0, r1, r2 ; r0 = r1 - r2 SUB r0, r1, #256 SUB r0, r2, r3, LSL#1 ; r0 = r2 - (r3 \u003c\u003c 1)\rLDR指令:LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中. 用法1： LDR r0, =0x20000000 用法2： LDR r0, =0x30000000\nSTR指令:STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。即：将前边的量赋值给后边的量。 STR r0，[r1] ; 将r0中的字数据写入以r1为地址的存储器中 STR r0，[r1], ＃8 ; 将r0中的字数据写入以r1为地址的存储器中，并将新地址r1＋8写入r1。 STR r0，[r1, ＃8] ; 将r0中的字数据写入以r1＋8为地址的存储器中。\r跳转指令 案例1 CMP R0， #0 MOVEQ R1， #0 MOVGT R1， #1 解：CMP R0， #0 ; 将R0的值减去0，并根据结果设置CPSR的标志位 MOVEQ R1， #0 ; 若R0等于0，Z=1，则将立即数0装入到R1 MOVGT R1， #1 ; 若R0大于0，Z=0，N=V，则将立即数1装入到R1\r程序实现的功能是判断R0的值与0的关系，将结果装入R1，若R0=0则R1=0，若R0\u003e0则R1=1.用C语言描述如下。 设R0对应变量a，R1对应变量b，\nif(a==0) b=0; else if(a\u003e0) b=1; 案例2 对程序各条指令进行注释，最后分析整个程序的功能。\nAREA\tExample1,CODE,READONLY\t; 声明代码段Example1 ENTRY\t; 标识程序入口 CODE32\t; 声明32位ARM指令 START ; 标号/标签 MOV R0, #0\t; 设置参数，R0=0 MOV R1, #10 ; 设置参数，R1=10 LOOP ; 标号/标签 BL ADD_SUB\t; 调用子程序ADD_SUB B\tLOOP\t; 跳转到LOOP ADD_SUB\t; 标号/标签 ADDS R0, R0, R1\t; R0 = R0 + R1，并根据结果设置CPSR的标志位 MOV\tPC, LR\t; 子程序返回，PC=LR END\t; 声明文件结束\r整个程序的功能：程序实现了一个死循环，每次循环R0都增加10。\nLInux编程基础 GCC编译的4个过程的主要功能 预编译：主要功能是读取源文件，并对头文件预编译语句和一些特殊符号进行分析和处理； 编译：主要包括检查代码语法和将预编译后的文件转换成汇编语言； 汇编：主要的功能是将汇编语言的代码编程目标文件；（机器代码，0和1） 连接：主要功能是连接代码，生成可执行文件。 简述Make工具和Makefile的基本结构 Make又叫工程管理工具，即管理较多的工程文件。\n主要的功能:\n通过Makefile文件来描述源程序之间相互依赖的关系，并自动完成维护编译工作； 能够根据文件的时间戳发现更新的文件，可以减少编译工作； 基本结构：\ntarget ： dependency \u003ctab 键\u003e command\rtarget:目标； dependency：依赖关系 command：命令\nMakefile变量 用户自定义变量 预定义变量 自动变量 后两个是系统的变量，是Makefile文件常用的变量，其中有部分变量用户可以修改。\n预定义变量 需要记住两个比较重要且常用的预定义变量，即\nCC：C编译器名称，默认cc CFLAGS：C编译器的选项，无默认值 自动变量（又叫系统变量） $@ :规则的目标所对应的文件； $\u003c：规则中的第一个依赖文件； $^:规则中所有依赖的列表，以空格为间隔符。 文件操作编程 C语言库中的fopen、fclose、fwrite、fread等函数。\n其实是由操作系统的API函数封装而来，如\nfopen内部其实调用的是open函数， fwrite内部调用的是write函数。 用户也可以直接利用Linux系统的API函数来完成文件操作编程\n在Linux操作系统下，用C语言实现文件操作可以采用哪两种方法？ 在LInux操作系统中，实现文件操作有两种方法，第一种是调用C语言标准库，第二种是通过Linux系统调用实现。前者独立于操作系统，在任何操作系统下使用C语言标准库函数操作文件，而后者以来于操作系统。\n时间编程 time函数 返回1970.1.1 0时到现在所经历的时间，操作失败返回((time_t)-1)\ngmtime函数 将日历转化为格林威治标准时间，结果存在结构体tm中。 在课堂上老师叫我们使用的并非上面这个函数，而是用localtime(const time_t *timep)这个函数,这个函数可以将日历转为本地时间，具体用法请看综合案例\ngettimeofday函数 获取从今日凌晨到现在的时差并存储在tv中，tz存放当地时区差；\n综合案例 （4）编写一个程序，将系统时间以“year-month-day hour:minute:second”格式保存在time.txt文件中。\n#include\u003cstdio.h\u003e #include\u003cstring.h\u003e #include\u003cfcntl.h\u003e #include\u003ctime.h\u003e #define MAX 40 int main() { int fd,n,ret; char writebuf[MAX]; struct tm *t; time_t lt; lt=time(NULL); t=localtime(\u0026lt); //将日历时间转化为本地时间 sprintf(writebuf,\"%d-%d-%d %d:%d:%d\\n\",t-\u003etm_year+1900,t-\u003etm_mon+1,t-\u003etm_mday,t-\u003etm_hour,t-\u003etm_min,t-\u003etm_sec); //按指定格式保存时间 /*打开文件，如果文件不存在，则会创建文件*/ fd = open(\"time.txt\", O_RDWR | O_CREAT); /*向文件写入字符串*/ ret = write(fd, writebuf, strlen(writebuf)); if (ret \u003c 0){ perror(\"Write Error!\"); return 1; } else { printf(\"write %d characters!\\n\", ret); } /*关闭时，会自动保存文件*/ close(fd); }\r多线程编程 基本用法 使用到pthread_createh头文件，以及libpthread.so和libpthread.a库文件；\npthread_create函数：创建线程 pthread_exit函数：退出线程 pthread_join函数：阻塞线程 互斥锁线程 解决多个线程在一起执行的时候共享数据、资源的问题。在POSIX中有两种线程同步机制，分别为互斥锁和信号量\npthread_mutex_init:初始化互斥锁 pthread_mutex_lock：互斥锁上锁 pthread_mutex_unlock：互斥锁释放 嵌入式开发交叉编译与系统移植 嵌入式软件调试方法 实时在线仿真 模拟调试 软件调试 片上调试 引导程序移植 操作系统运行前的一个程序，也就是启动程序。\nBoolLoader工作模式 启动加载模式 下载模式 BoolLoader启动过程 第一阶段 主要依赖CPU的体系结构硬件初始化的代码，通常使用汇编语言编写。 这个阶段的功能主要有： 基本硬件设备初始化； 为第二阶段准备ARM空间； 复制BootLoader的第二阶段代码到RAM； 设置栈堆； 跳转到第二阶段的入口点； 第二阶段 通常使用C语言完成，以便实现更复杂的功能，使程序具有更好的可读性和可移植性。 这一阶段的主要任务是： 初始化这一阶段要使用的硬件设备; 检测系统内存映射； 将内核文件和根目录系统映像文件从Flash读到RAM； 为内核设置启动参数， 调用内核。 常用的启动文件有很多，这里介绍Uboot。\nUboot是一个开源项目，最早是由德国登克斯（DENX）小组的开发，然后发布在网上，许多对这款软件感兴趣的开发人员共同来维护。\nBootLoader的核心任务是什么？ 启动内核，向内核提供启动参数，完成系统软件的部署功能。\n系统加电后执行的第一段代码是什么？ BootLoader(引导程序)是系统上电后运行的第一段代码。\nU-Boot命令和环境变量 U-Boot通常支持几十个常用命令，通过这些命令，可以对目标机进行调试，也可以引导Linux内核，还可以擦写Flash完成系统部署等功能。\n常用命令： print: 通常用于打印信息或变量的值到控制台或终端。 setenv: 设置环境变量。环境变量是在操作系统中存储的配置信息，可以影响程序的行为。\nsaveenv: 保存环境变量。这个命令通常用于将当前的环境变量设置保存到非易失性存储器，以便在系统重启后保持这些设置。\nping: 网络诊断工具，用于测试主机之间的网络连接是否可达。\ntftp: Trivial File Transfer Protocol（简单文件传输协议）的缩写，用于在设备之间传输文件。\nboot: 启动系统或加载执行程序。\n组合命令 movi read:用来读取iNand到DDR上 movi write:用来将DDR写到到iNand上 注释：\n非易失性存储器 iNand 动态数据随机存取存储器 DDR linux内核简介 Linux内核主要功能有：\n进程管理 内存管理 文件管理 设备管理 网络管理 Linux内核源代码非常庞大，它使用目录树结构，内核源码的顶层有许多子目录,分别组织存放各种内核子系统或者文件,如下表： Linux内核移植 Linux内核支持多种处理器，如果目标机使用的是ARM处理器核，使用的交叉编译工具链是arm-linux-，内核移植时要指定处理器的类型以及使用的交叉编译工具链，简述具体操作方法。\n具体操作如下。 打开内核顶层目录下的Makefile文件，在文件中找到如下内容。 ARCH？=$(SUBARCH) CROSS_COMPILE?=$(CONFIG_CROSS_COMPILE:“%”=%) 将找到的以上代码修改为如下内容。 ARCH？=arm CROSS_COMPILE?=arm-none-linux-gnueabi- 其中，ARCH是CPU架构变量；CROSS_COMPILE是交叉编译工具链变量。修改完成后，保存文件退出。\n驱动程序 驱动程序的功能 对设备初始化和释放 数据传输:把数据从内核传送到硬件和从硬件读取数据,读取应用程序传送给设备文件的数据和回送应用程序请求的数据. 检测和处理设备出现的错误 Open入口点 对象：字符设备文件； 特点：字符设备文件都需要经过open入口点调用 open子程序功能：为I/O口作必要的准备工作 同一时刻只能有一个程序访问此设备（即设备是独占的）,则 open子程序必须设置一些标志以表示设备处于忙碌状态。open子程序的调用格式如下。 int open(char * filename,int acess)\n第一个功能中 打开设备是由调用定义在incliude/linux/fs.h中的file_operations结构体中的 open()函数完成的。open()函数主要完成的主要工作：\n1.若是首次打开，先初始化 2.增加设备的使用计数 3.检测设备是否异常，及时发现设备相关错误 4.读取设备次设备号。\n驱动程序的主要组成部分 自动配置和初始化子程序：检测驱动的硬件设备是否正常，能否正常工作 服务子程序和中断服务程序:这两者分别是驱动程序的上下两部分。 驱动上部分，即设备服务子程序，它是系统调用的结果，并且伴随着用户态向核心态的演变，在此过程中还可以调用与进程运行环境有关的函数，比如 sleep()函数。 驱动程序的下半部分，即中断服务子程序 Linux设备分类 （用C表示设备） 字符设备 块设备 网络设备 应用程序操作设备框图 简述驱动程序和应用程序的区别 第一，应用程序一般有一个main函数，并从头到尾执行一个任务；驱动程序没有main函数，它在加载时，通过调用module_init宏，完成驱动设备的初始化和注册工作之后便停止工作，并等待被应用程序调用。\n第二，应用程序可以和GLIBC库连接，因此可以包含标准的头文件；驱动程序不能使用标准的C库，因此不能调用所有的C库函数，比如输出函数不能使用printf，只能用内核的printk，包含的头文件只能是内核的头文件，比如Linux/module.h。\n第三，驱动程序运行在内核空间（又称内核态）比应用程序执行的优先级要高很多。应用程序则运行在最低级别的用户空间（又称用户态），在这一级别禁止对硬件的直接访问和对内存的未授权访问。\n应用程序一般有一个main函数,并从头到尾执行一个任务； 应用程序可以和 GLIBC 库连接,因此可以包含标准的头文件； 驱动程序运行在内核空间(又称内核态),比应用程序执行的优先级要高很多。\n附件\r嵌入式复习PPT.pptx (659 KB)\r嵌入式作业.docx (52 KB)",
    "description": "基于Cortex-A9微处理器的硬件平台 RISC和CISC RISC是精简指令集计算机，CISC是复杂指令集计算机\nRISC（精简指令集计算机，Reduced Instruction Set Computer）和CISC（复杂指令集计算机，Complex Instruction Set Computer）是两种不同的计算机架构设计理念，它们在指令集的复杂性、指令执行方式、硬件实现等方面有所区别。以下是RISC和CISC的主要特点及其区别：",
    "tags": [
      "嵌入式",
      "Cortex-A9微处理器",
      "Linux操作系统"
    ],
    "title": "嵌入式系统设计知识点",
    "uri": "/class/12.%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: B5-比赛",
    "uri": "/categories/b5-%E6%AF%94%E8%B5%9B/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: STM32学习",
    "uri": "/tags/stm32%E5%AD%A6%E4%B9%A0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: X1-项目",
    "uri": "/categories/x1-%E9%A1%B9%E7%9B%AE/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r项目",
    "content": "以下笔记皆基于HAL库。\n新建STM32CubeMX工程步骤 创建工程中如果勾选MCO表示向外部输出时钟， 输出的是哪一个引脚可以查看，如下图。 外部时钟设置 工程设置 如果Application Structure设置为Basic，那么会把下面的两个文件分开放 否则项目会把两个文件放在一个文件夹里，如Core\n最后还需要设置Code Generator，如下： 时钟 1.初识时钟周期\n2.时钟树 3.时钟配置步骤 4.外设时钟使能和失能\n5.sys_stm32_cloc_init()函数\nHAL_RCC_OscConfig()\nHSE高速外设振荡器 LSE RC振荡器，随着电压的变化而变化，所以需要一个检验值 PLL锁相环 HAL_RCC_ClockConfig() 第一个参数 结构体中的第一个参数里的HCLK是指AHB总线、PCLK1是指APB1总线、PCLK2是指APB2总线，这个配置表示要配那条总线的时钟。 第二个形参 F1系统时钟72MHz,如果使用72MHz访问闪存（Flash）那么是需要等待的，因为闪存的允许最大时钟频率是42MHz,所以需要等待，等待多少个周期需要下图 6.SYSTEN文件夹\nsys文件夹 NVIC介绍 中断基本概念 中断向量表 文件里的中断在哪里呢？ 在文件startup_stm32f10x_hd.s中这里列出内部中断，外部中断就在内部中断之下，这里不再列出。\n__Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD MemManage_Handler ; MPU Fault Handler DCD BusFault_Handler ; Bus Fault Handler DCD UsageFault_Handler ; Usage Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD SVC_Handler ; SVCall Handler DCD DebugMon_Handler ; Debug Monitor Handler DCD 0 ; Reserved DCD PendSV_Handler ; PendSV Handler DCD SysTick_Handler ; SysTick Handler\r中断寄存器 中断原理 中断优先级 响应优先级又叫子优先级\n中断的抢占优先级由AICR寄存器的后三位控制，而响应优先级由IPRx寄存器的后四位控制，最终分配结果参考下面的表格 中断一般只设置一次，设置多次可能会导致中断紊乱，一般以最后一次的中断设置为准，详细说明参考手册4.4.5\n中断执行的顺序：抢占优先级（先执行数值小的）————响应优先级（先执行数值小的）————自然优先级（先执行数值大的）\nNVIC 的使用 以下笔记皆基于标准库。\n标准库中额中断 EXTI（Extern Interrupt）外部中断 EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序\n简而言之，gpio电平发生变化时，申请外部中断。\n支持的触发方式：上升沿/下降沿/双边沿/软件触发（引脚没有发生变化，执行一段代码就申请中断） 支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断（如PA1，PB1，PC1不能同时触发中断） 通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒 触发响应方式：中断响应/事件响应（事件响应不会触发中断。而是触发别的外设操作。属于外设之间的联合工作） AFIO复用IO口 主要用于引脚复用功能的选择和重定义\n在STM32中，AFIO主要完成两个任务：\n复用功能引脚重映射 中断引脚选择 EXTI实现代码 这段代码的中断端口是GPIOB_Pin14，所以需要将相关的传感器接到PB14这个端口\nvoid CountSensor_Init(){ //配置RCC RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); //AFIO、 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); //EXTI、一直打开着不用配置打开时钟 //NVIC 一直打开着不用配置打开时钟 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOB,\u0026GPIO_InitStructure); GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14); //EXTI EXTI_InitTypeDef EXTI_InitStructure; EXTI_InitStructure.EXTI_Line=EXTI_Line14; EXTI_InitStructure.EXTI_LineCmd=ENABLE; EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling; EXTI_Init(\u0026EXTI_InitStructure); //NVIC NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel=EXTI15_10_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2; NVIC_InitStructure.NVIC_IRQChannelSubPriority=0; NVIC_Init(\u0026NVIC_InitStructure); } void EXTI15_10_IRQHandler(void){//中断函数 if(EXTI_GetITStatus(EXTI_Line14)== SET){ EXTI_ClearITPendingBit(EXTI_Line14); } }\r定时器 TIM（Timer）定时器 定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断\n16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时 不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能 根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型\n使用内部时钟源实现中断（标准库中） 在编写代码前先看看定时器的实现原理图\n基本定时器 通用定时器 高级定时器（红色框出来的部分是高级定时器独有的） 此处主要参考通用计时器的结构图，下面是基于内部时钟RCC的定时器。\n在 stm32f103xxx_rcc.c 文件对 RCC_APB1PeriphClockCmd 这样的介绍：\n/** * @brief Enables or disables the High Speed APB (APB2) peripheral clock. * @param RCC_APB2Periph: specifies the APB2 peripheral to gates its clock. * This parameter can be any combination of the following values: * @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, …… …… ……+ */\rspecifies the APB2 peripheral to gates its clock.即：指定APB 2外围设备到其时钟门。而这里的时钟门代码里选择了TIM2。\nvoid Timer_Init(void){ //1.RCC RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE); //2.选择时基单元时钟源， TIM_InternalClockConfig(TIM2); //3.时基单元 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1;\t//时钟分频，这里是1分频 TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;\t//计数方式 TIM_TimeBaseInitStructure.TIM_Period=10000-1;\t//自动重装值，计数达到这个值后触发中断，然后重新开始计数 TIM_TimeBaseInitStructure.TIM_Prescaler=7200 -1;\t//预分频，计数频率， //假设计数为1s则自动重装值可设置为10000，预分频可设置为7200，公式为秒数=27MHz/PSC/ARR TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;\t//重复计数数器高级定时器才有，这里设置为0 TIM_TimeBaseInit(TIM2,\u0026TIM_TimeBaseInitStructure);\t//时基单元设置 TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE); //4.中断输出控制 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\t//抢占优先级,0-3， 响应优先级0-3，一个工程只设置一次 //5.NVIC NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn; NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1; NVIC_InitStructure.NVIC_IRQChannelSubPriority=1; NVIC_Init(\u0026NVIC_InitStructure); TIM_Cmd(TIM2,ENABLE); } void TIM2_IRQHandler(void){ if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET){ Num++; TIM_ClearITPendingBit(TIM2,TIM_IT_Update); } }\r实现输出比较 OC（Output Compare）输出比较 输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形\n每个高级定时器和通用定时器都拥有4个输出比较通道\n高级定时器的前3个通道额外拥有死区生成和互补输出的功能\nOC：输出比较\nIC：输入比较\nCC：输入/输出比较\nPWM波形 PWM（Pulse Width Modulation）脉冲宽度调制，广泛应用于各种电子和电气系统中，用于控制功率转换、电机速度、信号传输等 在具有^1中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域 ^1 PWM参数： 频率 = 1 / TS 占空比 = TON / TS 分辨率 = 占空比变化步距 一些电平变化图可以等效为图中的虚线。 上图框出来的部分具体如下图： 在信号通过比较后输出到CC1P，然后再输出到输出使用电路，输出使用电路的OC1可以查看引脚定义表\n在上图中需要注意的一些引文缩写：\nREF 是reference的缩写。意思是 参考信号 输出比较的设置 设置的函数为\nPWM基本结构 配置PWM的时候可以参考下面的图， 图中的参考坐标系图红色线表示CCR的值，蓝色线表示CNT的值，黄色线表示自动重装载值即ARR。 了解了这点后我们再看看PWM的是如何计算的，如下公式\nPWM频率： [ \\text{Freq} = \\frac{CKPSC}{(PSC + 1) \\times (ARR + 1)} ] 可以看出PWM的频率等于CNT的更新频率\nPWM占空比： [ \\text{Duty} = \\frac{CCR}{(ARR + 1)} ]\nPWM分辨率： [ \\text{Reso} = \\frac{1}{(ARR + 1)} ]\n代码编写 附件",
    "description": "以下笔记皆基于HAL库。\n新建STM32CubeMX工程步骤 创建工程中如果勾选MCO表示向外部输出时钟， 输出的是哪一个引脚可以查看，如下图。",
    "tags": [
      "STM32学习"
    ],
    "title": "电赛",
    "uri": "/projects/%E7%94%B5%E8%B5%9B/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "参数context 与环境变量有关，不管是系统还是用户自定义的都用这个来获取，获取方式：context.env\n先部署云函数到远端，然后在去远端添加环境变量，然后在本地运行虚拟机查看。 负载均衡的四种方式\n随机 轮询 最少连接数 最短响应时间 延迟时长的重试策略\nzero:一旦云函数调用失败，则调用，中间不等待 constant：调用失败等一段时间 jittered:调用失败等一段时间，再次调用，如果失败等待时间以指数增长 熔断\n设置一定的条件，满足条件后会执行熔断。熔断后云函数不在提供服务。\n附件",
    "description": "参数context 与环境变量有关，不管是系统还是用户自定义的都用这个来获取，获取方式：context.env\n先部署云函数到远端，然后在去远端添加环境变量，然后在本地运行虚拟机查看。 负载均衡的四种方式",
    "tags": [
      "ArkTS",
      "OpenHarmony",
      "HarmonyOS",
      "云端一体化"
    ],
    "title": "6.云端一体化的环境变量问题",
    "uri": "/log/6.%E4%BA%91%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: ArkTS",
    "uri": "/tags/arkts/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: HarmonyOS",
    "uri": "/tags/harmonyos/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: OpenHarmony",
    "uri": "/tags/openharmony/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 应用开发",
    "uri": "/categories/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 云端一体化",
    "uri": "/tags/%E4%BA%91%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "调用云函数的时候我们总有输入输出结果不符合自己预期的时候，这个时候查看日志很重要！！在云端一体化开发过程中，我们可以通过下面的方式解决这一问题：\n首先参数event的输出以JSON格式输出，这样方便阅读，下面有一段代码，\n云函数代码如下：\nimport { stringify } from \"querystring\"; let myHandler = async function (event, context, callback, logger) { logger.info(JSON.stringify(event)); const name = event.body.name callback({ code: 200, message: `Hello ${name}.` }); }; export { myHandler };\r获取信息的ets文件如下：\nimport cloud from '@hw-agconnect/cloud'; @Entry @Component struct MyIndex { @State message: string = '' @State name:string = '' build() { Row() { Column() { TextInput({placeholder:'请输入姓名'}) .onChange(value =\u003e { this.name = value }) Button('使用云端一体化') .fontSize(20) .onClick(async ()=\u003e{ const result = await cloud.callFunction({ name:'login',//云函数的名字 version:'$latest', params:{name:this.name} }) this.message=result.getValue().message }) Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) } .width('100%') } .height('100%') } }\rfunction函数的说明：\n触发条件： HTTP请求， 云数据库插入， 云存储 参数含义： 输入信息（）， 执行时上下文信息（环境变量）， 输出（返回结果给调用者）， 记录日志（） 此处做了这样的处理使得日志输出以JSON格式输出：\nlogger.info(JSON.stringify(event))\r当遇到问题时，去官方的开发论坛搜索相关内容， 此处我想实现输入一个名字，然后让云端函数以不同的方式输出，比如：\n你好，张三\n你好，李四\n但是现在输出的是：你好，%\u0026*%%\n解决办法：\n查看event参数说明\n再去CAG官网选择云监控—\u003e日志服务\n然后复制右边的内容,放到一个json文件夹，用编译器（比如VScode）打开，并调整格式(如果用的是VScode，请使用shift+alt+F调整json格式)如下：\n{\r\"path\": \"login-$latest\",\r\"httpMethod\": \"POST\",\r\"headers\": {\r\"user-agent\": \"libcurl-agent/1.0\",\r\"x-forwarded-for\": \"115.46.239.151, 10.135.135.154, 10.134.64.11\",\r\"x-forwarded-port\": \"443\",\r\"accept\": \"*/*\",\r\"accept-encoding\": \"gzip\",\r\"agcgw-trigger-authtype\": \"apigw-client\",\r\"host\": \"10.14.4.31\",\r\"content-type\": \"application/json;charset=UTF-8\",\r\"packagename\": \"com.itwcx.test\",\r\"appid\": \"5765880207853994135\",\r\"authorization\": \"SDK-HMAC-SHA256 containPath=false,containBody=false,containQuery=false,accessId=m7rTGQ2uNvyq1AGfJFLo,timestamp=1711175951586,signedHeaders=appid;productid,signature=44fe3b4da7d80ec9dfee07ca3747c448e94254b5454fef87f468150089f38623\",\r\"x-forwarded-host\": \"10.14.4.31\",\r\"appversion\": \"1.0.0\",\r\"sdkplatformversion\": \"3.2.0.0\",\r\"sdktype\": \"TS\",\r\"content-length\": \"19\",\r\"x-real-ip\": \"10.134.64.11\",\r\"sdkversion\": \"1.0.0\",\r\"x-forwarded-proto\": \"https\",\r\"sdkservicename\": \"agconnect-cloud\",\r\"x-trace-id\": \"f09f1070-6d7b-46a9-875d-bfb2bc4bfdb9\",\r\"productid\": \"388421841222044287\",\r\"sdkplatform\": \"OpenHarmony\"\r},\r\"queryStringParameters\": \"\",\r\"queryParameters\": null,\r\"body\": \"{\\\"name\\\":\\\"zhangsan\\\"}\",\r\"isBase64Encoded\": false,\r\"pathVariable\": null\r}\r此处我们只查看参数event的HTTP请求的相关说明：\n比较官网的event参数格式与自己日志打印的格式，看看有什么不同\n观察可知问题出在body这个参数，参数是json格式，而日志打印的是字符格式，我们需要把字符格式转换成json格式，做如下操作：\nimport { stringify } from \"querystring\"; let myHandler = async function (event, context, callback, logger) { logger.info(JSON.stringify(event)); const obj = JSON.parse(event.body) const name = obj.name callback({ code: 200, message: `Hello ${name}.` }); }; export { myHandler };\r上面的代码中\nconst obj = JSON.parse(event.body)\rconst name = obj.name\r就是转换操作。\n认证服务 登录页面的实现 登录验证代码：\nimport { AuthMode,Login } from '@hw-agconnect/auth-component' import { AuthUser } from '@hw-agconnect/cloud' import router from '@ohos.router' @Entry @Component struct MyLogin { @State message: string = 'Hello World' build() { Row() { Column() { Login({ modes:[AuthMode.PHONE_VERIFY_CODE], onSuccess:(usr:AuthUser) =\u003e{ router.pushUrl({url:'page/MyWelcome'}) } }){ Button('登录') } } .width('100%') } .height('100%') } }\r页面登录获取验证码 import { Auth, VerifyCodeAction } from '@hw-agconnect/cloud'; import cloud from '@hw-agconnect/cloud' import hilog from '@ohos.hilog' import router from '@ohos.router'; @Entry @Component struct MyLogin { @State countDown: number = 10 //用一个变量来获取setinterval的ID intervalId:number = 0 //因为这个变量与页面显示无关所以不用@State注释 @State verifyCodeButtonEnable:boolean = false @State verifyCodeButtonText:string ='获取验证码' @State phoneNumber: string = '' @State verifyCode:string = '输入验证码' //定时器代码 waiting(){ this.verifyCodeButtonEnable = false this.verifyCodeButtonText = `${this.countDown}s`//在一点击时，就显示10S this.intervalId = setInterval(() =\u003e { //要知道定时器结束没有需要知道它的返回结果，这个结果可以通过setinterval的ID获取。 this.verifyCodeButtonText = `${this.countDown}s`//将倒计时显示出来 if(this.countDown \u003c 0){ //如果减到0，清楚定时器 clearInterval(this.intervalId)//得到返回结果后清楚定时器 this.countDown = 10 this.intervalId = 0 this.verifyCodeButtonText = '获取验证码'//倒计时结束时回复 this.verifyCodeButtonEnable = true //当点击时按键不可用 return //不需要再往下继续执行了，所以return } this.countDown-- },1000)//每隔1秒减一次 } judgement(){ if(this.phoneNumber.length === 11){ this.verifyCodeButtonEnable=true }else { this.verifyCodeButtonEnable=false } } async sending_verifyCode(){ try { //调用方式异步调用 await cloud.auth().requestVerifyCode({ verifyCodeType: { kind: 'phone', phoneNumber: this.phoneNumber, countryCode: '86' }, action: VerifyCodeAction.REGISTER_LOGIN, //验证的方式 lang: 'zh_CN', sendInterval: 10 }) hilog.info(0,'VerifCode','Success') } catch (e) { AlertDialog.show({ title: '错误', message: '验证码失败' })//弹窗内容 hilog.info(0,'VerifCode',JSON.stringify(e)) } } async login_verify(){ try { const result = await cloud.auth().signIn({ //定义一个变量来接收它的返回结果,返回的是result，在通过result.gitUsr获取用户信息 credentialInfo: { kind: 'phone', countryCode: '86', phoneNumber: this.phoneNumber, verifyCode: this.verifyCode } }) const user = result.getUser() AppStorage.SetOrCreate('user',user)//存储用户到 AppStorage hilog.info(0,'Login','Success') router.replaceUrl({ url: 'pages/MyLoginLignOut' }) } catch (e) { AlertDialog.show({title:'错误',message:'登陆失败'}) hilog.info(0,'Login',JSON.stringify(e)) } } build() { Row() { Column() { TextInput({placeholder:'请输入手机号'}) .type(InputType.Number) .onChange(values =\u003e{ this.phoneNumber = values this.judgement()//点击获取验证码时，判断按键是否可用 }) Row(){ TextInput({placeholder:'验证码'}) .width('70%') .onChange(value =\u003e{ this.verifyCode=value }) Button(this.verifyCodeButtonText) .width('30%') .enabled(this.verifyCodeButtonEnable)//该属性是控制按键是否可用 .onClick(async () =\u003e{ //所在方法加async this.waiting() this.sending_verifyCode() }) } .width('100%') Button('登录') .enabled(this.phoneNumber.length === 11 \u0026\u0026 this.verifyCode.length === 6)//手机号11位，且验证码六位时点击登录才有效 .onClick(async ()=\u003e{ this.login_verify() }) } .width('100%') } .height('100%') } }\r登录后跳转到的页面：\nimport cloud ,{AuthUser}from \"@hw-agconnect/cloud\" import hilog from '@ohos.hilog' import router from '@ohos.router' @Entry @Component struct MyLoginLignOut { @State photoUrl:string = '' //存储头像路径 @State displayName:string = '' //存储用户昵称 @StorageLink('user') user:AuthUser = null //定义一个AuthUser的类型来获取用户存的值，('user')叫存储对象名，是在另一个页面定义的名字 aboutToAppear(){//build渲染前就运行 //1.cloud.auth().getCurrentUser() //2.appStorage this.displayName = this.user.getDisplayName()//获取用户，间接通过用户拿到用户头像等数据。 this.photoUrl = this.user.getPhotoUrl() } build() { Row() { Column() { Row(){ Image(this.photoUrl?this.photoUrl:$r('app.media.app_icon')) .width(80) .height(80) .onClick(()=\u003e{ this.photoUrl= 'https://img.btstu.cn/api/images/5a2a5d5560223.jpg' }) }.width('100%') .justifyContent(FlexAlign.Center) .padding({bottom:70}) TextInput({placeholder:'设置昵称',text:this.displayName}) .fontSize(25) .fontWeight(FontWeight.Bold) .onChange(value =\u003e{ this.displayName = value }) Button('保存') .margin({top:10,bottom:10}) .width(90) .onClick(async ()=\u003e{//保存图片与用户名 try { await this.user.updateProfile({//保存头像、用户名 displayName: this.displayName, photoUrl: this.photoUrl }) hilog.info(0,'updateProfile','Success') } catch (e) { hilog.info(0,'updateProfile',JSON.stringify(e)) } }) Button('登出') .margin({top:10,bottom:10}) .width(90) .onClick(async ()=\u003e{ try { await cloud.auth().signOut() hilog.info(0,'SignOut','Success') router.replaceUrl({url:'pages/MyLogin'}) } catch (e) { hilog.info(0,'SignOut',JSON.stringify(e)) } }) } .width('100%') } .height('100%') } }\r个人设置中心 import cloud, { AuthUser } from '@hw-agconnect/cloud' import router from '@ohos.router' import hilog from '@ohos.hilog' import picker from '@ohos.file.picker' @Entry @Component struct MyIndex { @State photoUrl: string = '' //存储头像路径 @State displayName: string = '' //存储用户昵称 @StorageLink('user') user: AuthUser = null //定义一个AuthUser的类型来获取用户存的值，('user')叫存储对象名，是在另一个页面定义的名字 @State uploading: boolean = false//用户控制图片是否可以点击，上传时不可以点击 @State uploadingText: string = '0%'//上传进度 aboutToAppear() { //build渲染前就运行 // 1. cloud.auth().getCurrentUser() // 2. AppStorage this.displayName = this.user?.getDisplayName()//获取用户，间接通过用户拿到用户头像等数据。加问号是因为在aboutToAppear运行时是无法获取用户名或图片等信息的 this.photoUrl = this.user?.getPhotoUrl() } build() { Row() { Column({ space: 10 }) { Stack() {//Stack该属性让它所包含的组件重叠 Image(this.photoUrl ? this.photoUrl : $r('app.media.user_dark')) .width(70) .height(70) .borderRadius(70) .enabled(!this.uploading) .onComplete(()=\u003e{ this.uploading = false }) .onClick(async () =\u003e { // this.photoUrl = '网络图片的地址' try { // 1. 从相簿中选照片 const options = new picker.PhotoSelectOptions() options.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE//媒体类型：视频还是图片 options.maxSelectNumber = 1//最大选择个数 const result = await new picker.PhotoViewPicker().select(options)//把参数传给下面的方法，把结果传给result hilog.info(0, 'Upload', `Picker Success ${result.photoUris[0]}`) this.uploading = true // 2. 调云存储 api 上传照片 await cloud.storage().upload({ localPath: result.photoUris[0],//本地图片路径 cloudPath: `test/${this.user.getUid()}.jpg`,//云存储那边存储的路径 onUploadProgress: event =\u003e { const percent = Math.floor(100 * event.loaded / event.total)//获取上传的百分比，event.loaded：已上传的自己数，event.total：总的自己数，Math.floor：舍弃小数点 this.uploadingText = `${percent}%` //数值更新到uploadingText } }) hilog.info(0, 'Upload', 'Upload Success') // 3. 获取上传照片的网络地址 const url = await cloud.storage().getDownloadURL(`test/${this.user.getUid()}.jpg`)//获取公网地址，拿到图片在网络上的地址 this.photoUrl = `${url}\u0026ts=${new Date().getTime()}`//这个里做这个处理是因为，图片被缓存起来了，上传的时候如果只是给云存储的地址，那么在传第二张图片到云存储后，photoUrl再获取时，因为图片地址不变照片也不会改变，它会缓存起来，而在图片后面加上一个时间图片就不在被缓存。 // this.uploading = false hilog.info(0, 'Upload', `url: ${url}`) } catch (e) { hilog.error(0, 'Upload', JSON.stringify(e)) } }) if (this.uploading) { // 显示上传进度 Text(this.uploadingText) .width(70) .height(70) .borderRadius(70) .fontColor('white') .backgroundColor('black') .opacity(0.6) .fontSize(24) .fontWeight(FontWeight.Bolder) .textAlign(TextAlign.Center)//文字对齐方式 } } TextInput({ placeholder: '请设置昵称', text: this.displayName }) .width('50%') .onChange(value =\u003e { this.displayName = value }) Button(`保存`) .onClick(async () =\u003e { try { await this.user.updateProfile({ displayName: this.displayName, photoUrl: this.photoUrl }) hilog.info(0, 'updateProfile', 'Success') } catch (e) { hilog.error(0, 'updateProfile', JSON.stringify(e)) } }) Button(`登出`) .onClick(async () =\u003e { try { await cloud.auth().signOut() hilog.info(0, 'SignOut', 'Success') router.replaceUrl({ url: 'pages/MyLoginCustom' }) } catch (e) { hilog.error(0, 'SignOut', JSON.stringify(e)) } }) } .width('100%') } .height('100%') } }\r登录页面 import { Auth, VerifyCodeAction } from '@hw-agconnect/cloud'; import cloud from '@hw-agconnect/cloud' import hilog from '@ohos.hilog' import router from '@ohos.router'; @Entry @Component struct MyLogin { @State countDown: number = 10 //用一个变量来获取setinterval的ID intervalId:number = 0 //因为这个变量与页面显示无关所以不用@State注释 @State verifyCodeButtonEnable:boolean = false @State verifyCodeButtonText:string ='获取验证码' @State phoneNumber: string = '' @State verifyCode:string = '输入验证码' private mainPage = `pages/StudentPage` async aboutToAppear() { try { const user = await cloud.auth().getCurrentUser()//获取当前认证用户 if (user != null) {//获取用户是否为空，如果用户已经断开会话，则下一次进入时间走时登录流程 AppStorage.SetOrCreate('user', user) // 如果会话未断开，不走登录流程，而是吧用户数据存到AppStorage router.replaceUrl({ url: this.mainPage }) } } catch (e) { hilog.error(0, 'Login', JSON.stringify(e)) } } //定时器代码 waiting(){ this.verifyCodeButtonEnable = false this.verifyCodeButtonText = `${this.countDown}s`//在一点击时，就显示10S this.intervalId = setInterval(() =\u003e { //要知道定时器结束没有需要知道它的返回结果，这个结果可以通过setinterval的ID获取。 this.verifyCodeButtonText = `${this.countDown}s`//将倒计时显示出来 if(this.countDown \u003c 0){ //如果减到0，清楚定时器 clearInterval(this.intervalId)//得到返回结果后清楚定时器 this.countDown = 10 this.intervalId = 0 this.verifyCodeButtonText = '获取验证码'//倒计时结束时回复 this.verifyCodeButtonEnable = true //当点击时按键不可用 return //不需要再往下继续执行了，所以return } this.countDown-- },1000)//每隔1秒减一次 } judgement(){ if(this.phoneNumber.length === 11){ this.verifyCodeButtonEnable=true }else { this.verifyCodeButtonEnable=false } } async sending_verifyCode(){ try { //调用方式异步调用 await cloud.auth().requestVerifyCode({ verifyCodeType: { kind: 'phone', phoneNumber: this.phoneNumber, countryCode: '86' }, action: VerifyCodeAction.REGISTER_LOGIN, //验证的方式 lang: 'zh_CN', sendInterval: 10 }) hilog.info(0,'VerifCode','Success') } catch (e) { AlertDialog.show({ title: '错误', message: '验证码失败' })//弹窗内容 hilog.info(0,'VerifCode',JSON.stringify(e)) } } async login_verify(){ try { const result = await cloud.auth().signIn({ //定义一个变量来接收它的返回结果,返回的是result，在通过result.gitUsr获取用户信息 credentialInfo: { kind: 'phone', countryCode: '86', phoneNumber: this.phoneNumber, verifyCode: this.verifyCode } }) const user = result.getUser() AppStorage.SetOrCreate('user',user)//存储用户到 AppStorage hilog.info(0,'Login','Success') router.replaceUrl({ url: 'pages/MyLoginLignOut' }) } catch (e) { AlertDialog.show({title:'错误',message:'登陆失败'}) hilog.info(0,'Login',JSON.stringify(e)) } } build() { Row() { Column() { TextInput({placeholder:'请输入手机号'}) .type(InputType.Number) .onChange(values =\u003e{ this.phoneNumber = values this.judgement()//点击获取验证码时，判断按键是否可用 }) Row(){ TextInput({placeholder:'验证码'}) .width('70%') .onChange(value =\u003e{ this.verifyCode=value }) Button(this.verifyCodeButtonText) .width('30%') .enabled(this.verifyCodeButtonEnable)//该属性是控制按键是否可用 .onClick(async () =\u003e{ //所在方法加async this.waiting() this.sending_verifyCode() }) } .width('100%') Button('登录') .enabled(this.phoneNumber.length === 11 \u0026\u0026 this.verifyCode.length === 6)//手机号11位，且验证码六位时点击登录才有效 .onClick(async ()=\u003e{ this.login_verify() }) } .width('100%') } .height('100%') } }\r希望文档对你有所帮助。\n附件",
    "description": "调用云函数的时候我们总有输入输出结果不符合自己预期的时候，这个时候查看日志很重要！！在云端一体化开发过程中，我们可以通过下面的方式解决这一问题：",
    "tags": [
      "ArkTS",
      "OpenHarmony",
      "HarmonyOS",
      "云端一体化"
    ],
    "title": "5.云端一体化如何查看云函数日志？",
    "uri": "/log/5.%E4%BA%91%E7%AB%AF%E4%B8%80%E4%BD%93%E5%8C%96%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BA%91%E5%87%BD%E6%95%B0%E6%97%A5%E5%BF%97/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "数据类型 练习网址：\n条件语句 拓展：for in与for of的使用\nfor in ：遍历得到数组的角标， for of ：直接得到元素。 函数 使用function关键字声明函数，\nfunction outname(name:string):void{ console.log('你好'+name+\"!\") } //第二种写法： let outname = (name:string)=\u003e{ console.log('你好'+name+\"!\") } outname('lucy')\rts还提供了一种可传参数和不传参数也执行的函数的操作，写法如下：\nlet outname = (name:string='张三')=\u003e{ console.log('你好'+name+\"!\") } outname()\r面向对象 模块的导入导出 提高代码的重复使用 组件的使用 image组件 textinput组件 TextInput({text:this.imagewidth.toFixed(0)}) .width(150) .backgroundColor('#36D00A') .type(InputType.Number) .onChange( values =\u003e{ this.imagewidth = parseInt(values) }) TextInput({placeholder:'nihao'}) .width(150) .backgroundColor('#4399')\r效果如下图： 文本框内输入的值是什么类型的数据呢？\n从上面的代码可知是字符型的，此处我们用parseInt将一个变量转换成number类型，又用方法.toFixed()将一个number类型的变量转换成字符串型。\n按键组件 滑动条组件（slider） 页面布局 线性布局 Row布局与Column布局类似，只是主轴方向不同 循环控制ForEach 使用router进行页面跳转时用replaceUrl与pushUrl的区别 后者会保留前一页信息，就是跳转后会返回上一页面，而后面的不会跳回上一页\n11–t\nf–!=11,运行时\n附件",
    "description": "数据类型 练习网址：\n条件语句 拓展：for in与for of的使用\nfor in ：遍历得到数组的角标， for of ：直接得到元素。 函数 使用function关键字声明函数，",
    "tags": [
      "ArkTS语言",
      "OpenHarmony",
      "HarmonyOS"
    ],
    "title": "ArkTS",
    "uri": "/class/1.arkts/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: ArkTS语言",
    "uri": "/tags/arkts%E8%AF%AD%E8%A8%80/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: B1-拓展笔记",
    "uri": "/categories/b1-%E6%8B%93%E5%B1%95%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "模拟电子技术知识。 模拟电子技术基础笔记常用半导体器件 本征半导体 半导体：介于导体与绝缘体之间的\n本征半导体： 载流子 3.1 本征激发 3.2 自由电子，带负电 3.3 空穴，带正电 自由电子和空穴都能到点。 3.4 复合：与本真激发相反的过程",
    "description": "模拟电子技术知识。 模拟电子技术基础笔记常用半导体器件 本征半导体 半导体：介于导体与绝缘体之间的\n本征半导体： 载流子 3.1 本征激发 3.2 自由电子，带负电 3.3 空穴，带正电 自由电子和空穴都能到点。 3.4 复合：与本真激发相反的过程",
    "tags": [
      "电子电路"
    ],
    "title": "电子电路",
    "uri": "/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 电子电路",
    "uri": "/tags/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 模电",
    "uri": "/tags/%E6%A8%A1%E7%94%B5/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r电子电路",
    "content": "常用半导体器件 本征半导体 半导体：介于导体与绝缘体之间的\n本征半导体： 载流子 3.1 本征激发 3.2 自由电子，带负电 3.3 空穴，带正电 自由电子和空穴都能到点。 3.4 复合：与本真激发相反的过程\n本征半导体的导电能力与载流子的浓度有关：此时处于动态平衡，本证激发与复合的速度一样。\n从工程的角度看，只加热温度让导电能力增加不实际，还好它具有掺杂别的东西让导电能力增加。\n杂质半导体 概念 掺杂少量 的杂志元素。\nN型半导体 掺杂P元素（5价元素），本征半导体的导电能力增加，自由电子是多子，空穴是少子；\n温度对多子影响小，因为多子本身就多，但对少子浓度的影响大，因为少子的量少；\nP型半导体 掺杂硼元素（3价元素），本征半导体的导电能力增加，自由电子是少子，空穴是多子；\nPN结半导体 1.扩散运动：在浓度梯度的作用下，浓度高的地方向浓度低的地方扩散；\n2.空间电荷区（耗尽层、PN结），这里举个例子，就右边空间电荷区的正电荷而言，从电场线出发，两边平衡我们可以理为正电荷发出的电场阻止了左边的空穴移动，而对于负电荷他也有这样的特性，所以两边达到平衡的状态。\n虽然中间有空间电荷区形成势垒（由电压形成）组织了两遍的多子运动，但是这样的势垒能百分之百阻止多子向两边运动吗？\n答案是不完全，还是有一小部分的多子冲破避雷向两边运动。下面是一张简单的图。\n3.漂移运动：两边少子的运动称之为漂移运动\n4.对称结与不对称结：由上面的图可以看出两边宽度一样，原因是掺杂的浓度一样，如果不一样？那么两边就不对称了，这时候称之为不对称结。\n加外电压的PN结半导体 加正电压（P流向N，空间电荷区被削弱） 加反向电压（，空间电荷区增加） 这个时候的漂移运动是增加的，但漂移运动是由少子形成的所以他的影响是很小的，值得注意的是漂移运动对 温度 是很敏感的。\nPN结的电流方程 $i=I_s(e^{U/U{_T}}-1),其中V_T=26V$\n锗：0.2-0.3V 硅：0.6-0.7V\n特性 正向特性 反向特性 2.1雪崩击穿（掺杂浓度低，温度越高，击穿电压越高，因为粒子需要加速） 2.2齐纳击穿（掺杂浓度高，温度越高，击穿电压越低，因为） PN结的电容效应 当正负极两边的电压变化时，中间的电量发生改变；\n1.势垒电容 2.扩散电容：非平衡少子形成 电压增高为2线，浓度增高，电压减小为3，浓度降低；\n半导体二极管 常见结构 伏安特性 体电阻的存在，电流的PN结小； 反向电流大一些； 温度的影响 正向电流：温度升高，本证激发，粒子热运动增加，所以电压固定的时候，温度高的电流可定大，所以曲线往上走；\n反向电流：温度升高，对少子影响大，饱和电流增加，所以曲线往下走；\n二极管作用 单向导电性，规定电流流向，做整流器件；也可以稳压，但一般用反向的稳压 反向的饱和电流，简单的温度传感器； 反向截止电流，稳压二极管； 问：为什么稳压电路不用正向的电压稳压？\n二极管的主要参数 IF：工作的时候电流的最大流过电流， UR：最高反向电压， IR：反向电流（未击穿时）， FM：最高频率（选高频电路的时候需要参考）， 二极管的等效电路 1.上图a为理想的等效电路\n2.b图为常用的等效模型\n上面三张图的\r中间没有一杠，这是与普通二极管的区别。\n下面我们看二级管的几个应用：\n整流电路 在上面的这个电路中我们假设交流电10mV，要想在$u_R$中测量出变化的电流那么需要加一个直流电压，将交流电抬高，曲线图如下：\n上图B点的电压10mV升到A点，它们的关系是：$U_A=U_B+V$,那么此时就可以测量出$u_R$两端的变化的电流了。具体电路图如下：\n最后得到的波形图是去掉Y轴的负半轴的正弦三角函数图像，也就是整流电路。\n限幅电路 在分析这个电路时，要先判断正向导通和反向截止。\n当$U_S-U_1\u003c=Uon$的时候截止 当$U_S-U_1\u003e=Uon$的时候导通 这时候的三角函数上半边会被割掉如下图：\n附件",
    "description": "常用半导体器件 本征半导体 半导体：介于导体与绝缘体之间的\n本征半导体： 载流子 3.1 本征激发 3.2 自由电子，带负电 3.3 空穴，带正电 自由电子和空穴都能到点。 3.4 复合：与本真激发相反的过程",
    "tags": [
      "模电"
    ],
    "title": "模拟电子技术基础笔记",
    "uri": "/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: Version",
    "uri": "/categories/version/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r关于",
    "content": "2024-04-07 V0.1.0 修改content目录结构 删除多余，以及未完成的文章 自定义首页页面输出 更新小说内容",
    "description": "2024-04-07 V0.1.0 修改content目录结构 删除多余，以及未完成的文章 自定义首页页面输出 更新小说内容",
    "tags": [
      "网站版本",
      "网站优化"
    ],
    "title": "版本",
    "uri": "/about/%E7%89%88%E6%9C%AC/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 网站版本",
    "uri": "/tags/%E7%BD%91%E7%AB%99%E7%89%88%E6%9C%AC/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 网站优化",
    "uri": "/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 后端",
    "uri": "/tags/%E5%90%8E%E7%AB%AF/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r项目",
    "content": "比赛题目 一、项目主题 知识产权流程管理系统\n二、项目描述\n该系统用于知识产权项目申报的全过程跟踪管理，其功能包括：\n客户下单、 提交申请、 申请反馈、 订单查询、 订单详情、 文档查阅下载等六大部分。 该系统分为客户端和管理端两个子系统。客户端对客户开放，主要功能包括：\n客户下单、 付款、 订单查询、 订单进度消息推送（推送到公众号、网站内部消息）、 文档查阅下载等。 管理端对管理人员开放，不对客户开放，负责订单管理、文档上传（批量上传）等。\n三、项目需求 （一）、用户端\n个人中心模块：\n1、订单查询\n分为我的订单（综合查询）及商标、专利、版权、科技项目四大子类查询，订单查询按全部业务下单时间顺列。\n订单查询功能大致效果图： 2、订单详细\n可根据订单详情按钮跳转到对应的订单详情。 订单详情页展示图： （二）、管理端\n订单管理模块：\n1、订单查询\n查询订单，展示列表。\n2、订单详细\n在订单列表中点击某个订单，进入订单详情。\n3、文档上传\n在订单详情页，点击文档上传，选中本地文件，上传本地文件到服务器，支持批量、单文件上传。\n注册唛盟账号 队长和队员注册账号 一、扫描一级部门的二维码\n这一部分只建议参加了比赛的网友查看。本次是组队参加，一队3-5人，队长要在他们的官方网页端注册号团队（二级部门），方便后面的项目管理，然后再通过一级部门添加自己的团队，首先是扫描官方给的二维码，扫这个二维码后注册就会在一级部门下，这也是要注册在一级部门之下的办法，\n二、授权登录成功后，跳转到提示页面，点击“首页”\n三、进入低代码平台首页，按照提示，点击“账户明细”\n四、按照提示，输入姓名，并提交\n五、点击唛盟低代码平台官网，选择微信扫码登录\n唛盟低代码平台官网：https://maimengcloud.com/lcode/m1/#/login\n六、看到用户名称是自己的即报名成功\n队长注册团队 1要求 1.构建每个参赛团队的独立部门 2.将参赛队员拉入部门 3.给每个参赛队员设置好岗位 2相关环境 唛盟账户系统\n3操作步骤 3.1 在一级部门，即总部下建立子部门\n进入【部门管理】，点击【添加下级】\n3.2输入部门信息\n部门名称要求：以参赛团队名称作为部门名称 上级领导选：一级部门 部门负责人：选参赛团队组长 部门性质：技术部门 协作类型：内部组织 其它字段不填\n（如果你不是第一届比赛的同学，那这个不需要关注，可能每年都不一样）\n3.3保存提交\n3.4把岗位挂接到部门上\n【部门管理】中找到刚才建立的部门，点击【岗位】按钮弹出以下岗位选择框：\n选择左边需要绑定的岗位，移动到右边，点击【提交】按钮即完成岗位绑定（如果没有显示岗位，多次刷新，或者退出重新登录，这个知识第一届遇到此问题解决的方案）\n3.5把用户拉入部门\n打开【用户管理】菜单，先把自己的搜索出来，如果不是通过一级部门的二维码注册的，会搜不到的哦。找到需要拉入的队友，点击【部门/岗位】\n弹出以下部门岗位选择界面：\n在弹出的界面中左边选中归属的部门，右边选中岗位，再【提交】即可\n这部分本来也不想记了，毕竟没什么用了，可能下一届又不一样了，但想想自己记一下当作回忆也可以。\n安装git和nodejs 在安装前我们通过这个链接https://gitee.com/maimengcloud/mdp-lcode-ui-web去看看这个项目的介绍，\n大概浏览一下，然后往下拉根据导航直接跳到 快速开始\n这里并不是说其他的不重要，只是说对于一个项目而言如果不是涉及本地启动的话不必花费时间去纠结，等你能让项目在本地启动后再回来看看也不迟，当然这也有弊端，可能会错一些细节哈。\n在快速开始的地方提到：\n注意：该项目使用 element-ui@2.3.0+ 版本，所以最低兼容 vue@2.5.0+ nodejs版本v14.16.1\n所以我们安装的时候要注意版本的问题尽量不要选太高的，如果你已经安装了一部分或全部，而且版本很高或很低，这样也不必太担心（大不了删掉重新安装，哈哈），下面是我的一些经验，希望帮到你。\ngit的安装 这部分没有太多可讲的，网上有很多的教程，讲的也很好，这里需要你记住的一条命令是：\ngit clone \u003c远程仓库地址\u003e \u003c本地存放目录\u003e\r这里举个例子，就比如这次比赛用到的这个项目,我们建一个文件夹装要下载的项目，比如是mdp文件夹，然后右键，win11选显示更多，在弹出的选项选择： git bash here\n然后复制下面的内容回车就可以了。\ngit clone https://gitee.com/maimengcloud/mdp-lcode-ui-web.git mdp-lcode-ui-web/\n但是有的时候也会因为网速的问题，导致无法下载，比如回车后报错，如下:\nCloning into ‘mdp-lcode-ui-web’… fatal: unable to access ‘https://gitee.com/maimengcloud/mdp-lcode-ui-web.git/': Failed to connect to 127.0.0.1 port 26501 after 2017 ms: Couldn’t connect to server\n简单翻译理解就是这个远程仓库无法访问，其实这也是使用让我比较烦恼的问题，这里的原因我可能没办法给你讲清楚（你有时间可以去琢磨哈），但有个软件可以分享给你，帮你解决这个问题，即 watt toolkit ,而且这个软件在微软软件商城就有。\n下载后选github，然后点击一键加速。\n然我们再回到git base here，再次输入刚才的命令回车，\n发现刚才的代码仓库已经下载到本地了。\n如果你使用上面的软件还是无法下载远程的仓库，那你需要根据报错信息在网上查考相关的信息，这里提供上面报错的可能解决方案，只是针对上面的问题哦！参照文章\n安装node 网上可能称为nodejs都是一个工具，这个工具的简介还请参照官方，这里我们有做过多的了解哦。在安装node之前我们要先安装nvm。这是一个管理node的工具，这里安装的主要目的是 升高或降低node版本，简单就是想安装哪个版本（已发布且可下载的版本）的可以用这个工具来实现。\nnvm是否要安装取决于你的情况，除了nvm，此次项目还需要安装工具node，vue，mvn。\n方案一：为防止版本过高过低影响运行，以后可能还需要，最好是下载nvm管理node，然后也要了解升级或降低vue版本的方法，最后下载mvn；\n方案二：自己不管安装还是没安装，直接安装node，vue，mvn，本次项目用到的node，vue，mvn都在package.json文件里定义写好了，运行后会根据里面去下载，似乎对项目没太大影响（因为我工具处于最高版本，或是相对低一点的版本，使用相同的命令，报错都是一个，基于这点你可以尝试。）\n方案一 安装nvm 参照文档 关于文章的几点说明：\n登录github的时候记得开watt toolket; 如果nvm下载不了要刷新或者退出重新进入，多试几次； 基于本次的项目我们只看文章的一——四，五往后有时间就了解一下就好了； 里面的 三、配置路径和下载源我们需要把淘宝镜像改为如下：\nnode_mirror: https://cdn.npmmirror.com/binaries/node/ npm_mirror: https://cdn.npmmirror.com/binaries/npm/\r这是因为淘宝的镜像换了。\n接着参照文章，目的是node还要做一些配置，主要node的环境变量设置，还有目录node_cache和目录node_global的一些设置。从文章的下图开始看，关于node的下载就不看了。 注意在设置目录node_cache和目录node_global时，\nnpm config set prefix “\u003c自己的文件目录\u003e\\node_global” npm config set cache “\u003c自己的文件目录\u003e\\node_cache”\n这两个路径时要记得把它改成自己安装的路径：\n安装指定的vue版本 情况一：你没安装过vue 首先你要先安装好node，然后用node的npm工具安装vue。\n使用命令查看可安装版本：\n要查看的vue版本是1.x和2.x的\nnpm view vue-cli versions --json\r要查看的vue版本是3.x的\nnpm view @vue/cli versions --json\r安装vue指定的版本：\n安装的vue版本是1.x和2.x的\nnpm install -g @vue/cli@版本号 yarn global add @vue/cli@版本号\r要查看的vue版本是3.x的\nnpm install -g vue-cli@版本号 yarn global add vue-cli@版本号\r第一次安装要去配环境变量。\n情况二：你安装过vue 卸载已经安装的Vue Cli\n卸载 3.x 或 4.x 版本的Vue Cli\nnpm uninstall -g @vue/cli yarn global remove @vue/cli\r卸载 1.x 或 2.x 版本的Vue Cli\nnpm uninstall vue-cli -g yarn global remove vue-cli\r重复情况一的步骤，然后打开cmd，输入：\nvue -V\r显示安装的版本则说明安装完成。\n原文章链接\n安装mvn（Maven）工具 直接参照这个文章就好了。\n方案二 安装node和vue 参照文章，同样的里面涉及到镜像文件的设置要注意换掉：\nnode_mirror: https://cdn.npmmirror.com/binaries/node/ npm_mirror: https://cdn.npmmirror.com/binaries/npm/\r除此之外在设置目录node_cache和目录node_global这两个路径时要记得把它改成自己安装的路径：\nnpm config set prefix “\u003c自己的文件目录\u003e\\node_global” npm config set cache “\u003c自己的文件目录\u003e\\node_cache”\n安装mvn 直接参照这个文章就好了。\n至此工具就就安装完了，接着我们就要去启动项目了。\n本地启动项目 本次使用的系统是win11和code应用程序，如果你用的不是这个系统和应用程序情况可能不一样哈。\n根据项目的简介开始运行项目 这里我使用的是code应用程序（你如果用的是别的应用程序另说咯），点击文件夹用code打开后，根据项目文档执行命令：\nnpm install\r结果…………………………报错啦（我就知道没这么简单）！！！错误如下：\n上面的报错意思是：在尝试安装项目依赖时，npm遇到了依赖冲突问题。具体来说，babel-loader需要webpack的版本在2、3或4之间，但是你的项目中已经安装了webpack的5.90.1版本。这导致了peer依赖冲突，因为babel-loader期望的webpack版本与实际安装的版本不匹配，\n解决办法如下：\n1.查看自己的node版本；\n``` node -v ``` 2.修改\"package.json\"，在\"devDependencies\"中增加\"node\": “^21.6.1\"依赖；\n``` \"node\":\"^21.6.1\", ``` 3.npm install -s node-sass@4.14.1;\n4.npm install –save –legacy-peer-deps;\n结果……………………报错啦！！！！！ 修改\"package.json\"，原来的改为\"node\": \"^13.14.0\"依赖； 再次运行结果没报错。 5.npm install –registry=https://cdn.npmmirror.com\n接着我们运行如下代码 `npm install --registry=https://cdn.npmmirror.com` 6.npm run dev\n运行npm run dev，结果还是报错了…… 这里的错误说vue-template-compiler的版本为2.7.16，那我们就去\"package.json\"找到vue， 原来的vue版本： 把上面的修改为`\"vue\":\"^2.7.16\",` 这时候要重新运行 `npm install --save --legacy-peer-deps`,然后再次运行 `npm run dev`; 结果还是报错，如下： 大概意思是没有找到ajv这个包，那么我们在\"package.json\"里的 **\"dependencies\"** 添加`\"ajv\": \"^8.12.0\",` 然后重复`npm install --save --legacy-peer-deps`, `npm run dev`操作就可以了。 显示如下： 我们再看看页面，页面如下： 到这里说明没问题了。 从上面我们可以了解到一点，自己安装的版本似乎并不会影响项目的运行，所以选择方案二来进行安装似乎更简单，但从往长远的看方案一更更好，他可以随时换版本，更为方便。\n原文章链接",
    "description": "比赛题目 一、项目主题 知识产权流程管理系统\n二、项目描述\n该系统用于知识产权项目申报的全过程跟踪管理，其功能包括：\n客户下单、 提交申请、 申请反馈、 订单查询、 订单详情、 文档查阅下载等六大部分。 该系统分为客户端和管理端两个子系统。客户端对客户开放，主要功能包括：",
    "tags": [
      "前端",
      "后端"
    ],
    "title": "唛盟杯比赛详记",
    "uri": "/projects/%E5%94%9B%E7%9B%9F%E6%9D%AF%E9%A1%B9%E7%9B%AE%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "拥有一个属于自己的服务器个人感觉就很赞，我最初是在不买公网IP情况下，用一台电脑做服务器，然后另外一台电脑可以远程访问，部署网站，然后别人可以访问这个网站，这样一个功能。如果你也有这样的想法还请阅读下去，希望自己的经验对你有所帮助。\n所需设备 一台旧电脑，一台目前在使用的电脑。\n在旧电脑上安装natapp程序 在百度上搜索NATAPP，或点击这个链接:NATAPP,\n进入网站后先简单注册一下用户,顺便实名认证一下，因为买隧道会提示需要实名，接着点击首页下载自己的电脑系统对应版本，我的是Windows（下面的测试也是基于Windows）\n下载好后解压文件，得到如下图程序：\n在解压文件下新建一个文件： config.ini,做好这一步后我们去购买免费的隧道，如下图：\n点击网站的文档，然后点击教程/文档里的 使用本地配置文件config.ini 文章，\n然后复制里面的配置信息：\n#将本文件放置于natapp同级目录 程序将读取 [default] 段 #在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置 #命令行参数 -config= 可以指定任意config.ini文件 [default] authtoken= #对应一条隧道的authtoken clienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空, log=none #log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为none loglevel=ERROR #日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUG http_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空\r在字段authtoken后面值在我的隧道配置里可以找到，如下：\n复制下图authtoken的值填到config.ini文件里\n我这边演示的效果如下：\n完成上面的操作后，我们运行NATAPP程序，结果如下：\n你会得到一个随机的网址，这个网址指向你的本地端口，当你有网站挂载到本地端口时，你就可以通过网址访问到你的本地端口网址，内网外网都可以，但是这个网址每一次运行都会不一样，这点需要注意，然后就是端口的设置，看下图：\n我这里写的的端口是1313，如果你网站运行后不在1313，例如你运行网站后，本地的网站启动端口是8080.那你就把这个地方的1313改为8080就可以了。\n下面我们举个例子看看，假设我现在我需要外网的网友访问我挂在在自己电脑本地的网站，那们在做好上面的操作后我先去启动自己的网站，这里使用hugo的网站模版，用code程序打开网站模版，然后调出终端，在终端输入命令 hugo server ,表示启动网站，如下图：\n然后去复制刚才运行NATAPP程序后的网站，在浏览器中打开，我们先试一下局域网能不能访问，结果如下：\n将网站发给自己的朋友，测试外网是否可以访问，\n结果是外网可以正常可以访问。\n那么到这里你的电脑其实就充当了一台服务器，将网站放到了你电脑上，只要你的电脑保持开机状态那么别人就可以一直访问你的网站，或许NATAPP网站还有别的有趣功能，所以你不妨去摸索摸索，所不定可以找到多次启动NATAPP指向你本地的网址不变，你也就不用每次启动后都要发新的网址给对方了。\n那么其实到这里就差不多了，但是我们还需要用一台电脑控制另一台电脑，简而言之就是电脑的远程登录，其实电脑远程登录有许多的方法，这里我需要借助一个来实现内网穿透，其实上面的旧电脑变服务器也是使用了内网穿透， 附件",
    "description": "拥有一个属于自己的服务器个人感觉就很赞，我最初是在不买公网IP情况下，用一台电脑做服务器，然后另外一台电脑可以远程访问，部署网站，然后别人可以访问这个网站，这样一个功能。如果你也有这样的想法还请阅读下去，希望自己的经验对你有所帮助。",
    "tags": [
      "前端",
      "网络",
      "网站"
    ],
    "title": "8.如何用旧电脑搭建自己的服务器？",
    "uri": "/log/8.%E5%A6%82%E4%BD%95%E7%94%A8%E6%97%A7%E7%94%B5%E8%84%91%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 技术分享",
    "uri": "/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 网络",
    "uri": "/tags/%E7%BD%91%E7%BB%9C/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 网站",
    "uri": "/tags/%E7%BD%91%E7%AB%99/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: F1-复习资料",
    "uri": "/categories/f1-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r操作系统",
    "content": "认识Linux 安装Linux 图形界面与命令行 文件管理与常用命令 文件/目录的打包和压缩 gzip压缩文件和gunzip、zcat压缩文件命令 一般压缩解压文件： ​\r命令\rgzip [文件名]\rgunzip [解压文件名]\r例子：\n[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# gzip hello.txt\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt.gz\r[root@localhost stdio]# gunzip hello.txt.gz [root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# 如果不想删除源文件要怎么做呢？使用如下命令： ​\r命令\rgzip -c [文件名] \u003e [压缩文件名.gz]\rzcat [解压文件名.gz] \u003e[压缩文件名.gz]\r例子：\n[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# gzip -c hello.txt \u003ehello.txt.gz\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt hello.txt.gz\r[root@localhost stdio]# zcat hello.txt.gz \u003ehe.txt\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt hello.txt.gz he.txt\r[root@localhost stdio]# 在上面的命令中，zcat [解压文件名.gz] \u003e[压缩文件名.gz] 与 gunzip -c [解压文件名.gz] \u003e[压缩文件名.gz] 作用一样，另外，zcat [文件名]会将文件压缩信息输出在窗口上，即输出在 std。\nbzip2压缩文件和bunzip2压缩文件命令 一般压缩解压文件： ​\r命令\rbzip2 [文件名]\rbunzip2 [解压文件名]\r//压缩解压后不会删除原文件\rbzip2 -k [文件名]\rbunzip2 -k [解压文件名]\r例子：\n[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# bzip2 hello.txt [root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt.bz2\r[root@localhost stdio]# bunzip2 hello.txt.bz2 [root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt\r[root@localhost stdio]# bzip2 -k hello.txt [root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt hello.txt.bz2\r[root@localhost stdio]# rm hello.txt\rrm：是否删除普通文件 \"hello.txt\"？y\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt.bz2\r[root@localhost stdio]# bunzip2 -k hello.txt.bz2\r[root@localhost stdio]# ls\r1.c 2.c 3.c hello.txt hello.txt.bz2\r[root@localhost stdio]# tar归档文件命令 ​\r命令\r在Linux系统中，tar 是一个非常重要的归档工具，用于将一组文件和目录打包到一个单一的.tar文件中。它创建的这种归档文件并不进行压缩，仅仅是将多个文件集合在一起，并保持原始文件的权限、所有权和其他元数据信息。\ntar -cvf [文件名]\rtar -xvf [解压文件名]\r然而，为了减少存储空间占用以及在网络上传输时加快速度，通常会结合使用 tar 和压缩工具（如gzip或bzip2）对归档文件进行压缩。这里 -z 或 -j 参数的作用就是启用压缩功能\ntar -czvf [文件名]\rtar -xzvf [解压文件名]\rtar -cjvf [文件名]\rtar -xjvf [解压文件名]\r如果要选择性的归档或压缩、解压某个文件或目录，那么需要加 w，如下：\ntar -cwzvf [文件名]\rtar -xwzvf [解压文件名]\rtar -cwjvf [文件名]\rtar -xwjvf [解压文件名]\r在命令中;\nc（create）：表示创建新备份 z（gzip或gunzip）:表示使用gzip指令处理文件 v（verbose）：显示指令执行过程 f（file）:指定备份文件 w(interactive):对每一步都进行确认 j:表示使用bzip2、bunzip2指令进行压缩解压 如果加选项 -C （directory），则说明转到指定的目录，命令如下：\n[root@localhost ~]# tar -cjvf stdio.tar stdio/\rstdio/\rstdio/1.c\r[root@localhost ~]# tar -xjvf stdio.tar -C st/\rstdio/\rstdio/1.c\r[root@localhost ~]# cd st/\r[root@localhost st]# ls\rstdio\r[root@localhost st]# ls stdio/\r1.c\r[root@localhost st]# 用户与用户组管理 用户与组文件 用户文件-passwd 存放用户登录用户信息的文件位置：/etc/passwd 文件中域的的格式：\nusername:passwd:uid:gid:userinfo:home:shell:\n例子：\n[root@localhost st]# tail -1 /etc/passwd daliu:x:1008:1006::/home/daliu:/bin/bash\n/etc/passwdw 文件中域的含义\n域 含义 username 用户名 password 登录密码（一般显示的是密码转换后的乱码） uid 用户ID（0-99一般为系统保留） gid 用户组ID userinfo 用户信息 home 分配该用户的主目录（但位置是人为决定的，自己可以修改） shell 登录后启动的shell 一般root用户的UID为0，UID一般是唯一的为的是区分不同的用户，但UID为0的除外，UID为0则说明为超级用户；\n创建用户时，系统会分配一个主目录给用户一般在 home 目录下，例如用户user主目录为 /home/user。\n用户文件-shadow Linux系统中的/etc/shadow文件是存放用户密码信息的重要安全文件，也称为“影子口令文件”。它的主要作用是存储用户的加密密码以及与密码相关的属性，以增强系统的安全性。\n在早期的Unix/Linux系统中，密码是以明文或简单加密的形式存储在/etc/passwd文件中。为了提高系统的安全性，从1970年代末期开始引入了影子口令的概念，将密码字段从/etc/passwd移出，并存放在只有超级用户（root）可以读取的/etc/shadow文件中，而原来的 /etc/passwd 中的密码字段显示 x ,这就是上面的例子中显示x的原因。\n通过这种方式，即使攻击者获取了/etc/shadow文件，由于密码已经被高度加密，直接破解难度大大增加，从而有效提高了系统的密码安全级别。同时，通过对密码策略的设定，还可以实现对用户密码复杂度和有效期的管理。\n域 含义 username password min max warm inactive expire flag 下面就举个例子：\n[root@localhost st]# tail -1 /etc/passwd daliu:x:1008:1006::/home/daliu:/bin/bash\n[root@localhost st]# tail -1 /etc/shadow daliu:$6$f703Izgm$gIA74I6Vyqdjstz3BazhvEUVWfSyelNuv7UKTUtB3cScauSctebqrBIr/KShHnBcWWQideao3aucMrXsO.I6Z/:19694:0:99999:7:::\n用户组文件-group 用户组一方面是为了查找用户时更方便，比如查找user用户，你不需要去passwd文件一行一行的查找，你只需要去group文件找到对应的用户组即可。\n同样的，用户组也有类似passwd、shadow之和这样的文件，分别为group、gshadow.\n/etc/group 文件中域的含义如下：\n域 含义 group_name 组用户名 group_password 加密后的用户组口令 group_id 用户组ID group_members 以逗号隔开的用户清单 /etc/gshadow 文件中域的含义如下：\n域 含义 group_name 组用户名 group_password 加密后的用户组口令 group_members 以逗号隔开的用户清单 检验用户与用户组文件之间是否正确 检验 /etc/passwd 与 /etc/shadow 文件之间的正确性，使用命令 pwck,当发生错误，两个文件之间信息不对应时，系统会提示对相应项进行修改； 检验 /etc/group 与 /etc/gshadow 文件之间的正确性，使用命令 grpck,当发生错误，两个文件之间信息不对应时，系统会提示对相应项进行修改。 相关的命令操作 1.添加用户与用户组———— useradd \u0026 groupadd\n用法：\nuseradd [选项] 登录 useradd -D useradd -D [选项] 值得注意的是，对于选项的-d、-md，加了m表示在/home目录创建用户目录，如果不加，表示该目录已存在不需要再使用m,详细请结合下面的展开内容来开。 展开\r选项：\r-b, --base-dir BASE_DIR\t新账户的主目录的基目录\r-c, --comment COMMENT 新账户的 GECOS 字段\r-d, --home-dir HOME_DIR 新账户的主目录\r-D, --defaults\t显示或更改默认的 useradd 配置\r-e, --expiredate EXPIRE_DATE 新账户的过期日期\r-f, --inactive INACTIVE 新账户的密码不活动期\r-g, --gid GROUP\t新账户主组的名称或 ID\r-G, --groups GROUPS\t新账户的附加组列表\r-h, --help 显示此帮助信息并推出\r-k, --skel SKEL_DIR\t使用此目录作为骨架目录\r-K, --key KEY=VALUE 不使用 /etc/login.defs 中的默认值\r-l, --no-log-init\t不要将此用户添加到最近登录和登录失败数据库\r-m, --create-home\t创建用户的主目录\r-M, --no-create-home\t不创建用户的主目录\r-N, --no-user-group\t不创建同名的组\r-o, --non-unique\t允许使用重复的 UID 创建用户\r-p, --password PASSWORD\t加密后的新账户密码\r-r, --system 创建一个系统账户\r-R, --root CHROOT_DIR chroot 到的目录\r-s, --shell SHELL\t新账户的登录 shell\r-u, --uid UID\t新账户的用户 ID\r-U, --user-group\t创建与用户同名的组\r-Z, --selinux-user SEUSER\t为 SELinux 用户映射使用指定 SEUSER\r用法： groupadd [选项] [组名] ，一般会用到的选项有\n-g: 用户设置组ID； -o: 与-g配合使用，设置不唯一的组ID; -n: 修改组的名字，如：gpasswd -n [新组名] [旧组名] 2.删除用户与用户组———— userdel \u0026 groupdel\nuserdel:一般用法就是在后面加要删除的用户，如果加选项-r则会删除主目录文件； groupdel：在后面加要删除的用户组 3.修改用户与用户组———— usermod 、passwd \u0026 gpasswd\nusermod： 一般就是对问文件中的域进行修改，会加加上选项-u、-g、-s等，最后还得指定用户，用法： usermod [选项] [用户名]。另外，-L（-U） 的作用是对用户的锁定（解锁）； passwd：一般就是用来修改用户的密码，在登录的是root用户情况下passwd是要指定修改密码的用户的，而如果登录的是用户本身，使用passwd时就不用指定在； gpasswd： 用法： gpasswd [选项] [组名] ，一般会用到的选项有 -a(添加组的用户)， -d(删除组里的用户)，gpasswd -d [用户名] [组名] -A(添加组的管理员). -g(修改组GID),例如：gpasswd -g [新ID] [组名] 对于usermod的进一步说明，除了上面提到的选项，还有如下选项：\n展开\r选项：\r-c, --comment 注释 GECOS 字段的新值\r-d, --home HOME_DIR 用户的新主目录\r-e, --expiredate EXPIRE_DATE 设定帐户过期的日期为 EXPIRE_DATE\r-f, --inactive INACTIVE 过期 INACTIVE 天数后，设定密码为失效状态\r-g, --gid GROUP 强制使用 GROUP 为新主组\r-G, --groups GROUPS 新的附加组列表 GROUPS\r-a, --append GROUP 将用户追加至上边 -G 中提到的附加组中，\r并不从其它组中删除此用户\r-h, --help 显示此帮助信息并推出\r-l, --login LOGIN 新的登录名称\r-L, --lock 锁定用户帐号\r-m, --move-home 将家目录内容移至新位置 (仅于 -d 一起使用)\r-o, --non-unique 允许使用重复的(非唯一的) UID\r-p, --password PASSWORD 将加密过的密码 (PASSWORD) 设为新密码\r-R, --root CHROOT_DIR chroot 到的目录\r-s, --shell SHELL 该用户帐号的新登录 shell\r-u, --uid UID 用户帐号的新 UID\r-U, --unlock 解锁用户帐号\r-Z, --selinux-user SEUSER 用户账户的新 SELinux 用户映射\r3.登录用户与用户组———— su newgrp\nroot用户与普通用户之间的切换使用su,如果要切换根目录则需要在su 后加-，即： su - [用户]。\n在Linux中，组的登录使用 newgrp ，即 newgrp [组名]。\n下面通过一个例子加以理解：\n添加一个用户名为15user，且该用户在用户组15group中，设置用户组和用户密码为123，创建一个用户15user2让该用户为用户组管理员,修改user的UID为2024，最后删除所用所建信息。\n展开\r[root@localhost ~]# groupadd 15group\r[root@localhost ~]# useradd -g 15group 15user\r[root@localhost ~]# tail -1 /etc/passwd\r15user:x:1001:1007::/home/15user:/bin/bash\r[root@localhost ~]# tail -1 /etc/group\r15group:x:1007:\r[root@localhost ~]# gpasswd 15group\r正在修改 15group 组的密码\r新密码：\r请重新输入新密码：\r[root@localhost ~]# passwd 15user\r更改用户 15user 的密码 。\r新的 密码：\r无效的密码： 密码少于 8 个字符\r重新输入新的 密码：\rpasswd：所有的身份验证令牌已经成功更新。\r[root@localhost ~]# useradd 15user2\r[root@localhost ~]# gpasswd -A 15user2 15group\r[root@localhost ~]# tail -2 /etc/group\r15group:x:1007:\r15user2:x:1002:\r[root@localhost ~]# tail -2 /etc/gshadow\r15group:$6$d4pzl/CPrp$3NYvX8gzE3DBm35BLqAE8aGzfUhrUZTSMGQfeRve2iUhrH1tZGR8I8t91gWzFD2GWFEDaaocO7XO85RjKDY.q1:15user2:\r15user2:!::\r[root@localhost ~]# usermod -u 2024 15user\r[root@localhost ~]# tail -2 /etc/passwd\r15user:x:2024:1007::/home/15user:/bin/bash\r15user2:x:1002:1002::/home/15user2:/bin/bash\r[root@localhost ~]# userdel 15user\r[root@localhost ~]# groupdel 15group\r[root@localhost ~]# userdel 15user2\r在上面的例子中，我们使用gpasswd -A来设置用户组管理员。\n文件目录和目录权限管理 文件访问权限与用户分类 文件的访问权限 读(r)：允许读文件的内容 写(w)：允许向文件中写入数据 执行(x)：允许将文件作为程序执行 目录的访问权限 读(r)：允许查看目录中有哪些文件和目录； 写(w)：允许该在目录下创建（或删除）文件、目录，修改文件名字或者目录名字 执行(x)：允许访问目录(用 cd 命令进入该目录，并查看目录中可读文件的内容) 用户分类 文件所有者（owner）：建立文件、目录的用户。 同组用户(group)：属于同一组群的用户对属于该组群的文件有相同的访问权限。 其他用户(other)：除了文件所有者、同组用户的其他用户。 我们先用ls -l 查看文件的权限信息：\n在上面的开头有三段他们分别表示为文件所有者、同组用户、其他用户：\n其中的d表示目录。\n权限修改 访问权限的表示 （1）字母表示法（如：rwxr-xr-x） （2）数字表示法 （如：755） 使用数字进行文件权限的划分，其中r=4、w=2、x=1、-=0，这样rwx这组权限就是4+2+1=7，r-x这组权限就是5。\n修改权限的命令：chmod 命令格式1： chmod $n{_1}n{_2}n{_3}$ \u003c文件|目录\u003e 功能：为指定文件或目录修改给定的数值访问权限。 选项：$n{_1}n{_2}n{_3}$三位数字表示的文件访问权限。 命令格式2： chmod [用户标识] [设定方法] [权限字符] \u003c文件名或目录名〉 功能：修改文件或目录的访问权限。 选项： （1）用户标识：所有者（u）、同组（g）、其他人（o）、所有的人员（a） （2）设定方法：+ 增加权限、- 删除权限、= 分配权限，同时删除旧的权限 （3）权限字符：r（读）、w（写）、x（执行）、u（和所有者的权限相同）、g（和所同组用户的权限相同）、o（和其他用户的权限相同） 修改文件所有者的命令：chown 格式：chown [-R] \u003c用户[：组]\u003e \u003c文件或目录\u003e 功能：更改属主和组。 选项： -R：对目录及其子目录进行递归设置。 例如：chown sjh：sjh result.txt\n修改文件所属组群的命令：chgrp 格式：chgrp group file\n其中group：组名或组代号\n功能： 改变文件或目录组群\n例如：chgrp user result.txt\n关于chown与chgrp的命令的例子：\n展开\r[root@localhost ~]# chown user2:user2 /tmp/test/user1_2.txt\r[root@localhost ~]# ls -l /tmp/test/\r总用量 0\r-rw-rw-r--. 1 user2 user2 0 1月 15 19:40 user1_2.txt\r[root@localhost ~]# chgrp root /tmp/test/user1_2.txt\r[root@localhost ~]# ls -l /tmp/test/\r总用量 0\r-rw-rw-r--. 1 user2 root 0 1月 15 19:40 user1_2.txt\r[root@localhost ~]# 修改默认权限的命令：umask 格式：umask [mask]\n功能：设置文件或目录的默认权限\n注意：系统默认屏蔽的权限为022（umask的默认值为0022），因此新 创建的目录权限就为777-022=755，用字符表示就是rwxr-xr-x，新创 建的普通文件权限为666-022=644，即rw–r–r–。\n文件隐藏属性 1）查看文件隐藏属性：lsattr\n2）修改文件隐藏属性：chattr\nchattr [+-=] [ ai] 文件或目录名称\na: 当设置a之后，这个文件将只能增加数据，而不能删除也不能修改数据， 必须要为root才能设置这个属性。 i：不能删除，不能修改，不能改名。必须要为root才能设置这个属性。 文件特殊权限 文件特殊权限有以下三种：\n1）SUID：Set UID（只对二进制程序有效，对shell script无效）\n例如：ll /usr/bin/passwd\n注意：当用户执行passwd命令的时候，需要修改/etc/shadow文件，而该文件普通用户并没有任何权限。\n2）SGID：Set GID\n例如：ll /usr/bin/locate 注意：当用户执行locate命令的时候，需要读取/var/lib/mlocate/mlocate.db文件。\n3）SBIT：Sticky Bit （只对目录有效）\n设置方法：\nchmod -o+t [指定目录名]\r或者\rchmod 1777 [指定目录名]\r对一个目录进行如上设置以后，假设有用户A和B，用户A在该目录下创建的文件只有他自己的root用户可以删，像B这样的其他用户删不了。\n特殊文件说明文章链接\n软件包管理 接下里介绍两个软件安装的工具，分别是RPM：Red Hat Package Manager（Red Hat软件包管，以及YUM:Yellow dog Dpdater,Modified.\nRPM工具不需要网络，需要提前准备好安装包，但是他也有缺点安装的时候如果缺少依赖包你还需要再安装依赖包；\n而YUM工具需要再有网的状态下才可以下载，它免去了依赖包提醒，自动将依赖包下载好，较为方便，我跟推荐使用YUM。\nRPM工具的使用 1．安装软件包（install）\nrpm -ivh rpm软件包全名：\ni：安装一个新的软件包 v：显示详细信息 h：显示安装进度条理工具 2．查询已安装的软件包（query）\nrpm –qa //查询出本机所有已经安装的软件\rrpm –q httpd //查询httpd软件包是否已经安装\rrpm -q【i l c d R】 vsftpd\rrpm -qf /etc/inittab\r查询未安装的软件包：\rrpm -qp 【i l c d R】 gconf-editor-2.28.0-3.el6.i686.rpm\r3．升级与更新（upgrade/freshen）\nrpm -Uvh 软件包名称\r//原来没有安装过的，直接安装；如果已安装过，则更新至新版\rrpm -Fvh 软件包名称\r//原来没有安装过的，不安装；如果已安装过，则更新至新版\r4．卸载RPM包（erase）\nrpm -e vsftpd\r注意：卸载时只需要给出软件包名称vsftpd，而不需要给出软件包的全部名称信息vsftpd-2.2.2-6.el6.i686.rpm。\rYUM工具的使用 yum在线升级机制：\n安装软件 yum install gcc 删除软件 yum remove gcc 查询软件 yum search gcc 软件包管理：\n举例一：搜寻与磁盘阵列(raid)相关的软件有哪些？ [root@www ~]# yum search raid 举例二：找出mdadm这个软件的功能为何？ [root@www ~]# yum info mdadm 举例三：列出yum 服务器上面提供的所有软件名称。 [root@www ~]# yum list 举例四：列出目前服务器上可供本机进行升级的软件有哪些？ [root@www ~]# yum list updates 举例五：列出提供passwd这个文件的软件有哪些？ [root@www ~]# yum provides passwd yum的软件组功能：\n查询软件组：yum grouplist（查阅目前容器与本机上面的可用与安装过 的软件群组有哪些？） yum groupinfo Eclipse（查询Eclipse软件组的相关信息）\n安装软件组： yum groupinstall Eclipse 删除软件组： yum groupremove Eclipse 硬盘分区及格式化 硬盘分区介绍 硬盘的分区分为主磁盘分区和扩展磁盘分区。 一个硬盘最多可以划分为 4 个主磁盘分区，这时不能再创建扩展分区。 一个硬盘中最多只能创建 1个扩展分区 ，扩展分区不能直接使用，必须在扩展分区中再划分出逻辑分区才可以使用。 逻辑分区是从5开始的，每多1个分区，数字加1就可以。 硬盘标识 （1）IDE硬盘：hd[a-d]*\nhd表示硬盘类型为IDE，中括号中的字母为a、b、c、d中的一个，a是基本盘，b是从盘，是辅助主盘，d是辅助从盘，*指分区，即主分区和扩展分区。\n例如：hda1代表第一块IDE硬盘上的第一个分区。hdb5代表第二块IDE硬盘的第一个逻辑分区。\n（2）SCSI/SATA硬盘：sd[a-p]*\nsd表示SCSI/SATA硬盘。SCSI/SATA的引导盘使用设备文件/dev/sda1、/dev/sda2、/dev/sda3、/dev/sda4作为主分区或者扩展分区，而以/dev/sda5，/dev/sda6等作为逻辑分区。\n创建硬盘分区 先使用ls -l /dev |grep ‘sd’查看文件里是否有可用的磁盘，如果没有需要创建一个磁盘，创建步骤：\n1．通过虚拟机设置增加一块SCSI硬盘，大小为5G，重启系统。 展开\r按照下图点击下一步\n根据实际情况输入所需硬盘大小，这里输入5GB\n然后点击完成\n最后在命令窗口输入reboot重启。\n2．将该硬盘分为2个主分区（每个主分区的大小为1G），1个扩展分区（大小为3G），将第2个主分区制作成swap分区。\n命令： 展开\r//先用命令查看sd,sd表示SCSI/SATA硬盘， ls /dev/sd |grep sd //硬盘分区 fdisk /dev/sdb //使用m查看帮助命令，n为新建命令，d为删除命令，w为写入命令，每次配完都要写入才有效。 n p //这是新建主分区的意思 //接着指定分区起始位置，一般我们默认，所以回车就可以 //然后就是指定分区的大小，这里我设置1G、 +1G //可以用p命令查看设置的情况 P //按照上面的流程进行其他的设置，一下给出步骤命令 n p +1G n e +3G\r3．将扩展分区划出2个逻辑分区（大小分别为1G、2G）。\n命令： 展开\r//到这步后我们可以给扩展分区分配逻辑分区，分配时逻辑分区用l命令。 n l +1G n l +2G\r查看磁盘情况与磁盘格式化 （1）查看系统中的新硬盘：ls /dev/sd* （2）查看分区：fdisk –l /dev/sda （3）创建主分区：fdisk /dev/sdc （4）创建扩展分区：输入n,再输入e （5）创建逻辑分区: 输入n,再输入l （6）修改分区类型 （7）格式化分区： mkfs –t ext4 /dev/sdc1 还可以写成**mkfs.ext4 /dev/sdc1** 格式化交换分区略有不同，使用命令 mkswap ,例如： mkswap dev/sdb2 （8）磁盘检查命令：fsck –t ext4 /dev/sdc1 badblocks /dev/sdb5 （9）查看磁盘使用情况 df,或使用df -h输出更易于查看。 上面的-t意思是参数TYPE的意思，后面接ext4()、vfat(FAT32)、ntfs()等，\n挂载文件系统：mount 1、 挂载硬盘分区： 步骤1：mkdir /usr/music 步骤2：mount /dev/sdc5 /usr/music 2、 挂载光驱： 步骤1：mkdir /mnt/cdrom 步骤2：mount /dev/cdrom /mnt/cdrom 3、 挂载U盘： 步骤1：mkdir /mnt/usb 步骤2：mount /dev/sdd1 /mnt/usb 4、 挂载Windows下的C盘 （FAT32格式）： 步骤1：mkdir /mnt/dosc 步骤2：mount -t vfat /dev/sda1 /mnt/dos 注意： C盘必须已经被格式化为FAT32格式。\n显示系统内所有已经挂载的文件系统 mount 不带任何参数执行mount命令，则会显示当前系统中已经挂载的所有的文件系统列表。\n卸载设备：umount 格式： umount \u003c设备名或挂载点\u003e\n说明：卸载指定的设备，既可以使用设备名也可以使用挂载点。\n举例： # umount /dev/cdrom\n自动挂载文件系统：/etc/fstab 每条记录由6个字段组成。\n1.设备名称 2.设备挂载点 3.文件系统类型 4.挂载选项 5.是否备份 6.自检顺序\n如果想要系统自动挂载/dev/sdc5分区，可在/etc/fstab文件添加下面这行：\n/dev/sdc5 /usr/music ext4 defaults 0 0\n注意:由于fstab文件非常重要，如果这个文件有错误，就可能会造成系统不能正常启动。因此向fstab文件中添加数据时应非常小心。修改完该文件后务必使用mount -a命令测试有没有错误。\n磁盘配额 以sdb1为例\n第一步：先配置sdb磁盘，然后挂载sdb1磁盘\n第二步：使用quotaon /sdb1/生成aquota.group和aquota.user文件\n第三步：对用户或用户组进行磁盘限制,例如：edquota -u user1，然后会进入一个文件，文件里的0表示禁用，在里面可以设置创建文件个数或文件大小的软限制、硬限制；\n第四步：我们登录user1，在/sdb/目录下创建文件，使用 db if=/dev/zero of=/sdb1/test/ bs=1k count=10这条命令进行测试，这是一个写文件大小的命令，这样可以快速测试文件大小的软限制和硬限制；\n第五步：子里面建文件，检验创建文件个数的软限制和硬限制；\n第六步: 可以使用repquota -u查看目录的情况；\n第七步：关闭磁盘匹配额，quotatoff /sdb1/\nLinux编程 附件",
    "description": "认识Linux 安装Linux 图形界面与命令行 文件管理与常用命令 文件/目录的打包和压缩 gzip压缩文件和gunzip、zcat压缩文件命令 一般压缩解压文件： ​\r命令\rgzip [文件名]\rgunzip [解压文件名]\r例子：",
    "tags": [
      "软硬件"
    ],
    "title": "Linux期末复习",
    "uri": "/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "Linux期末复习认识Linux 安装Linux 图形界面与命令行 文件管理与常用命令 文件/目录的打包和压缩 gzip压缩文件和gunzip、zcat压缩文件命令 一般压缩解压文件： ​\r命令\rgzip [文件名]\rgunzip [解压文件名]\r例子：",
    "description": "Linux期末复习认识Linux 安装Linux 图形界面与命令行 文件管理与常用命令 文件/目录的打包和压缩 gzip压缩文件和gunzip、zcat压缩文件命令 一般压缩解压文件： ​\r命令\rgzip [文件名]\rgunzip [解压文件名]\r例子：",
    "tags": [
      "操作系统"
    ],
    "title": "操作系统",
    "uri": "/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 操作系统",
    "uri": "/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 软硬件",
    "uri": "/tags/%E8%BD%AF%E7%A1%AC%E4%BB%B6/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "AndroidStudio接下来将将介绍AndroidStudio的复习资料，包括AndroidStudio简介、AndroidStudio中 Make Project 、Clean Project 、Rebuild Project 的作用、Run窗口、manifests文件夹（清单文件夹）、java文件夹、res文件夹、Android系统体系结构四层等。\nAndroidStudio笔记这篇文章主要介绍AndroidStudio的使用，以及一些Android开发的基础知识。以及一些开发中遇到的问题和解决方法，除此之外，还会介绍一些开发中常用的工具和技巧。\n2-1.Toolbar工具栏本篇文章主要介绍**Toolbar**工具栏的使用，以及**menu**文件的使用",
    "description": "AndroidStudio接下来将将介绍AndroidStudio的复习资料，包括AndroidStudio简介、AndroidStudio中 Make Project 、Clean Project 、Rebuild Project 的作用、Run窗口、manifests文件夹（清单文件夹）、java文件夹、res文件夹、Android系统体系结构四层等。",
    "tags": [
      "AndroidStudio"
    ],
    "title": "AndroidStudio",
    "uri": "/class/2.androidstudio/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \rAndroidStudio",
    "content": "接下来将将介绍AndroidStudio的复习资料，包括AndroidStudio简介、AndroidStudio中 Make Project 、Clean Project 、Rebuild Project 的作用、Run窗口、manifests文件夹（清单文件夹）、java文件夹、res文件夹、Android系统体系结构四层等。\nAndroidStudio简介 Important 1.配置Android开发环境：\n安装JDK： （1）下载JDK （2）配置环境变量； 安装Android Studio； 安装SDK。 2.自动构建工具Gradle：\nGradle 是以 Groovy 语言为基础，面向Java应用为主，基于DSL（领域特定语言）语法的自动化构建工具。它可以自动化地进行软件构建、测试、发布、部署、软件打包，同时也可以完成项目相关功能，如生成静态网站、生成文档等。另外其集合了Ant的灵活性和强大功能，以及Maven的依赖管理和约定，从而创造了一个更有效的构建方式。凭借Groovy的DSL和创新打包方式，Gradle提供了一个可声明的方式，并在合理默认值的基础上描述所有类型的构建。Gradle目前已被选作许多开源项目的构建系统。\n3.Logcat日志输出工具：使用 Logcat 查看日志\nAndroid Studio 中的 Logcat 窗口会实时显示设备日志来帮助您调试应用，例如，使用 Log 类添加到应用的消息、在 Android 上运行的服务发出的消息或系统消息（例如在发生垃圾回收时）。如果应用抛出异常，Logcat 会显示一条消息，后跟相关联的堆栈轨迹，其中包含指向代码行的链接。\n4.Android Studio中 Make Project 、Clean Project 、Rebuild Project 的作用\nMake Project：编译Project下所有Module（组件或模块），一般是自上次编译后Project下有更新的文件，增量编译，不生成Apk。 Clean Project：删除之前编译后的编译文件。部分版本的AS会自动重新编译整个Project，不生成Apk。 Rebuild Project：先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成Apk 5.Run窗口：可以输出程序运行过程中出现的错误。 6.manifests文件夹（清单文件夹）：Android系统配置文件夹，包含一个AndroidManifest.xml文件（清单文件），可在此文件注册声明\n\u003cactivity\u003e页面、 \u003cservice\u003e服务、 \u003creceiver\u003e接收器、 \u003cprovider\u003e提供者或提供程序、 \u003cuses-permission\u003e使用权限等； 7.java文件夹：存放Java代码的文件夹，新建项目时默认生成了三个文件夹，com.first.project文件夹用来存放Java文件，这里包含一个名为MainActivity的Java文件，是新建项目时默认生成的。 第二个和第三个文件为测试代码文件夹，不是十分常用。\nres文件夹：存放Android项目的资源文件，包含四个文件夹： drawable（图片资源文件夹）、 layout（布局资源文件夹）、 mipmap（图片资源文件夹，存放项目图标）、 values（存放数值资源文件）， 此外有menu文件（菜单资源文件）。 8.Android系统体系结构四层，从上到下分别是\n应用程序层 应用程序框架层 系统运行库层 Linux内核层 每一层都是用其下面各层所提供的服务。 应用程序层\nAndroid平台包含了许多核心的应用程序，诸如Email客户端、SMS短消息程序、日历、地图、浏览器、联系人等应用程序。这些应用程序都是用Java语言编写的。开发人员可以灵活地根据需求替换这些自带的应用程序或者开发新的应用程序。\n应用程序框架\n开发者可以完全访问核心应用程序所使用的API框架。该层简化了组件的复用，使得开发人员可以直接使用系统提供的组件来进行快速地开发，也可以通过继承灵活地加以拓展。这些东西包括：\n活动管理器（Activity Manager，管理各个应用程序的生命周期以及通常的导航回退功能） 视图系统（View System，构建应用程序的基本组件） 内容提供器（ContentProvider，使得不同的应用程序之间可以存取或者分享数据） 资源管理器（Resource Manager，提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件等） 通知管理器（Notification Manager，使应用程序可以在状态栏中显示自定义的提示信息）等。\n系统运行库层\n包括系统库和Android Runtime，系统库是应用程序框架的支撑，是连接应用程序框架层与Linux内核层的重要纽带。程序在Android Runtime中执行，其运行时分为核心库和Dalvik虚拟机两部分。\nLinux内核层\nAndroid基于Linux2.6的内核，其核心系统服务如安全性、内存管理、进程管理、网络协议以及驱动模型都依赖于Linux内核，同时内核层也扮演了介于硬件层和软件栈之间的抽象层的角色。 Linux内核层和系统运行库层之间，从Linux操作系统的角度来看，是内核空间与用户空间的分界线，Linux层运行于内核空间，以上各层运行于用户空间。系统运行库层和应用框架层之间是本地代码层和Java代码层的接口。应用框架层和应用程序层是Android的系统API的接口，对于Android应用程序的开发，应用程序框架层以下的内容是不可见的，仅考虑系统API即可。\n9.四大核心组件有：activity（活动或页面）、service（服务）、broadcast receiver（广播接收器）、content provider（内容提供者）\n10.Activity介绍Android系统是通过任务栈来管理Activity的。当一个Activity启动时，会把Activity压入到堆栈中，当用户按返回键或者结束掉该Activity时，它会从堆栈中弹出。\n11.Android为我们定义了四种加载方式\nStandard 加载模式 ——标准模式/默认加载模式\n标准模式：系统默认的Activity启动模式，当Intent欲打开Activity时，在该Activity不存在，存在于栈顶和存在于栈底三种情况下都会正常创建Activity，并压入任务栈栈顶；\nSingleTop 加载模式 ——栈顶单例模式\n栈顶单例模式：当启动一个Activity时，只有当该activity存在任务栈中且为栈顶，Intent才会通过onNewIntent()方法传递给在栈顶Activity实例；其他情况则正常创建Activity并压入任务栈；\nSingleTask 加载模式 ——栈内单例模式\n站内单例模式：当启动一个Activity时，系统会先检查任务栈内是否有该Activity，如果该Activity不存在则正常创建Activity实例，如果存在且在栈底则会将它上面的Activity弹出并销毁，使该Activity置于栈顶再调用onNewIntent()方法；\nSingleInstence 加载模式 ——全局单例模式\n与SingleTask模式基本一样，只是在这个模式下Activity所处的任务栈中只能有Activity这一个实例，不能有其他的实例。\n12.Activity生命周期是指Activity从创建到销毁的过程，在这一过程中，Activity一般处于4种状态，即：Active/Running、Paused、Stop、Killed\n（1）Active/Running 此时Activity一定处于屏幕的最前端，用户完全可以看得到，并且可以与用户进行交互。对于Activity栈来说，它处于栈顶； （2）Paused 此时Activity在屏幕上仍然可见，但是它已经失去了焦点，用户不能与之进行交互。暂停状态的Activity是存活的，它仍然维持着其内部状态和信息，但是系统可能会在手机内存极低的情况下杀掉该Activity； （3）Stop 此时Activity在屏幕上完全不能被用户看见，也就是说这个Activity已经完全被其他Activity所遮住。处于停止状态的Activity，系统仍然保留有其内部状态和成员信息，但是它经常会由于手机系统内存被征用而被系统杀死回收； （4）Killed Activity被系统杀死回收或者未启动。\n13.为了能够让Android程序了解自身状态的变化，Android系统中具有很多事件回调函数，我们可以重载这些方法来实现自己的操作。Android生命周期的事件回调函数如下：\nvoid onCreate(Bundle savedInstanceState) void onStart() void onRestart() void onResume() void onPause() void onStop() void onDestroy()\r14.Activity生命周期\n15.Fragment必须是依存于Activity而存在，因此Activity的生命周期会直接影响到Fragment的生命周期。图在课本第50页。\n由图可以看到Fragment比Activity多了几个额外的生命周期回调函数：\nonAttach(Activity)：当Fragment与Activity发生关联时调用。从该方法开始，就可以通过Fragment.getActivity方法获取与Fragment关联的窗口对象了，但在该方法中仍然无法操作Fragment中的控件。 onCreateView(LayoutInflater, ViewGroup, Bundle)：创建该Fragment的视图。onActivityCreated(Bundle)：当Activity的onCreate方法返回时调用。\nonDestoryView():与onCreateView相对应，当该Fragment的视图被移除时调用。onDetach()：与onAttach相对应，当Fragment与Activity关联被取消时调用。\n16.在使用Intent进行Activity之间的跳转时，我们通常有三种Intent跳转方式，即：不带参数的跳转、带参数的跳转以及带返回值的跳转，代码实现可参考实验报告或书本。\n17.TextView常用的属性\nandroid:id=\"@+id/textView1\"表示该控件的id，在布局文件中或者代码中被引用 android:textStyle=\"bold\"表示TextView里面的字加粗显示 android:layout_height=\"wrap_content\"表示该控件的高度为其包含内容的高度 android:layout_width=\"wrap_content\"表示该控件的宽度为其包含内容的宽度 android:text=\"@string/signin\" 显示的内容，这里表示存放在string.xml文件中name=signin的文本 android:layout_height=\"40dip\"设置具体的高度 android:textColor=\"#7089c0\"设置文本的颜色 android:textSize=\"18sp\"设置文本的大小 android:gravity=\"center_vertical\"设置文本垂直居中 android:paddingLeft=\"5dip\"设置内边距 android:layout_marginTop=\"5dip\"设置外边距\r18.LinearLayout线性布局、\nRelativeLayout相对布局、 FrameLayout帧布局、 TableLayout表格布局、 AbsoluteLayout绝对布局 线性布局，是指该容器（LinearLayout）内子控件的摆放方式有两种： 第一种：垂直放置（VERTICAL），相对水平放置来讲，垂直放置就相当于一列，放置的控件或者容器只能在该列中的某个位置，两个控件之间只存在上下方向的关系，不存在其他方向上的关系。当这一列放满后，再添加的控件就至于屏幕之外存在，无法看见。 第二种：水平放置（HORIZONTAL），指的是该容器里面存放的控件或者容器只能以一行的形式出现，放置的控件只能是该行中的某个位置，两个控件或者容器之间只有左右关系没有其他方向上的关系，当放置水平方向满屏时不会自动换行，再放置的控件将在屏幕之外存在，无法看见。 在线性布局中重要的属性值对应表示\nandroid:orientation\t//设置控件或者容器存放的方式 android:id\t//设置控件id，方便在使用时找到其引用 android:layout_width\t//容器的宽度，该值必须设置 android:layout_height\t//容器的高度，该值必须设置 android:layout_weight\t//该属性针对其内的子控件，存放在LinearLayout中的控件都有这个属性，用来设置该控件或者容器占父控件或者容器的比例。\r相对布局，是指利用控件之间的相对位置关系来对布局进行放置。换句话说，在该容器中的控件与其他任何一个控件或者容器（包括父控件）有相对关系。\n帧布局，是指该容器内放置的控件或者容器没有上下左右的关系，只有层叠前后的关系。放置在容器内的控件按放置的前后顺序逐一层叠摆放，自然地后面摆放的控件就将前面摆放的控件覆盖了，叠在它的上面了。对于放置前后的关系，在没有设置其他属性之前，Android系统采用的是叠放的原则，即后加入节点的层叠在上面。设置属性android：bringToFront=“true|false”将前面放置的控件提到最前面可见。\n表格布局，指该容器是一个表格，放置控件时，控件的位置坐落在表格的某个位置上。其中TableRow是配合TableLayout使用的，目的是为了让TableLayout生成多个列，否则TableLayout中就只能存在一列元素，但可以有多行。\nTableLayout的直接父类是LinearLayout，所以其具有LinearLayout的属性，TableLayout中的每一行用TableRow表示，每一列就是TableRow中的个数指定的。TableRow的直接父类是LinearLayout，但是其放置的方式只能水平放置。\n绝对布局，是指以屏幕左上角为坐标原点（0,0），控件在容器中的位置以坐标的形式存在，可以随意指定控件的坐标位置，非常灵活。在开发过程中很少使用，原因是屏幕兼容性不好，不便控制两个控件之间的位置。其中控件或者容器放置的位置通过android:layout_x和android:layout_y这两个属性进行设置。\nConstraintLayout约束布局\n优点：\nConstraintLayout之所以成为目前Android开发中主流的布局，除了官方建议使用ConstraintLayout外还有以下几个方面的优势 1.功能强大，ConstraintLayout几乎能实现其他布局所有的功能 2.能减少布局层次的嵌套，有性能的优势 3.可视化操作的增强，大部分界面用ConstraintLayout都能通过可视化编辑区域完成\n19.对话框（Dialog）是Android系统在Activity或者其他组件运行过程中提供的一种资源消耗很小的提示机制，它可以帮助应用完成一些必要的提示功能，同时还提供一些用户交互的功能，包括简单的提示、等待、选择、展示等功能。操作简单，资源消耗较少。代码实现可参考实验报告或书本\n1提示对话框\npackage com.example.alertdialog; import android.content.DialogInterface; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; import androidx.annotation.Nullable; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; import java.util.ArrayList; import java.util.HashMap; public class MultipleChoiceDialogBox extends AppCompatActivity { private Button button; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.test); button = findViewById(R.id.dialog_box_up); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { AlertDialog.Builder builder = new AlertDialog.Builder(MultipleChoiceDialogBox.this); builder.setTitle(\"这是一个简单的弹窗\"); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(\"你学会了吗？\"); builder.setPositiveButton(\"学会了\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.setNegativeButton(\"不会\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.show(); } }); } }\r2单选对话框\npackage com.example.alertdialog; import android.content.DialogInterface; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; import androidx.annotation.Nullable; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; import java.util.ArrayList; import java.util.HashMap; public class MultipleChoiceDialogBox extends AppCompatActivity { private Button button; private TextView textView; private String sexx[] ={\"男\",\"女\"}; private int choiceWitch = 1; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.test); button = findViewById(R.id.dialog_box_up); textView=findViewById(R.id.show_dialog_box_text); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { AlertDialog.Builder builder = new AlertDialog.Builder(MultipleChoiceDialogBox.this); builder.setCancelable(false); builder.setSingleChoiceItems(sexx, -1, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { choiceWitch=which; } }); builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { textView.setText(sexx[choiceWitch]); } }); builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.show(); } }); } }\r3多选对话框\npackage com.example.gpc.wzxapplicationwu1; import android.content.DialogInterface; import android.os.Bundle; import android.support.annotation.Nullable; import android.support.v7.app.AlertDialog; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; import java.util.ArrayList; import java.util.HashMap; public class AlertDialogActivity extends AppCompatActivity{ private Button button; private TextView textView; private String sexx[] ={\"a\",\"b\",\"c\",\"d\"}; private boolean stu[] = {false,false,false,false}; private int choiceWitch = 1; private ArrayList\u003cInteger\u003e list = new ArrayList(); private String str = \"\"; private HashMap\u003cInteger,Integer\u003e map = new HashMap\u003c\u003e(); @Override protected void onCreate(@Nullable final Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.alert_dialog); textView = findViewById(R.id.alert_dialog_textview); button = findViewById(R.id.alert_dialog_button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { AlertDialog.Builder builder = new AlertDialog.Builder(AlertDialogActivity.this); builder.setMultiChoiceItems(sexx, stu, new DialogInterface.OnMultiChoiceClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i, boolean b) { if(b == true){ map.put(i,i); } else { map.remove(i); } } }); builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { for (Integer j : map.keySet()){ int z = map.get(j); str = str + sexx[z]; } textView.setText(str); str = \"\"; } }); builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.show(); } }); } }\r19.Android系统中的ContextMenu(上下文菜单)类似于PC中的右键弹出菜单，当一个视图注册了上下文菜单时，长按该视图对象将出现一个提供相关功能的浮动菜单。上下文菜单可以被注册到任何视图对象中，最常见的是用于列表视图中，但上下文菜单不支持图标和快捷键。\n选项菜单 当Activity在前台运行时，如果用户按下微信消息列表页面右上角加号键，此时就会在屏幕右上角弹出相应的选项菜单。但这个功能需要开发人员编程来实现，如果在开发应用程序时没有实现该功能，那么程序运行时按下手机的meun键是不会起作用的。\n下拉菜单 严格来讲Spinner不算是一个菜单，但是其操作和表现形式具有菜单的行为。Spinner的有效使用可以提高用户的体验。当用户需要选择的时候，可以提供一个下拉列表将所有可选的项列出来，供用户选择。\n21.Toast（提示）的使用，代码实现可参考实验报告或书本。\nToast.makeText(MultipleChoiceDialogBox.this,“nihao”,Toast.LENGTH_LONG).show();\n22.Notification表示通知，是可以显示在Android系统通知栏上的一种数据的封装形，运用Notification可以提高应用的交互性，带来良好的用户感受。 关于Notification，主要涉及到Notification类与NotificationManager类的使用。 Notification类的实例表示在通知栏显示的一个通知，该通知内容包括该通知的ID、时间、内容、标题、图标等。 NotificationManager实例用来将该通知发送到系统的通知栏上。\n23.本地服务（Local Service）用于应用程序内部，可以实现应用程序自己的一些耗时任务，比如查询升级信息、网络传输，或者在一些场合需要在后台执行，比如播放音乐，并不占用应用程序比如Activity所属的线程，而是单开线程后台执行，这样用户体验比较好。\nService的两种启动方式 (1)通过bindService绑定： 绑定时，bindService -\u003e onCreate() –\u003e onBind()； 解绑定：unbindService –\u003eonUnbind() –\u003e onDestory()； 此时如果调用者（如Activity）直接退出，Service 由于与调用者绑定在一起，则Service随着调用者一同停止。\n（2）通过startService绑定： 启动时，startService –\u003e onCreate() –\u003e onStart()； 停止时，stopService –\u003e onDestroy()； 此时，服务与调用者（如Activity）没有绝对关联，当调用者关闭后服务还会一直在后台运行。 服务的生命周期\n23.在Android里面有各式各样的广播，比如：电池的状态变化、信号的强弱状态、电话的接听和短信的接收等等，本节将会介绍系统发送、监听这些广播的机制。\n两种广播注册方法的区别 第一种不是常驻型广播，也就是说广播跟随程序的生命周期 第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播过来，程序广播接收器也会被系统调用自动运行\n25.作为一个完整的应用程序，数据的存储与操作是必不可少的。Android系统为我们提供了四种数据存储方式，分别是：Shared Preference、SQLite、File和ContentProvider。 SharedPreference：一种常用的数据存储方式，其本质就是基于xml文件存储键值对（key-value）数据，通常用来存储一些简单的配置信息。\nSQLite：一个轻量级的数据库，支持基本SQL语法，是Android系统中常被采用的一种数据存储方式。Android为此数据库提供了一个名为SQLiteDatabase的类，封装了一些操作数据库的API。 文件储存：即常说的文件（I/O）存储方法，常用于存储数量比较大的数据，但缺点是更新数据将是一件困难的事情。 ContentProvider：它是Android系统中能实现应用程序之间数据共享的一种存储方式。由于Android系统中，数据基本都是私有的，存放于“data/data/程序包名（package name）”目录下，所以要实现数据共享，正确方式是使用ContentProvider。由于数据通常在各应用间是私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。如果应用程序有数据需要共享时，就需要使用ContentProvider为这些数据定义一个URI（包装成Uri对象），然后其他的应用程序就通过ContentResolver传入这个URI来对数据进行操作。\n26.SharedPreferences对象的常用方法有以下几种：\n27.Sqlite数据库的使用涉及到两个类：SQLiteDataBase和SQLiteOpenHelper\nSQLiteDatabase具体方法：\nSQLiteOpenHelper 具体方法\n例：要得到一个可写数据库，首先创建一个类继承 SQLiteOpenHelper，重写 onCreate()方法并在该方法中创建表，然后使用创建出的 SQLiteOpenHelper 的子类对象的 getWritableDatabase()方法获得一个可读写的数据库对象。\n28.网络状态\n29.JSON数据解析 是一种轻量级的数据交换格式，它基于纯文本，采用完全独立于语言的文本格式来存储和传输数据。在编程环境中解析JSON数据意味着将JSON字符串转换为程序可以理解并操作的数据结构 JSON Object：JSON中对象(Object)以“{”开始, 以“}”结束。对象中的每一个item都是一个键值对，表现为“key:value”的形式, 键值对之间使用逗号分隔。如下代码所示： { “name”：“coolxing”， “age”：24， “male”：true， “address”：{ “street”:“huiLongGuan”， “city”:“beijing”， “country”:“china” } }\nJSONArray: JSON数组(Array)以\"[“开始, 以”]“结束, 数组中的每一个元素可以是String,Number, Boolean, null, Object对象甚至是Array数组, 数组间的元素使用逗号分隔,如下代码所示： [ “coolxing”, 24， { “street”:“huiLongGuan”， “city”:“beijing”， “country”:“china” } ]\n30.Webview WebView 加载页面主要调用三个方法：LoadUrl、LoadData、LoadDataWithBaseURL. LoadUrl 直接加载网页、图片并显示。 LoadData 显示文字与图片内容。(模拟器1.5、1.6)。 LoadDataWithBase 显示文字与图片内容 (支持多个模拟器版本)。 使用webview的websetting来设置，WebSetting websetting = webView.getSettings(). Websetting常用方法：\n31.进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元。 通俗地讲一个进程代表一个应用程序，该应用程序运行在自己的进程当中，使用系统为其分配的堆内存，不受其他应用程序或者是其他进程的影响，是独立运行的。当然一个进程中可以同时运行多个应用程序，这时堆内存是共享的。\nAndroid系统为每个应用程序分配了一个进程，应用程序中组件（Activity，Service，BroadCast）的状态决定的一个进程的“重要性层次”，层次最低的属于旧进程。这个“重要性层次”有五个等级，也就是进程的生命周期，按最高层次到最低层次排列如下： （1）前台进程 （2）可视进程 （3）服务进程 （4）背景进程 （5）空进程\n一个Android应用只能存在一个进程，但是可以存在多个线程，也就是说，当应用启动后，系统分配了内存，这个进程的内存不被其他进程使用，但被进程中一个或多个线程共享。宏观地讲所有的进程是并发执行的，而进程中的多个线程同时执行但并不是并发的，系统的CPU会根据应用的线程数触发每个线程执行的时刻，当CPU时间轮到分配某个线程执行时刻时该线程开始执行，执行到下一个线程执行的时，依此轮询，直到线程执行结束。 在理解启动模式前，理解几个概念\n任务 用户尝试在您的应用中执行操作时与之互动的一系列 activity。这些 activity 按照每个 activity 的打开顺序排列在称为“返回堆栈”的堆栈中，也称为任务栈。 Activity：简单理解就是页面，下面介绍启动模式的时候我们都把它理解为“页面”； Intent：教材一般叫意图，简单理解它就是带操作的信息，像指令一样，接收到Intent就类似接收到指令一样。 一个应用可以有多个任务栈，在考虑一个应用一个任务栈的情况下，两个页面如果在不同应用程序，那么在启动这两个页面的时候，他们会被压入各自的任务栈，所以两个不同应用程序的各自页面一般不会出现在同一个任务栈中； onNewIntent() 方法的作用主要是允许已存在的 Activity 更新其状态以响应新的 Intent 数据。例如，在接收动态广播（如地理位置更新、消息通知等）或重新加载内容时，无需重启 Activity 就可以处理新的数据。开发者需要重写这个方法并在其中处理接收到的新 Intent 数据。 四种启动模式：\n标准模式（standard）\n默认启动模式，如果任务栈中没有Activity则会实例化一个新的Activity，并将其压入当前任务栈的顶部。 如果同一个Activity已经存在栈顶，那么新的实例仍然会被创建并压入栈中，因此栈中可能包含多个该Activity实例。\n单例模式（singleTop）\n当一个新的Intent要启动已位于栈顶的Activity（与请求的Intent匹配的Activity）时，系统不会创建新的Activity实例，而是将intent通过onNewIntent()方法传递给现有的Activity实例；\n如果目标Activity不在栈顶，则会正常创建新的实例； 如果目标Activity不在栈顶而在栈顶的下一层呢？ 比如现在有A-B-C-D,D在栈顶，如果传来的Intent是要打开页面C，在单例模式下也是正常创建； 总结：\n在单例模式下，\n如果页面不存在，也就是要打开的Activity没有在任务栈中实例化，那么正常创建Activity实例，并压入栈中； 如果Activity已经存在于任务栈中，且为栈顶，那么系统不创建新的Activity实例，而是将intent通过onNewIntent()方法传递给现有的Activity实例， 如果不是栈顶，正常创建Activity实例。 栈内复用模式（singleTask）\n当打开一个页面，也就是启动一个Activity时，系统首先会在整个任务栈中查找这个Activity是否已经在栈中，\n情况一：如果存在并且处于栈底，则直接把该Activity之上的所有Activity弹出栈，使这个Activity置于栈顶并调用其onNewIntent()。 情况二：如果在栈顶，则将intent通过onNewIntent()方法传递给现有的Activity实例 如果不存在已有的Activity实例，才会创建新的实例并放入栈顶。这种模式下的Activity始终只有一个实例存在于任务栈中。\n单实例模式（singleInstance）\n当启动Activity时，系统会为它创建一个新的任务栈，然后在这个新的栈顶放上这个Activity的实例。 如果再次启动这个Activity，即使是在另一个任务栈中，系统也不会创建新实例，而是将意图传递给已经存在的Activity实例。\n附件",
    "description": "接下来将将介绍AndroidStudio的复习资料，包括AndroidStudio简介、AndroidStudio中 Make Project 、Clean Project 、Rebuild Project 的作用、Run窗口、manifests文件夹（清单文件夹）、java文件夹、res文件夹、Android系统体系结构四层等。",
    "tags": [
      "安卓"
    ],
    "title": "AndroidStudio",
    "uri": "/class/2.androidstudio/androidstudio%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: AndroidStudio",
    "uri": "/tags/androidstudio/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: Z-专业课",
    "uri": "/categories/z-%E4%B8%93%E4%B8%9A%E8%AF%BE/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 安卓",
    "uri": "/tags/%E5%AE%89%E5%8D%93/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: R-软硬件",
    "uri": "/tags/r-%E8%BD%AF%E7%A1%AC%E4%BB%B6/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "过年\r计算机组成原理-复习1 计算机系统概论 计算机的分类 计算机总体上分为：电子模拟计算机1和电子数字计算机。二者区别如下表\n比较内容 电子数字计算机 电子模拟计算机 数据表示方法 0或1 电压 计算方式 数字计算 电压组合和测量值 控制方式 程序控制 盘上连线 精度 高 低 数据存储量 大 小 逻辑计算能力 强 无 计算机的五代变化 第一代1946~1957年， 数据处理 得到应用； 第二代1958~1964年， 工业控制 开始得到应用； 第三代1965~1971年， 小型计算机开始出现； 第四代1972~1990年， 微型计算机 开始出现； 第五代1991年开始， 单片机 开始出现 计算机的性能指标 处理机字长 指处理机运算其中一次能工处理的二进制数运算的位数，例如32位，64位。 存储器带宽 单位时间内从存储器独处的二进制数信息量，一般用 字节数/秒表示。",
    "description": "过年\r计算机组成原理-复习1 计算机系统概论 计算机的分类 计算机总体上分为：电子模拟计算机1和电子数字计算机。二者区别如下表\n比较内容 电子数字计算机 电子模拟计算机 数据表示方法 0或1 电压 计算方式 数字计算 电压组合和测量值 控制方式 程序控制 盘上连线 精度 高 低 数据存储量 大 小 逻辑计算能力 强 无 计算机的五代变化 第一代1946~1957年， 数据处理 得到应用； 第二代1958~1964年， 工业控制 开始得到应用； 第三代1965~1971年， 小型计算机开始出现； 第四代1972~1990年， 微型计算机 开始出现； 第五代1991年开始， 单片机 开始出现 计算机的性能指标 处理机字长 指处理机运算其中一次能工处理的二进制数运算的位数，例如32位，64位。 存储器带宽 单位时间内从存储器独处的二进制数信息量，一般用 字节数/秒表示。",
    "tags": [
      "嵌入式",
      "计算机组成原理",
      "Linux操作系统"
    ],
    "title": "计算机组成原理",
    "uri": "/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 计算机组成原理",
    "uri": "/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r计算机组成原理",
    "content": "1 计算机系统概论 计算机的分类 计算机总体上分为：电子模拟计算机1和电子数字计算机。二者区别如下表\n比较内容 电子数字计算机 电子模拟计算机 数据表示方法 0或1 电压 计算方式 数字计算 电压组合和测量值 控制方式 程序控制 盘上连线 精度 高 低 数据存储量 大 小 逻辑计算能力 强 无 计算机的五代变化 第一代1946~1957年， 数据处理 得到应用； 第二代1958~1964年， 工业控制 开始得到应用； 第三代1965~1971年， 小型计算机开始出现； 第四代1972~1990年， 微型计算机 开始出现； 第五代1991年开始， 单片机 开始出现 计算机的性能指标 处理机字长 指处理机运算其中一次能工处理的二进制数运算的位数，例如32位，64位。 存储器带宽 单位时间内从存储器独处的二进制数信息量，一般用 字节数/秒表示。\n2 运算方法和运算器 注：\n掌握各进制之间的转换； 掌握小数点之间的二进制与十进制之间的转换； 二进制纯小数或纯整数表示方法 二进制纯小数： 0.10101 或 1.10101，0或1表示正负号，在正负号后面，在实际中计算机并不存储小数点； 二进制纯整数： 10101.，同样纯整数也用0或1区分正负号。 用Xn-1表示二进制数的个数，Xn表示符号位，如下： Xn Xn-1……X0 符号 量值（尾数） 纯小数表示范围： $0\u003c=|x|\u003c=1-2^{-n} $ 纯整数表示范围： $0\u003c=|x|\u003c=2^{-n} - 1$\n浮点数表示方法 电子质量(克)： 9×10^28 = 0.9×10^27 太阳质量(克)： 2×10^33 = 0.2×10^34\n任意十进制数 N 可以表示为：\n$$N=10^E \\cdot M$$\r同样在二进制中也有这样类似的表达：\n$$ N=2^e \\cdot M$$ 在二进制浮点数表达中：\n尾数：M，是一个纯小数； 比例因子：e，表示指数，常用整数表示，也称为 阶码 ； 基数：式子中的2 二进制浮点数格式：\n$E_s$ $E_m-1…E_1 E_0$ $M_s$ $M_m-1…M_1 M_0$ 阶符 阶码 数符 尾数 IEEE754标准格式表示浮点数\n知识储备： $\\frac{1}{2^0}=1$,$\\frac{1}{2^1}=0.5$,$\\frac{1}{2^2}=0.25$,$\\frac{1}{2^3}=0.125$,$\\frac{1}{2^4}=0.0625$,$\\frac{1}{2^5}=0.03125$\n浮点数表示：\n$$ N=2^e \\cdot M$$ 浮点数所占位数：\n$S$ $E$ $M$ $31$ $30 \\gets 23$ $22 \\gets 0$ 基数R=2，基数固定，采用隐含方式来表示它。 32位的浮点数： S数的符号位，1位，在最高位，“0”表示正数，“1”表示负 数。 M是尾数， 23位，在低位部分，采用纯小数表示,不对小数点进行存储； E是阶码，8位，也就是说阶码最大不超过255，但阶码采用移码表示$E=2^{7}+e=127+e$，原因是移码比较大小方便。 规格化： 若不对浮点数的表示作出明确规定，同一个浮点数的表示就不是惟一的，所以一般都会规定这个浮点数的位数 尾数域最左位(最高有效位)总是1， 故这一位经常不予存储，而认为隐藏在小数点的左边。 采用这种方式时，将浮点数的指数真值e变成阶码E时，应将指数e加上一个固定的偏移值127(01111111)，即E=e+127。如果是二进制转真值就E=e-127 下面举两个例子进行说明：\n例1：二进制转十进制若浮点数x的754标准存储格式为(41360000)16，求其浮点数的十进制数值。\n解：将16进制数展开后，可得二制数格式为\n0 100 00010 011 0110 0000 0000 0000 0000\n符号S=0\n阶码E=100 00010\n尾数M=011 0110 0000 0000 0000 0000\n指数e=E-127=10000010-01111111=00000011=$(3)_10$，故有\n1.M=1.011 0110 0000 0000 0000 0000=1.011011\n于是有\n$x=(-1)S \\times 1.M \\times 2^e=+(1.011011) \\times 2^3=+1011.011=(11.375)_10$ 问： 0.011怎么转成0.375？\n根据上面的知识储备有$ \\frac{1}{2^0}\\times 0 + \\frac{1}{2^1}\\times 1 +\\frac{1}{2^2}\\times 1=0+0.25+0.125=0.375 $\n例2：十进制转二进制若浮点数为$(28.8125)_10$，求其浮点数的IEEE754标准存储格式的二进制数值。\n解：$(28.8125)_10$=$(11100.1101)_2$\n格式化表示为：$(11100.1101)_2=1.11001101 \\times 2^4$\n于是有\ne=4\nE=e+127=4+127=131=$(1000 0011)_2$\nM=1100 1101 0000 0000 0000 000（去掉小数点和小数点前的1，而且有23位，不够补0）\nS=0\nIEEE754标准的32为存储数据位：0 1000 0011 1100 1101 0000 0000 0000 000\n数的机器码表示 计算机进行运算时，会把符号位和数字一起编码表示为相应的数，这些数可以用不同的方法表示，例如：原码、补码、移码、反码；\n为了区别一般写的数（比如-12，+3等）和机器中的编码（比如 0 1100,1 0011），通常前者称之为 真值，后者称为 机器数 或 机器码 。\n$[x]_原$表示机器数，x表示真值。\n例如：\n$x=+0011$，$[x]{_原}=\\textbf{0}0011$\n$x=-0011$，$[x]{_原}=\\textbf{1}0011$，\n原码机器中有“+0”“-0”之分，固有两种形式：例如：$[x]{_原}$与$\\textbf{1}0011$表达的意思一样。\n数学上把类似于$-3=+9 (mod12)$的式成为 同余式。\n原码、反码、补码、移码 对原码、反码、补码、移码的简单说明，已知计算机为4位，x=-3.\n例子 表示方法 二进制 说明 -3 原码 $[-3]{_原}$=00011 -3 反码 $[-3]{_反}$=01100 按位取反 -3 补码 $[-3]{_补}$=01101 反码最低位加1，注意这个时候符号还是1 -3 移码 $[-3]{_移}$=1,1101 $[e]{_移}=2^{k}+e=2^4-0011=0,1101$ 对于正数来说，前三个都一样，重点说明移码：\n定点整数定义 $[e]{_移}=2^{k}+e, 2^k \u003ee≥-2^k$\n上面的表达式中，$[e]{_移}$表示机器码，e为真值，$2^k$表示固定偏移常量。\n已知e=+0011,k=4，$[e]{_移}=2^{k}+e=2^{4}+0011=1,0011$\n已知e=-0011,k=4，$[e]{_移}=2^{k}+e=2^{4}-0011=0,1101$\n移码中的逗号不是小数点，而是表示左边一位是符号位，显然移码中符号位与前三者的表示相反（详见P21）。\n下面请看例题：\n已知计算机是8位的，请分别写出纯整数125，-110，纯小数+0.125，-0.375；二进制数x=11011,y=-01010的原码、反码、补码、移码。（注意格式，要对齐）\n表示方法 表示方法 +125=00101 1111 -110=10011 1011 $[125]{_原}$=00101 1111 $[-110]{_原}$=10011 1011 $[125]{_反}$=00101 1111 $[-110]{_反}$=11100 0100 $[125]{_补}$=00101 1111 $[-110]{_补}$=11100 0101 $[125]{_移}$=1,0101 1111 $[-110]{_移}$=0,1100 0100 +0.125=0.0010 0000 -0.357=1.0110 0000 $[125]{_原}$=0.0010 0000 $[-110]{_原}$=1.0110 0000 $[125]{_反}$=0.0010 0000 $[-110]{_反}$=1.1001 1111 $[125]{_补}$=0.0010 0000 $[-110]{_补}$=1.1010 0000 $[125]{_移}$=1,0010 0000 $[-110]{_移}$=0,1010 0000 x=11011 -110=-01010 $[125]{_原}$=00001 1011 $[-110]{_原}$=10000 1010 $[125]{_反}$=00001 1011 $[-110]{_反}$=11111 0101 $[125]{_补}$=00001 1011 $[-110]{_补}$=11111 0111 $[125]{_移}$=1,0001 1011 $[-110]{_移}$=0,1111 0111 定点加法、减法运算 公式 补码加法：任意两数补码之和等于两数之和的补码，$[x]{_补}+[y]{_补}=[x+y]{_补}$\n补码减法：$[x-y]{_补}=[x]{_补}-[y]{_补}=[x]{_补}+[-y]{_补}$\n从$[y]{_补}$求$[-y]{_补}$的法则是对$[y]{_补}$包括符号位在内求反，最低位加1得到表达式为：\n$[-y]{_补}=\\rightharpoondown [y]{_补}+2^{-n}$ 其中，符号$\\rightharpoondown$表示对$[y]{_补}$作求反操作，包括正负号在内，$2^{-n}$表示末位（最低位）加1.\n下面举例加以理解运算过程：\n（ 详见P29 ）\n溢出概念与检验方法 在定点整数机器中，运算过程中出现大于字长绝对值的现象称为 溢出，溢出分正、负溢出两种，用两位符号位表示， 00、11分别表示整数和负数，01表示正溢出，10 表示负溢出。\n详细说明原理： 假设x表示二进制数，用$2^{-n}",
    "description": "1 计算机系统概论 计算机的分类 计算机总体上分为：电子模拟计算机1和电子数字计算机。二者区别如下表\n比较内容 电子数字计算机 电子模拟计算机 数据表示方法 0或1 电压 计算方式 数字计算 电压组合和测量值 控制方式 程序控制 盘上连线 精度 高 低 数据存储量 大 小 逻辑计算能力 强 无 计算机的五代变化 第一代1946~1957年， 数据处理 得到应用； 第二代1958~1964年， 工业控制 开始得到应用； 第三代1965~1971年， 小型计算机开始出现； 第四代1972~1990年， 微型计算机 开始出现； 第五代1991年开始， 单片机 开始出现 计算机的性能指标 处理机字长 指处理机运算其中一次能工处理的二进制数运算的位数，例如32位，64位。 存储器带宽 单位时间内从存储器独处的二进制数信息量，一般用 字节数/秒表示。",
    "tags": [
      "R-软硬件"
    ],
    "title": "计算机组成原理-复习",
    "uri": "/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "pretues+kiel5仿真软件配合使用时需要注意的地方不知道keil5从哪个版本开始就不支持了晶振的设置操作，我在网上搜也得到不同的答案，所以从哪个版本开始限制这就不提了， 好在这样的改变并不会形象我们使用keil5。最近在刚进阶学习stm32，用到了pretues_8.11 仿真软 件和keil5代码编辑器，自己把心中所得分享一下。",
    "description": "pretues+kiel5仿真软件配合使用时需要注意的地方不知道keil5从哪个版本开始就不支持了晶振的设置操作，我在网上搜也得到不同的答案，所以从哪个版本开始限制这就不提了， 好在这样的改变并不会形象我们使用keil5。最近在刚进阶学习stm32，用到了pretues_8.11 仿真软 件和keil5代码编辑器，自己把心中所得分享一下。",
    "tags": [
      "单片机"
    ],
    "title": "51单片机",
    "uri": "/class/8.51%E5%8D%95%E7%89%87%E6%9C%BA/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: D1-51单片机",
    "uri": "/categories/d1-51%E5%8D%95%E7%89%87%E6%9C%BA/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \r51单片机",
    "content": "不知道keil5从哪个版本开始就不支持了晶振的设置操作，我在网上搜也得到不同的答案，所以从哪个版本开始限制这就不提了， 好在这样的改变并不会形象我们使用keil5。最近在刚进阶学习stm32，用到了pretues_8.11 仿真软 件和keil5代码编辑器，自己把心中所得分享一下。\n别人编译编译成功的工程，我另外用keil5打开编译为什么会失败？\n假设你拿到的别人的工程所选芯片为stm32f103VC，那么你在另外的电脑打开keil5，在设置里选芯片也是stm32f103VC，如果选的芯片与工程最初选的型号不同，那编译可能会失败，接着在打勾生成.hex文件。\npretues里没有找到keil5里选择的芯片，能用别的芯片代替吗？\n答案是可以的，但尽量使用版本更高的芯片，使之能向下兼容，在keil5如果选了stm32f103VC，而pretues仿真的芯片是stm32f103C6，那么你并不用担心芯片不对应而导致你仿真失败。\n在pretues导入.hex文件后直接开始仿真，为什么报了许多错误？\n可能原因：在选择好.hex文件后，还必须设置晶振频率，即12MHz，如果没置会导致仿真失败，另外你不用担心选择的.hex文件路径有中文，我测过即使导入文件路径有中文也可以正常运行。\n附件",
    "description": "不知道keil5从哪个版本开始就不支持了晶振的设置操作，我在网上搜也得到不同的答案，所以从哪个版本开始限制这就不提了， 好在这样的改变并不会形象我们使用keil5。最近在刚进阶学习stm32，用到了pretues_8.11 仿真软 件和keil5代码编辑器，自己把心中所得分享一下。",
    "tags": [
      "代码烧录",
      "报错与解决"
    ],
    "title": "pretues+kiel5仿真软件配合使用时需要注意的地方",
    "uri": "/class/8.51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%BB%A3%E7%A0%81%E7%83%A7%E5%BD%95/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 报错与解决",
    "uri": "/tags/%E6%8A%A5%E9%94%99%E4%B8%8E%E8%A7%A3%E5%86%B3/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 代码烧录",
    "uri": "/tags/%E4%BB%A3%E7%A0%81%E7%83%A7%E5%BD%95/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 单片机",
    "uri": "/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: X1-小说",
    "uri": "/categories/x1-%E5%B0%8F%E8%AF%B4/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 爱情",
    "uri": "/tags/%E7%88%B1%E6%83%85/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说",
    "content": "第一章 与君初相识 高中那会儿我老失眠，原因一言难尽。\n记得有一次我去吃饭，遇到张君，我们聊闲聊中，谈到了我失眠的事，张君听了说，他们有个朋友以睡觉为己任的人。我不信，哪有这种人？\n几天后张君竟把他介绍给了我，我们仨还一起去吃了饭，顺便逛了街，特别是喝奶茶的时候，张君故意给我和他有二人空间，整得像相亲似的，而后只是聊了些生活学习上的问题……在买花的时候我叫住他：“那个？”\n没想到他没听见，“听说你以‘睡觉’为己任，”我提了声音又叫了一遍，搞得自己有些尴尬：“是真的？”\n他一脸疑惑，又露出让人想笑的表情，道：“what?”\n气氛顿时尴尬，我有些不好意思，手挡了挡额头，说了句，没什么。回头继续吃着烧烤便不再问什么，寻思着张君的话自己也信？\n傍晚有些冷，校门就是我们的最后一站，老天在天角涂了层口红，不知道什么色号的，仔细看还挺美的。突然，岭正叫住了我，道：“都是为了我的下一代!”\n我一时间没反应过来，以为他在与别人对话，不想他似有深情地看着我，补充道：“所以，你要好好睡觉才行！”\n而后迷人之笑，怎么说呢？看着像在演戏一样，感觉这种桥段只有小说电视里才有，让我又懵又有些难为情，一时想不到什么好的词，只好顶着职业假笑示意“好的”。 “绘妹妹，”回寝室路上张君调侃道：“你要好好睡觉哦。”而后一阵哈哈大笑，我急忙想制止她，可越要这么做她就越要说，越说越开心。\n回宿舍后我细品了岭正的话，总感觉有什么意思在里头，但时间久了便不再放在心上。\n……\n后来张君不怎么提他，我倒是期待着张君说点关于他的什么，至于为什么这么想，我不敢究其原因，也不想问张君 ，只想着张君能和我说说，明明是些琐碎的事罢了，再次回忆，便不由自主地想起那些人，那些事。\n三个月后的一天，张君突然问我，还记得不得上次给你介绍的帅哥。我说，帅哥不记得了，只记得有个人说什么好好睡觉。随后聊的具体内容记不太清，依稀记得张君说，他转到了我们学校，而且在我们隔壁班。这算个惊喜吗……在我的生活里没那么多惊喜，也许眼睛会和惊喜反应，“生成”眼睛和平平无奇。\n分班后的一天，我去找张君，问她在哪个班。张君告诉我，他们班在一楼，离食堂最近。她还说，一般来说，学校的食堂都挺干净的，外面的不怎么卫生，可绘啊！我还是喜欢吃外面的，特别是小帅哥带来的。\n我说：“又是用美色挣来的吧！”\n张君听到后哈哈笑了，笑声爽朗，我也跟着笑了起来，和她总能这么开心，但是，笑过之后我却突然感觉心情有些沉重。因为在上个学期期末考试结束后，我看到她和另外一个男同学坐在靠窗的位置上，他们俩个正在讨论着什么。他们的讨论是那样的热烈和激情，这是我从未见到过的。这一刻，我不知为何渴望着融入他们。\n第二章 仲夏夜之星 张君看着楼道下，一个小巧的女孩正一步一步走来，她知道是谁，长舒了一口气，转身对着小峰说道，小峰，我好像有点喜欢上你了。小峰一时还转不过来，刚刚还在讨论高考的试题，现在怎么……小峰没说什么，故意移开视线看着试题，张君，又继续道：\n“可以牵牵我的手吗？一会儿，就一会儿。”张君抿了抿小嘴，“不说话就是默许。”张君不再犹豫，牵起了小峰的手。小峰面颊泛红，激动又开心，温暖的小手，好像柔软的云朵，微风拂过两腮，不经意让小峰忆起往事。他想：现在怎么也不想松开这个女孩的手了，因为这一天小峰已经等了很久很久了。\n四年前的一个夜晚，我打球准备回宿舍，在收拾时，看到张君一个人独自坐在长椅上，篮球场两排明亮的灯光照在她的身上，泛着光，影子投影到地面综错散乱，被拉成常常的弧线，我走了过去，夜晚的榕树下凉得让人想就地睡觉，有些疲惫的我边走边拉伸着身体。\n“唉，在这干嘛呢？”\n“哟，打球呐。”张君寻着熟悉声音，看向小峰，确认是他后，说道：“出来乘凉。”\n“切，女生宿舍不有风扇吗？”\n“你以为想吹就吹啊！那也是要看舍友滴……女生的世界，你个男生不懂。”\n小峰擦了擦头，看着地面道：\n“谁tm大晚上跑出来乘凉啊？现在又不是夏季。”\n“小峰，如果有个男生喜欢你……”张君长叹，又咽了咽口水，慵懒的说：“你们……”\n“什么？男的！那不搞基吗？”\n“呀，什么搞基啊，认真听我说嘛！”她继续道：“她还是你同学，你怎么办？”\n“拒绝啊……为什么？当然是因为我喜欢女孩子啦，而且我接受不了……如果吗？哪有什么如果，你这是假设，这样的场景和画面我敢都不敢想像，怎么你搞……” 张君插话道：“什么什么呀！好好说话好不好。”\n那天我想着要再次向张君表白，当时气氛尤为适宜，夜晚的操场很快人离影散，满天的星空捧着圆月，远远的传来葡萄架下的蟋蟀的奏鸣曲，好像拉小提琴一样，悠长而又慢慢地穿到我和张君这，操场的灯光还明着，铺洒一地，犹如海浪扑来，直冲张君的脚下，瞬间在身上如水浸透白纸般，我坐在长椅较暗的地方，一身好像穿着高雅的西服，一切都让我内心波涛汹涌。\n我们似乎同时说出了对方的名字，我有些不好意思，他亦如此，我便让他先说。\n“我被个女孩喜欢上了，她是我要好的朋友，看着小颗小颗的，纤弱又可爱，让我……不由自主产生保护她的心理，可是我不想因为这件事破坏我们的友谊……”\n聊了会，交谈中张君告诉了我那人的名字，知道后也有些震撼，也许那时候不知道什么是喜欢，什么是爱，所以我不能理解她们的关系和情愫。正说着，我们看到校警摸着电筒，四处照射，似个夜间丛林里的猎人，我们也结束了相关的话题。\n那后我渐渐的对她们之间的关系有些不自在起来，虽然如此，但我对张君的心却一直不变，对她仍存一丝丝希望，期待着有一天她回头，可以见到我还在原地等她归来，我无法忘记我与她们一同“出境”的尴尬处境，特别是虚假地做她男友，在喜欢她的人面前，把恋人的关系发挥到极致的事，我讨厌又害怕，犹如一场美梦，醒来却是肮脏的现实，噩梦般的现实。\n记得有一次我还因此谎称生病，停了一周的课，可我忘不掉张君，我依旧喜欢她，我想和她来一次真正的恋爱，不一定热烈浪漫，但一定真实难以忘怀。在高中时我就知道她其实不喜欢我，可我还是默默等待着，在漆黑的夜晚做个可怜的人。\n等我明白渐渐理解，和解这些事时，那已是许多年后的事了，张君也早已远嫁他乡，他乡的那颗星也一直在我可以看到的地方闪闪发光。\n第三章 剪不断，理还乱 苏绘走上楼梯，走廊传来张君的声音，他们讨论着今年高考各科试卷。\n我纳闷一个文科生，一个理科生的，有什么好讨论的？我知道此刻我是羡慕的，想想自己摸底考自己就是一个失败者，失败者，失败者……\n我苦涩地一笑，恰巧张君见状问道：“绘，怎么了？”\n我回过神，道：“没什么。”\n等我微微抬头——张君和小峰的手十指相扣，看着好像他们的手被牢牢焊死，原来刚刚的男孩是小峰，为什么，为什么，那背影，那声音完全是另外的人。对我是那样的尊敬，玩笑都开不起，而对张君却畅言所欲，小峰， 小峰……我的内心一声又一声，就像远山传来的回音。\n张君闻言大笑：“哈哈哈……你这个形象真好笑，对了告诉你哦，我和小峰确立关系了哦，今晚要不要庆祝一下下。”\n张君说的小峰，是我认识的人，那会还初中，我一直觉得小峰比较内向，又有点高冷，可现在看来它和张君的性格都比较随意，所以关系也建立得很快，现在都是情侣了。我和张君是从小认识的，可以说我们是死党，我总喜欢调戏她和她的堂弟云，和他们关系特别好，我觉得我是他们最好的朋友，所以总是会开开些无伤大雅的玩笑。\n“干嘛呢？开玩笑的，我和小峰没交往，”和小峰分开后，张君说了实话，可我当时并不相信，即使她说，有个人喜欢他，小峰为了避开她，他们就演演喽。\n“我说嘛！君姐怎么会那么快换男朋友嘛！”\n“啊？”张君看着我，愣了会儿，说道：“那不是。”随后我们鹅鹅地笑出声。\n后面我和张君又聊了几句，然后就各回了各自己的寝室，我推开寝室进去，一片死寂充斥着寝室，我坐在床边，呆呆地看着天花板，突然觉得心里一阵空落落，仿佛心底里丢失了一个什么东西，很难受很难受。\n张君，小峰和岭正分到了一个班，他们三个在班级里很低调，也不敢在学校里表露出他们三个的关系，毕竟那个班有些特殊，或许是不想引起别人的注意吧。不知道从什么时候开始自己躲在暗角默默地暗恋着岭正，对岭正的记忆自从分开后慢慢从脑海中消失，突然我想起，张君说的，我以后可能会是他的妻子，虽然我知道这是个假的概率，毕竟我和他还没到那一步，但心底里却不免升腾起一丝妄想，这些妄想也随着时间一天一天蒸发殆尽，为了不让这样的念头消失，我试着与他见面。我知道我配不上他，但是心底深处，却有些隐隐约约的期盼，期盼着有一天，我们能够在校园偶遇，在校园内，能够成为朋友，这样，我就能够时时刻刻，见证我和他在张君心目中的地位了。\n一晃一年的时间，转瞬即逝。\n我和张君、小峰、岭正他们的联系少之又少，除了偶尔见面聊聊，别的联系少之又少。\n我们似乎都各奔东西了。\n第四章 再忆江南曲 大一的一天晚上，我一个人躺在床上，想着和张君的点滴往事，我想起了我们初入江南高中时那个阳光开朗的张君，想起了那个总是喜欢逗我，却从来没有欺负我的云，想起了初中我第一次在学校的篮球场和小峰见面的那个早晨。\n初中篮球场。\n那一天天气格外炎热，有些受不了的直接不来，有些则虚弱地装一下，老师自然是信的，这样的天气搞不好真的会中暑呢。小峰注意班上的班花很久了，从军训那天开始，他就一直关注着她，报体育委员也是因为有她的名字，只可惜她没选上。这天，女子篮球组在练习，\n“唉！她身边老跟一个家伙”\n“什么家伙，人家有名字，叫苏绘。”\n“耶，你们认识？”小峰的同学手靠在他肩上，说道：“什么时候的事。”\n“唉，小学那会儿了，不过她是隔壁班的，她应该不记得我。”\n小峰看要到他们组训练了，顾不了那么多了，直接上前与班花搭话。\n我们第一次见面。小峰说：“如果你愿意当我的女朋友，我可以考虑带你进军篮球队。”当时张君愣了好一会，我也一样，这句话他是对张君说的，想想当时他是体育委员，我只不过是个连投球都不会，还硬要参加女子篮球队的家伙，自己真的傻得可怜。\n张君看了看绘，对她说，绘可以帮我去拿一下纸巾吗，在那边的树底下，谢谢。\n看着绘远去，张君提高了些声音，说道，你有那本事，我就答应。\n小峰一脸春风拂面，说道：“你说的，别反悔。”\n想到这我觉得那件事张君是刻意这么做的。\n第五章 终章 那时的我还是一个不谙世事的毛丫头，看着张君与小峰在一起，自己竟眼红了起来，那段时间一切的事情都只想着怎么和岭正在一起，我每天都在幻想着和他有朝一日可以成为男女朋友的画面，但是，一切的梦境都只是梦境而已，在现实里，我和他永远也不会在一起。想到那天鼓气勇气与岭正告白，却被拒绝的画面……眼泪不知怎的流出眼眶，打湿脸颊，黑夜抚摸着我，似乎在特意安慰，可我内心久久无法平静，久久无法入睡。\n翻来覆去怎么也是那美好而又难过的岁月。\n那天，我去学校图书馆借书，张君的书包落在图书馆里。张君让我在图书馆外面等一下，张君走了很久，我在图书馆外面站了好久好久，突然有人拍了我肩膀一下，我吓了一跳，猛地回头，见是云，我松了口气，拍了拍胸脯，责怪他道：“怎么走路一点声音都没有，吓死我了。”\n云微笑着，道：“我看你站在外面想事情想得很投入，所以就狠下心打扰你。”\n我问：“你怎么在这里？”\n云说：“我和朋友谈了点事儿，他们让我在这里等。”\n云的那些朋友都是高年级的学生，有男有女，看起来都不怎么好惹的样子，不用说也知道，云在这里肯定是认识不少人的，我心中不禁有些担忧，担心云在这里受到别人欺负。 我问：“你朋友都是些什么人啊？”\n云道：“是我以前的同学，现在都在这个学校里上学，我在这里认识不少人，以后有事儿，找我，我罩着你！”\n我道：“好啊，那我有事儿了再找你吧！”\n云说：“行！”\n云和我说的话很简单，但是，我知道他一定是一个善良的人。\n在外面久久不见张君出来，我的内心莫名有些难受，等待也许就是这样……\n想到这我才知道，那时的自己对张君是怎么样的感情，我就是只愿做信鸽脚下的信筒，即使有天会被丢弃，只要有一刻还在与她在一起，我所忍受的都是值得的，可我一直在她的庇护下，一步一步走向自己的未来，这种种美好而痛苦的记忆我永生难忘，这一生也不会再有。\n写于2021年6月",
    "description": "一段跨越青春岁月的校园记忆，在友情与暧昧的缝隙中悄然生长。苏绘与张君因一场失眠邂逅另一个少年，一段段往事就此展开，她们分享秘密，试探真心，却也各自藏起无法言说的情愫。当成长的年轮碾过懵懂的约定，那些未寄出的告白、假装的笑容与深夜的眼泪，最终凝结成青春独有的遗憾与温柔。这是一个关于暗恋、陪伴与自我和解的故事，在记忆的星空中，所有未完成的对话都成了照亮年少时光的微光。",
    "tags": [
      "校园",
      "爱情"
    ],
    "title": "君绘语",
    "uri": "/story/4.%E5%90%9B%E7%BB%98%E8%AF%AD/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 校园",
    "uri": "/tags/%E6%A0%A1%E5%9B%AD/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说",
    "content": "牛村和花村之间只隔着一片红树林。深秋时节，满山的红叶像火烧云似的铺满了山坡。牛村村尾是个热闹地方，常有城里人来玩耍，就是离阿牛家远了点儿。\n“哎！阿牛！你要媳妇不？只要你开个金口……“阿牛正弯腰收拾晒干的稻草，听见这大舌头的声音就知道是村里的跑腿阿光。回头一看，阿光正扶着栅栏，脸红得像猴屁股，满身酒气。\n“媳妇？不要。“阿牛头也不抬，继续捆他的稻草。\n阿光踉踉跄跄地凑过来：“村尾…来了个漂亮姑娘！保准…保准你喜欢！”\n“忙着呢，得去花村。“阿牛扛起稻草就要走，阿光还在牛槽边嘟囔着什么，自己乐得直拍大腿。\n天边乌云压得低低的，眼瞅着要下雨。阿牛想着得回家拿伞，刚转身，忽然听见桥下传来熟悉的笑声。他趴在桥栏杆上一看，顿时愣住了。\n那不是阿花吗？还有从小欺负他的阿狗。两个人你追我赶的，阿花娇嗔着\"轻点儿”，阿狗的手就没老实过。这场景落在阿牛眼里，像刀子似的扎心。\n“呸！晦气！“阿牛气得肝疼，把准备给未来老丈人的酒摔了个粉碎，扭头就走。一路上越想越憋屈：从小到大，阿花哭了他哄，阿花闹了他陪，为了给她买生日礼物，他跑城里挑了三天三夜。可现在呢？\n阿花听见林子里哗啦啦响，抬头看天要下雨，赶紧说：“阿狗哥，回吧，阿牛哥该到咱村了。”\n阿狗撇撇嘴：“整天阿牛哥长阿牛哥短的……“话没说完，阿花已经跑远了。\n这场雨下得急，花村村口始终没见阿牛的身影。阿花站在家门口望眼欲穿，看见个人影就喊\"阿牛哥”，结果来的是阿狗。她\"砰\"地关上门，她爹在院里叹气：“闺女啊，阿牛这些日子怕是不会来了。”\n“为啥？“阿花急得直跺脚。\n“张婶说看见他在桥头摔了酒坛子……”\n阿花一愣，突然明白过来，抓起蓑衣就往外跑。她爹在后面喊：“天要黑了，饭都不吃？““不吃了！“声音已经飘出去老远。\n阿花边跑边回想那天的事：她在河边抓鱼，阿狗老往身上蹭，她明明推开他了，还骂他\"男女授受不亲”。怎么在阿牛眼里就变了味儿？\n这头阿牛心里也乱得很。那天他上山割草，听见几个二流子说村里姑娘的荤话，气得抡起拳头就揍。被救的姑娘叫瑶妹，是城里回来的，长得跟画里的人似的，非要请他喝茶感谢。\n瑶妹端着茶碗笑出两个酒窝：“阿牛哥，听说红叶林可好看了，能带我去看看吗？”\n阿牛正要答应，突然听见一声\"阿牛哥”——是阿花！她跌跌撞撞冲进来，看见这场景顿时哭成了泪人：“我以为你是生我气，原来是有了新人！”\n瑶妹刚要解释，阿狗突然冲出来推了阿牛一把：“负心汉！“阿花见瑶妹扶着阿牛，更是火冒三丈，指着瑶妹就骂。阿狗还在旁边煽风点火：“他早看上阿光他姐了！”\n阿牛气得挥拳要打，阿花突然尖叫一声：“够了！“她眼泪汪汪地看着阿牛：“我以为桥上是误会，现在看是真的。阿狗哥比你好多了！“说完扭头就跑。\n阿牛瘫坐在地上，看着满地的茶碗碎片，心里比那碎瓷片还扎得慌。\n深秋的清晨，红树林的叶子簌簌地落，阿牛背着镰刀，在桥头割牛草。他低着头，手上动作麻利，心里却还想着那天的事。\n“阿牛啊，咋一个人在这儿？”\n阿牛抬头，见是阿花的父亲，老花叔。老花叔叼着烟斗，笑眯眯地看着他。\n“叔，您咋来了？”阿牛直起身，拍了拍手上的草屑。\n“路过，看你在这儿，就过来唠唠。”老花叔走近，烟斗在桥栏杆上磕了磕，“听说你前些日子摔了酒坛子？”\n阿牛脸色一僵，低头没吭声。\n老花叔叹了口气：“阿花那丫头，性子倔，从小就这样。你们俩……是不是有啥误会？”\n阿牛沉默了一会儿，终于把那天在桥下看到的事说了。老花叔听完，眉头一皱：“这丫头，咋不解释清楚？”\n阿牛苦笑：“叔，算了，都过去了。”\n老花叔拍了拍他的肩：“行，我回去问问她。”\n可还没等老花叔回家，阿花已经收拾包袱去了城里。老花叔站在村口，望着远去的马车，摇头叹气：“这丫头，跑得倒快。”\n没过多久，村里招兵，阿牛报了名。临行前，老花叔塞给他一包干粮：“路上小心，早点回来。”\n阿牛点点头，背起行囊走了。\n可刚到城里，他的包袱就被人顺走了。他站在陌生的街头，兜里一个铜板都没剩。饿了两天，他蹲在巷子口，眼前发黑。\n“喂，你没事吧？”\n一个穿着干净布衣的男人递给他一个馒头。阿牛抬头，是个陌生的年轻人，眉眼温和。\n“拿着吧，看你饿得慌。”\n阿牛接过馒头，狼吞虎咽地吃完。那人又给了他几个铜板：“找个地方住下，别睡街上。”\n阿牛感激地点头：“谢谢大哥，您叫啥名？”\n那人笑了笑：“叫我阿诚就行。”\n阿诚帮他在码头找了份短工，让他熬过了最难的日子。后来，阿牛顺利入伍，临走前，他回头望了望城里的方向，心里默默记下了这份恩情。\n转眼三年过去，阿牛光荣退伍，回到了牛村。村里变化不大，红树林依旧红得耀眼。\n这天，瑶妹家盖新房，阿牛去帮忙。正搬着木头，忽然听见有人喊他：“阿牛？”\n他回头，是老花叔。\n“叔，您咋来了？”\n老花叔笑呵呵地走过来：“阿光家盖房子，过来帮帮忙。”\n两人坐在院角的石凳上，老花叔递给他一支烟：“当兵苦不苦？”\n阿牛摇头：“不苦，比饿肚子强。”\n老花叔沉默了一会儿，忽然问：“当年那事，阿花后来知道了。”\n阿牛一愣：“她……知道了？”\n“你入伍后一年，她才听阿狗亲口承认，那天在桥下，是她推开了他，骂他‘男女授受不亲’。”老花叔叹了口气，“可那时候，她已经去了城里，再回来时，已经定了亲。”\n阿牛手指微微发紧，烟灰掉在地上。\n老花叔看着他，话里带了几分深意：“那户人家在城里开着绸缎庄，阿花嫁过去，吃穿不愁，也算……合适。”他拍了拍阿牛的膝盖，“你是个好孩子，叔心里清楚，你也别怪她”\n阿牛扯了扯嘴角：“叔，我早就不怪她了。”\n晚上，老花叔拉着阿牛去了家里，说什么也要喝上一杯。刚坐下没多久，院门被推开，阿花走了进来，老花叔有些诧异，怎么没有提前通知自己，探头叫屋里的老伴多做几碗饭。\n阿花穿着城里人的衣裳，头发盘得精致，比从前更漂亮了。看见阿牛，她脚步一顿，眼神复杂。\n“阿牛哥……”\n阿牛站起身，笑了笑：“阿花，好久不见。”\n两人坐在院子里，夜风微凉。阿花低着头：“当年的事，是我没解释清楚。”\n阿牛摇头：“都过去了。”\n阿花沉默了一会儿，忽然问：“你在城里……过得还好吗？”\n“还行，多亏有人帮了我。”\n“谁帮了你？”\n“一个叫阿诚的，在码头做工。”\n阿花猛地抬头，手不自觉地捏紧了衣角。她张了张嘴，却什么也没说，只是起身从堂屋的柜子上取下一张泛黄的照片。照片上是年幼的阿花，扎着羊角辫，旁边站着个眉眼温和的少年，手里捧着一束野花。\n阿牛盯着照片，记忆闪过儿时模糊的记忆，阿花先开口说道：“小时候他就被送去城里念书，后来成了码头管事的，阿爸说，算是有出息的孩子了……”。\n两人便这样谈着，说起了童年往事，在蟋蟀声中二人仿佛回到了过去。\n几个月后，阿牛在城里办事，路过一家花店。他本没在意，可一抬眼，看见店里有个熟悉的身影——阿诚。\n阿诚正低头修剪花枝，抬头看见他，笑了：“哟，这不是阿牛吗？”\n阿牛走进去：“阿诚哥，原来你开花店？”\n阿诚点头：“唉，这我女朋友的，今天刚开张来打理打理。”\n两人聊了几句，阿诚忽然转身从柜台下摸出一包东西：“对了，前些日子阿花托我捎给你的。”\n那是一包晒干的野菊花，用红绸布裹着，布角绣着一朵小小的木棉花——阿花从前最爱绣的花样。\n阿牛接过布包，指尖摩挲着绸布上的针脚。窗外一阵风过，街角的红叶轻轻飘落，像极了那年桥头的秋天。\n（完）",
    "description": "牛村与花村隔着一片红树林，阿牛和阿花从小在红叶堆里打滚长大。那年深秋，一场桥下误会让阿牛摔了定亲酒，阿花连夜进城，阿牛入伍流落街头。三年后，阿牛退伍回乡，当他接过一包绣着木棉的野菊花，才嚼出那年月里藏着的苦与甜：有些心意像深秋的红叶，风一吹就散了，可落下时偏偏砸得人心口生疼。",
    "tags": [
      "爱情",
      "民风"
    ],
    "title": "红叶那头儿",
    "uri": "/story/1.%E9%98%BF%E7%89%9B%E9%98%BF%E8%8A%B1/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 民风",
    "uri": "/tags/%E6%B0%91%E9%A3%8E/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \rAndroidStudio",
    "content": "这篇文章主要介绍AndroidStudio的使用，以及一些Android开发的基础知识。以及一些开发中遇到的问题和解决方法，除此之外，还会介绍一些开发中常用的工具和技巧。\n第一章 配置开发环境 1.安装JDK “安装连接” 2.安装AndroidStudio “安装连接” 3.安装SDK 4.AndroidStudio汉化 https://www.bilibili.com/video/BV1Hz4y1K7Tc/ 第二章 Gradle():自动构建 日志输出工具：查看报错 Run（运行）\n工程结构： （清单文件）：对Activity，service，re广播等进行注册的文件 Java目录： 后缀为 .class drawable目录：资源文件，放图片、图标、背景资源的文件 Layout目录：放页面布局文件 放图片和.xml文件，适配不同分辨率的文件夹 values目录：颜色、数组、字符串、样式\nAndroid基本原理 Android体系结构 Android 用用程序核心组件 Activity 第四章 Activity、Fragment以及Intent通信机制 Activity生命周期 四种状态的转换\n布局的特点：\n第八章 数据存储和提供器 SharedPreference 使用键值对关系来获取文件\nSQLite 轻量级占用内存小，支持基本的MySQL语言。 创建过程：\nContentPreference（应用存储） 通过暴露URL让软件之间可以共享文件 好比一般使用文件时，软件会要求需要访问你手机文件权限。\n文件存储 网络通信编程 网络访问方式 网络状态码，例如404表示什么？\n数据解析 1.JSON格式解析： 以类对象的方式进行相应，以数组的方式进行相应，也可以二者混合。\n网络状态 JavaScript与Java交互 webView的使用\n在简单的使用webview过程中可能无法进入指定的网页，而且AndroidStudio模拟机上还会弹出如下错误：\n**Webpage not available** The webpage at http://www.baidu.comi could not beloaded because: net::ERR_CLEARTEXT_NOT_PERMITTED\r解决的办法： 请在AndroidManifest.xml文件下添加代码： .xml文件\r添加代码\r\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /\u003e\r如果添加上面的还不可以，请在manifest中添加如下代码：\n.xml文件\r添加代码\r\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest ...\u003e \u003capplication ... android:usesCleartextTraffic=\"true\"\u003e ... \u003c/application\u003e \u003c/manifest\u003e\r“原文章链接”\ngetwebSetting\n附件",
    "description": "这篇文章主要介绍AndroidStudio的使用，以及一些Android开发的基础知识。以及一些开发中遇到的问题和解决方法，除此之外，还会介绍一些开发中常用的工具和技巧。",
    "tags": [
      "安卓"
    ],
    "title": "AndroidStudio笔记",
    "uri": "/class/2.androidstudio/%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: B2-笔记",
    "uri": "/categories/b2-%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程 \u003e \rAndroidStudio",
    "content": "menu文件的创建 在创建menu这个目录前，请看查看res/目录下是否包含该目录，如果没有则创建。 接着在该目录下创建xml文件，此处文件名为content_menu。在该content_menu使用\u003citem,如下为部分代码： .xml文件\r简码\r全码\r\u003citem android:id=\"@+id/content_menu_group_chat\" android:title=\"发起群聊\" android:orderInCategory=\"1\" /\u003e\r\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmenu xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:id=\"@+id/content_menu_group_chat\" android:title=\"发起群聊\" android:orderInCategory=\"1\" /\u003e \u003citem android:id=\"@+id/content_menu_add_friend\" android:title=\"添加朋友\" android:orderInCategory=\"2\" /\u003e \u003citem android:id=\"@+id/content_menu_add_RichScan\" android:title=\"扫一扫\" android:orderInCategory=\"3\" /\u003e \u003citem android:id=\"@+id/content_menu_add_QRcode\" android:title=\"扫码\" android:orderInCategory=\"4\" /\u003e \u003c/menu\u003e\r在代码中orderInCategory属性是用来控制该item权重的，权重越小等级越高，该标题就会靠前显示， 结果\r创建布局页面 详细代码如下： .xml文件\r简码\r全码\r\u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/options_menu_toolbar\" android:layout_width=\"409dp\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" android:minHeight=\"?attr/actionBarSize\" android:theme=\"?attr/actionBarTheme\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e\r\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/options_menu_toolbar\" android:layout_width=\"409dp\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" android:minHeight=\"?attr/actionBarSize\" android:theme=\"?attr/actionBarTheme\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\rActivity.java1文件中 此处创建类的步骤，继承AppCompatActivity方法就不再赘述。\n在onCreate获取Toolbar的id，这个过程也叫实例化； 接着使用方法setSupportActionBar; 在onCreate外重写onCreateOptionsMenu和onOptionsItemSelected方法。 .java文件\ronCreate\ronCreateOptionsMenu\ronOptionsItemSelected\r全码\r@SuppressLint(\"MissingInflatedId\") @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.opetions_menu); toolbar = findViewById(R.id.options_menu_toolbar); setSupportActionBar(toolbar); }\r@Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.content_menu,menu); return super.onCreateOptionsMenu(menu); }\r@Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { //获取menu目录中content_menu.xml文件里item的id int id = item.getItemId(); //判断id是否被点击，被点击就执行相应的动作，比如页面跳转 if(id == R.id.content_menu_add_friend){ Intent intent = new Intent(OpetionsMenu.this,ListDialogActivity.class); startActivity(intent); }else if(id == R.id.content_menu_group_chat){ return super.onContextItemSelected(item); } return false; }\rpackage com.example.practiceapplication; import android.annotation.SuppressLint; import android.content.Intent; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.widget.Toolbar; public class OpetionsMenu extends AppCompatActivity { private Toolbar toolbar; @SuppressLint(\"MissingInflatedId\") @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.opetions_menu); toolbar = findViewById(R.id.options_menu_toolbar); setSupportActionBar(toolbar); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.content_menu,menu); return super.onCreateOptionsMenu(menu); } @Override public boolean onOptionsItemSelected(@NonNull MenuItem item) { int id = item.getItemId(); if(id == R.id.content_menu_add_friend){ Intent intent = new Intent(OpetionsMenu.this,ListDialogActivity.class); startActivity(intent); }else if(id == R.id.content_menu_group_chat){ return super.onContextItemSelected(item); } return false; } }\r最终结果 结果\r展开\r详细知识等我更新……\rActivity.java这个文件的一般就是我们所说的主程序，类似与C语言中的包含main入口的文件。 ↩︎",
    "description": "本篇文章主要介绍**Toolbar**工具栏的使用，以及**menu**文件的使用",
    "tags": [
      "安卓",
      "UI设计"
    ],
    "title": "2-1.Toolbar工具栏",
    "uri": "/class/2.androidstudio/toolbar/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: B3-课堂笔记",
    "uri": "/categories/b3-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: UI设计",
    "uri": "/tags/ui%E8%AE%BE%E8%AE%A1/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r博客文章",
    "content": "**声明：**需要注意文章只提供思路，当处理一些复杂问题时可能需要变换思路，所以请根据自身情况选择是否阅读本篇文章。\n因本人没学过go语言，所以大部分代码都交由AI编写，不排除代码可能存在隐患。\n接下来我以自己使用的hugo-theme-relearn主题为例，讲解如何自定义康奈尔笔记页面输出格式。（hugo-theme-relearn主题）\n工程目录结构 your-blog/ ├── archetypes/ │ └── cornell-notes.md # 笔记原型模板 ├── layouts/ │ ├── cornell-notes/ │ │ └── views/ │ │ └── article.html # 页面布局模板 │ ├── partials/ │ │ ├── cornell-notes.html # 内容输出逻辑 │ │ └── custom-header.html # 自定义样式表 │ └── shortcodes/ │ ├── cues.html # 左侧标签短代码 │ ├── notes.html # 右侧内容短代码 │ └── summary.html # 底部总结短代码 └── static/ └── images/ └── cornell-img/ ├── icon1.svg # 右侧装饰图标 ├── icon2.svg # 左侧装饰图标 └── watermark.jpg # 底部背景图\r功能实现全流程 具体需求 我想输出一个左侧写标签，右侧写内容，最底下显示写总结的“康奈尔笔记”页面，使用命令：\nhugo new --kind cornell-notes learning/algorithm/_index.md\r创建.md文档后，md文件自动展示为如下格式：\n+++ title = \"{{ replace .Name \"-\" \" \" | title }}\" type = \"cornell-notes\" date = {{ .Date }} draft = true +++ {{% cues %}} 写标签区域 {{% /cues %}} {{% notes %}} 写内容区域 {{% /notes %}} {{% summary %}} 总结区域 {{% /summary %}}\r当识别到短代码{{% cues %}}时，将{{% cues %}} {{% /cues %}}中的内容显示在标签一侧，剩下的依次类推。\n样式定义 注意：假设自己的主题目录为your-blog,那么接下来的文件创建都该目录下，可参考目录结构。\n创建 layouts/partials/custom-header.html（遇到没有的目录或文件请自行创建，下同，所以不再提示！！）\n\u003cstyle\u003e /* 康奈尔笔记容器 */ .cornell-notes { padding: 20px; margin: 15px 0; display: flex; flex-wrap: wrap; background: #f9f9f9; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } /* 左侧标签区 */ .cues { background: url('/images/cornell-img/icon2.svg') no-repeat 95% 20px; border-right: 2px dashed #ccc; flex: 1; padding-right: 25px; min-width: 250px; } /* 右侧内容区 */ .notes { background: url('/images/cornell-img/icon1.svg') no-repeat 5% 20px; border-left: 2px dashed #ccc; flex: 2; padding-left: 25px; min-width: 300px; } /* 底部总结区 */ .summary { width: 100%; clear: both; padding: 20px; margin-top: 20px; background: url('/images/cornell-img/watermark.jpg') center/cover; border-radius: 6px; position: relative; } /* 响应式适配 */ @media (max-width: 768px) { .cornell-notes { flex-direction: column; } .cues, .notes { border: none; padding: 15px 0; } } \u003c/style\u003e\r短代码开发 ​1.​左侧标签区​​ (layouts/shortcodes/cues.html):\n{{ $scratch := .Page.Scratch \u003e}}\r{{ $scratch.Set \"cuesContent\" ( .Inner | markdownify ) }}\r2.右侧内容区：(layouts/shortcodes/notes.html):\n{{ $scratch := .Page.Scratch }}\r{{ $scratch.Set \"notesContent\" ( .Inner | markdownify ) }}\r3.底部总结区：(layouts/shortcodes/summary.html)：\n{{ $scratch := .Page.Scratch }}\r{{ $scratch.Set \"summaryContent\" ( .Inner | markdownify ) }}\r页面样式 创建页面样式 layouts/partials/cornell-notes.html：\n\u003cdiv class=\"cornell-content\"\u003e /*{{/* 初始化存储空间 */}} {{ .Scratch.Delete \"cuesContent\" }} {{ .Scratch.Delete \"notesContent\" }} {{ .Scratch.Delete \"summaryContent\" }}*/ {{/* 触发短代码解析 */}} {{ $dummy := .Content }} {{/* 结构化输出 */}} \u003cdiv class=\"cues-section\"\u003e {{ with .Scratch.Get \"cuesContent\" }} \u003cdiv class=\"cues-header\"\u003e📌 关键标签\u003c/div\u003e \u003cdiv class=\"cues-body\"\u003e{{ . | safeHTML }}\u003c/div\u003e {{ else }} \u003cdiv class=\"warning\"\u003e⚠️ 未检测到标签内容\u003c/div\u003e {{ end }} \u003c/div\u003e \u003cdiv class=\"notes-section\"\u003e {{ with .Scratch.Get \"notesContent\" }} \u003cdiv class=\"notes-header\"\u003e📝 学习记录\u003c/div\u003e \u003cdiv class=\"notes-body\"\u003e{{ . | safeHTML }}\u003c/div\u003e {{ else }} \u003cdiv class=\"warning\"\u003e⚠️ 未检测到笔记内容\u003c/div\u003e {{ end }} \u003c/div\u003e \u003cdiv class=\"summary-section\"\u003e {{ with .Scratch.Get \"summaryContent\" }} \u003cdiv class=\"summary-header\"\u003e✨ 学习总结\u003c/div\u003e \u003cdiv class=\"summary-body\"\u003e{{ . | safeHTML }}\u003c/div\u003e {{ else }} \u003cdiv class=\"warning\"\u003e⚠️ 未检测到总结内容\u003c/div\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e\r页面内容输出逻辑 创建 layouts/cornell-notes/views/article.html：\n\u003carticle class=\"cornell-notes\"\u003e {{ partial \"cornell-notes.html\" . }} \u003c/article\u003e\r此处就是系统将自动调用了我们之前写的layouts/partials/cornell-notes.html文件，将内容输出到这个容器中。\n实际效果如下： 为了丰富页面你可以设置标题、页脚等显示样式，这些你使用的主题一般会提供，如我这里的：\n\u003carticle class=\"cornell-notes\"\u003e \u003cheader class=\"headline\"\u003e {{partial \"content-header.html\" .}} \u003c/header\u003e {{partial \"heading-pre.html\" .}}{{partial \"heading.html\" .}}{{partial \"heading-post.html\" .}} {{partial \"cornell-notes.html\" .}} \u003cfooter class=\"footline\"\u003e {{partial \"content-footer.html\" .}} \u003c/footer\u003e \u003c/article\u003e\r代码说明如下（都是基于我使用的主题，可不看）：\n1.从上而下，article容器的class值为cornell-notes，这个值在layouts/partials/custom-header.html中，这是之前编写页面布局时写的，此处调用该cornell-notes样式：\n\u003carticle class=\"cornell-notes\"\u003e\r2.编写内容顶栏代码，如果项目未提供就自己创建一个，同样放地，放在layouts/partials/custom-header.html中，因此次使用主题自带故不再创建。当然，你也可以选择不写。\n\u003cheader class=\"headline\"\u003e {{partial \"content-header.html\" .}} \u003c/header\u003e\r对于标题设置：\n{{partial \"heading-pre.html\" .}}{{partial \"heading.html\" .}}{{partial \"heading-post.html\" .}}\r页脚设置：\n\u003cfooter class=\"footline\"\u003e {{partial \"content-footer.html\" .}} \u003c/footer\u003e\r依实际需求而定，可写可不写。\n3.总而言之，如果你只是输出之前需求的页面，那么可以只写这句代码：\n\u003carticle class=\"cornell-notes\"\u003e {{ partial \"cornell-notes.html\" . }}//就加了这句 \u003c/article\u003e\r{{ partial \"cornell-notes.html\" . }}这里就是去调用我们之前写的layouts/partials/cornell-notes.html文件，将内容输出到这个容器中。还记得吗?这个文件是我们写完短代码后写的文件，目的是将内容按照要求输出。\n原型模板创建 我们在创建页面时，如果使用命令：\nhugo new --kind cornell-notes log/cornell-notes/_index.md\r这个命令会自动创建一个archetypes/cornell-notes.md模型的文件，实现这一操作你需要先创建layouts/cornell-notes/views/article.html，这一操作在上面已经完成，接下来只需要创建archetypes/cornell-notes.md文件即可。值得注意的是无论是命令、还是layouts、archetypes文件下，都提到了cornell-notes这个名字，所以创建时留意名字需要相同。\n这里小结这一思路：\n在layouts/[fileName]/views/article.html中编写页面输出逻辑。 在layouts/[fileName].md中编写文件模版 使用命令hugo new --kind [fileName] [path]生成模版文件 接下来是详细操作：\n1.创建archetypes/cornell-notes.md文件：\n+++ title = \"{{ replace .Name \"-\" \" \" | title }}\" type = \"cornell-notes\" date = {{ .Date }} draft = true +++ {{% cues %}} 写标签区域 {{% /cues %}} {{% notes %}} 写内容区域 {{% /notes %}} {{% summary %}} 总结区域 {{% /summary %}}\r2.使用方式\n​​生成模版文件​​：\nhugo new --kind cornell-notes learning/algorithm/_index.md\r实际效果图：\n需要注意的是写模版文件的时候是依据你个人需求而定的，例如创建layouts/[fileName]/views/article.html这样的文件，在有些主题可能是layouts/partials/[fileName]/article.html，又如，此处md文件头部模版为：\n+++ title = \"{{ replace .Name \"-\" \" \" | title }}\" type = \"cornell-notes\" date = {{ .Date }} +++\r而有些则是以：\n--- title = \"{{ replace .Name \"-\" \" \" | title }}\" archetype = \"cornell-notes\" date = {{ .Date }} ---\r旨在告诉你编写形式各不相同，所以清楚这一思路即可。要避免这些坑请结合主题的说明文档帮助查看。\n总结 最后的最后做个总结，要想自定义hugo主题页面输出格式，你可以按照如下步骤展开：\n确定需求，不会写代码让AI完成。 如果有需要请编写段代码。 编写输出逻辑，如果不会还请求助社区、AI等。 编写页面模板，参照以上思路，同时参考自己hugo主题的文档说明",
    "description": "有时候需要自定义或在别人的基础上修改页面输出格式，有时候我们缺少的是一种思路，本篇文章就是提供一个清晰的思路，让你可以快速编写出自己的页面。",
    "tags": [
      "Hugo",
      "主题",
      "页面输出格式"
    ],
    "title": "10.如何自定义hugo主题页面输出格式？",
    "uri": "/log/10.%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89hugo%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r课程",
    "content": "组件协作 模板方法-template method 在C语言代码编写中主函数调用常调用库函数，进行功能实现。那么现在面向对象编程中，可以选择在库中调用未来写在主函数中的函数，这个设计方式就叫template method（个人的理解，不是定义）。举个例子，假设有一个lib.h的库，里面写了画圆的步骤，主体框架已经在rung()中写好，但是还有一个函数没用写，该函数是用来指定圆的半径等参数的，这个函数用virtual修饰，在未来主函数中可以继承该类并重写这个函数，最后在调用lib.h库里的run()即可。\n在这里画圆的框架以及步骤已经规定好，也就是稳定的，而圆的半径是变化，使用以上方法就把稳定与变化分开，这也是设计模式的核心要点之一。例子粗糙但已经能说明该设计模式了\n前一过程称为早绑定，后一过程称为晚绑定。\n策略方法-strategy 如下图是该方法的结构图。 该方法是为了应对未来的需求，这在业务就很常见，在未来会增加业务的功能，主要体现在代码运行时，假设现在有三种算分分别对应三种不同的情况，在运算时需要对不同的算法做不同的处理，以往我们会使用if-else或Switch-case，但是当情况不是三种或未来增加时，后者的代码会变得冗长，也不好维护，现在我们可以把三种情况对应的算法继承一个基类中的virtual修饰的方法，并重写这个方法。在运行处通过上下文调用对应的算法。",
    "description": "组件协作 模板方法-template method 在C语言代码编写中主函数调用常调用库函数，进行功能实现。那么现在面向对象编程中，可以选择在库中调用未来写在主函数中的函数，这个设计方式就叫template method（个人的理解，不是定义）。举个例子，假设有一个lib.h的库，里面写了画圆的步骤，主体框架已经在rung()中写好，但是还有一个函数没用写，该函数是用来指定圆的半径等参数的，这个函数用virtual修饰，在未来主函数中可以继承该类并重写这个函数，最后在调用lib.h库里的run()即可。",
    "tags": [
      "设计模式（C++）"
    ],
    "title": "19.设计模式（C++）",
    "uri": "/class/19.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc%E5%8A%A0%E5%8A%A0/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: Hugo",
    "uri": "/tags/hugo/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说",
    "content": "晚上八点。\n在西蚌县中学旁有一家名叫茶味浓浓的奶茶店，生意不错。这一天晚上来了一位顾客，她披着长发，身穿个蓝色卫衣，双手插在卫衣兜里，有些哆哆嗦嗦，进店后长发还飘着一丝丝白雾，那动人的眼眸来回扫过菜单，久久没有点餐。\n“你好，来杯大杯的蜜桃乌龙，常温。”最后姑娘说道。\n“好的，”店员回答道：“9块，这里支付。”\n姑娘拿出手机，扫码支付后，接过小票，掺了会儿又踹在兜里，不一会店员将点好的奶茶打包，递给了姑娘。姑娘出了店门后，又再次回来点了一份相同的。\n冬季西蚌县街道上，虽无雪，但榕树早已因冽风左右摇晃，似乎也在哈气搓手。姑娘离开店后往学校的后门走去，刚要过马路突然来了个电话，她接起电话。\n“喂，妈，咋个了。”\n“大晚上，跑哪点儿去了？”\n“在外头，学校这边。”\n“跑哪点克干嘛哦，今天不上学了嘛……回你姨娘家来……看小弟小妹了我克刘伯家。”\n“好嘛，我现在回来。”\n挂断电话后，退回路边拦下了来往的三轮车，她道：“师傅，去新开发区多少钱？”\n“8块。”\n她觉着有些贵了便于师傅讨价还价，最后车费砍为6.5元。\n西蚌县的新开发区是最近几年发展起来的，新建的小区多是建档立卡贫困户，他们搬到了县城，许多人在这开始了新生活，而有些人则选择留在乡下，同时政府也协助他们改造楼房。\n三轮车行驶到一小区停下，姑娘付款后在小区前来回踱步，最后发了一条消息。\n随着手机消息想起，仲晨星放下手中的药，点开手机一看。\n屠娘娘：我在你家楼下，有事找你。\n“屠娘娘”是他给璐玲的备注，玲是晨星在高中认识的同班同学，他们认识两年多了，对玲的短信晨星有些意外，他吃药后便提衣下了楼。\n等了稍许，依旧不见玲，他暗想:这家伙不会耍我吧，搞什么啊！正想着便掏出了手机……\n此时已八点三十五分。\n晨星见电话接通，便道：“哎！璐玲娘娘，不说在楼下吗？人呢!”\n不巧此举被提着奶茶的璐玲看见了，她走了过去，打了声招呼笑了笑，又道：“让你久等喽！”\n晨星心一颤，一回头一看是玲，血液瞬间似滚滚黄河，他不解地问道：\n“大姑娘家的那么晚出来？你家不在这附近吧！”\n“怎么了，有什么问题？”玲反问道，面色从容的玲此刻却显得有些为难，接着补充道，“我家在这下面不远的。”\n“这样的？”\n“前几个星期搬的，贫困户搬迁嘛!你以为我会大老远来找你，你……”本来还想说句“你想多了”，但想想现在也不适合，便作罢了。\n“OK，OK!所以，找我什么事捏？”晨星追问道。\n“这，有事才能找你，没事就不可以找你，聊聊天啊之类的吗？”\n“那倒不是。”晨星一手揣在衣兜，说道，“不过你拿着奶茶，怎么，要请我喝啊？”\n“少来，这是我妹和我弟的。”玲快速的回答道。\n她又继续补充道：“不过放心我有别的好东西给你。”\n淡黄的灯光在白衣的反射下，她犹如宝石般耀眼夺人，微风拨动细发，脚步停了，目光也停在了她掏出的手机上，唯有拇指在手机上不停舞动。微微见到她输入了几个数字后，手机便一脸黑，这让晨星更好奇她会给自己什么东西。\n未等晨星回过神，一个小礼盒挡住了他的视线，正当他要开口：这什么呢？礼盒已递到了他手边，她道：“生日快乐!晨星。”\n这一句如露水滴入花瓣，如花瓣掉入清池，传入他的耳膜，顿时这声音山谷传响，来回响彻晨星的全身。\n一切都来得太快，这让他一时间不知道说什么，晨星嘴唇一紧，一松牙齿冒出了白气，他说：“呀，搞错了吧！今天哪是我生日……”\n在稍早些的时候，晨星买了一个圆面包，一包干脆面，一包辣条来作为自己的生日蛋糕了，晨星的朋友方建端，倪力和泰明获在回宿舍时，见到三根辣条插在面包上，中间还夹着一块干脆面。\n“晨星，今天你生日莫？”建端一脸疑惑地问他。\n“不是啊!这是我弟弟的……我弟今天生日。”晨星连忙称道。\n“你还有弟？”明获一脸的浓眉，加上那方眼镜框，这么问起来像询问犯人似的。\n顿时房间一股审讯的气息。\n“你不是只有两个妹妹吗？之前说的噶。”倪力说道。\n“这是我表弟啦！”接着晨星拿起手机，拍了自制的蛋糕，还打上“嘿！老弟，生日快乐!”发到了QQ空间。\n对这种事情建端也是见怪不怪，只好不在问什么。\n“那你还不如，直接送个蛋糕给他，那不好过吗，或者别的礼物啊！”明获说道。\n“就是喽！”其他二人也应和道。\n“他在乡下嘛!我也是这几天才知道他生日，没办法的事。”晨星解释道。\n“空降蛋糕给他了喂。”倪力这一说倒是引得众人一阵哄笑。\n尴尬气氛突然上来，玲知道时间紧迫，她道：“纸条，上次你传纸条了的。”\n玲是知道晨星生日，记得一次自习课，玲就叫晨星写生日日期，传纸条给她。\n“还有这种事？”\n“本来今天早上下课要跟你说的……可课间，还有好多笔记要抄，所以……”\n“那纸条写的是我弟的生日，你没看到今天我在QQ空间发的吗？”晨星说道。\n今天是周末，早上放学时同学们都急着回家，各各挣着交了作业，玲坐在第二组第二桌，她想把写好的作业递给讲台上的同学，但叫了几声没人理，玲准备出来，就在这时一个身影从他身边走过。\n“给我吧！”晨星似一种有意无意的语气夺过她的作业。\n本来是个好的举动，但终是成了“有心栽花花不开，无心插柳柳成荫。”\n在拿上去时，晨星面无表情，回来时对玲冷眼相待，似有意而为之，谁看了谁都觉得不对劲，当局者和旁观者也说不出个原因。在玲看来，这就是一种信号——今天我生日，想想我以前是怎么送你礼物的。\n想到这晨星内心一震一震的，他似乎后悔说了这句话。\n玲带有道歉之意，说道：“祝福也许会迟到，但它永远不会缺席。”\n他这一说晨星心一寒，心似乎陷了个窝，有种不可抗拒的力似乎在让他接受着事实。\n晨星小心翼翼地接过礼物，道：“哎呀，此情此景真是让人激动得睡不着觉啊！”\n“还说不是你生日，我就说嘛！怎么会记错。”玲笑这说，接着催促道，“快，快，快打开!”\n“什么，打开，现在吗？”陈星问道，“一般礼物不是要回家才打开吗？”\n“叫你打开，你就打开嘛！我有事和你说，我怕我待会搞忘，再说了……”她往前望了望，接着说：“你家不就在这小区吗，差不多啦！”\n晨星一脸坚决，快速道：“我不!”\n玲一手捏了晨星胳膊，接着就是小袋子一打，晨星接连苦叫，晨星一边说：\n“好，好好！我开，我开。”\n一边怀着期待打开盒子，盒子里蹦出一只白色的纸鹤，纸鹤叼着一张纸，纸上写着生日礼物取件码：2-9-7755。\n取件码？晨星不禁想来句：我嘞个去!\n“拿出手机，快点。”\n晨星不敢抗议，照着做，看着玲在手机上输入着什么。\n“你九键打得很溜嘛”晨星瞥了她一眼说道。\n“像你用26键这么慢——我这个一是快，二是习惯了。”\n随着玲点击发送，晨星的手机发出“滴”的一声，晨星细看一个红包，他顿时内心波涛汹涌，海浪滚滚，气血的红鱼在血管中不断加速游动，手一颤一颤。\n玲见他没动静，道：“哎，你倒是点开呀!”\n晨星知道玲的意思，他本不想打开，但领红包的习惯似乎早已根深蒂固，玲又这么说，不经意间，手机发出一声清脆的“嘟”的震动声。\n“怎么还有……这红包怎么还有密码？”\n“看你，平时不是挺机灵的吗，现在反倒犯蠢了，刚才不给你密码了吗？”\n晨星哦了一句后输入了密码，他一看2.9映入眼帘，他内心调侃道：2.9，怎么这么少啊！这也太扣了门了。\n玲调整了一下语气，道：“知道为什么，送你两块九吗？”\n晨星半天隔不出个“屁”来。\n玲道：“那我说喽!”\n晨星直接打断，道：“等等，让我想想……”\n她闭着眼睛，头示意可以。\n晨星快速进入思考状态，是什么呢，究竟是什么呢？一定可以想到，一定可以想到的，让我想想……唉！什么鬼吗，猜不到嘛！对了，对了，“520”五是我，二是爱，零是你，那这样的话2.9不就是——爱久!这个意思？对了还有小数点，难道是爱得久，小数点是的、得等意思？晨星一脸懵“爱得久”，这……这莫非是——表白!不是吧，不是吧!不可能，玲不可能这么做的吧……\n“怎么样，好没？”\n“嗯，好了，那我说啦。”他深深吸一口气，道：“爱得久。”\n“什么？”玲皱着眉头道。\n“你爱久。”晨星对答案相当自信地道，这答案差点把玲笑死，但看起来很艰难，是在强笑吗？\n“什么嘛!你你小子一天天的在想什么。”\n二人皆哈哈大笑。\n“好了，刚才和你开玩笑的，真想不出来。”晨星道。\n“行行行，要不……”玲正要接着说，电话打断了她，她接电话回来后，接着说道，“以后有时间再和你解释吧，总之肯定不是你想的那样……可以给你一点小提示，这个是和你有关的数字的。”\n“和我有关？和我有关你发这么少，合着我就只能有两块九。”\n玲拿起贷子又是一锤，道：“想什么呐你，我可是诚意满满的!”\n星晨哈哈大笑……\n“玲，”晨星道：“谢谢你哈，你是第一个对我说生日祝福和送我礼物的人。”\n又刮了一道风，风吹在他们脸上，玲长发随风飘动，打乱了她的视线，玲撩着头发，晨星揉着眼睛。其实晨星应该加个时间——今年，但这样的情况他不再需要严谨。\n“怎么了？”玲道。\n“哦，风吹到眼睛里了。”这是撒谎，但玲不会知道的。\n“唉，这生日都不够正式，时间都过了才说的，早知道就不交手机了……哎！”\n每到学校，都会有一部分同学把手机交给老师保管，在周末在拿回来，但恰巧这周末老师下乡扶贫，钥匙也没交给班里的同学，以至于这周一些同学都没得到手机，玲没辙，只好请自己的卡顿手机“出山”。\n“哦哦，老班去扶贫那事对吧……没事，没事，这个生日礼物我很满意。”他接着道：“另外，你送的这礼物方式真是送礼物史上的一朵奇葩，一定会被载入送礼物奇葩史的。”\n玲听了觉得有点不对劲，道：“你什么意思嘛！我这叫创意，是被载入创意史，什么奇葩史……”\n“其实你直接发红包给我就好了!这样就不用麻烦你跑一趟啦。”\n“还不是因为你之前都是当面送我的。”\n“啊！我那个不算什么礼物的，折几张纸，写几句鸡汤语录而已。”\n去年6月13日，晨星分到玲的班级，建端下午放学吃完晚饭后，突然告诉晨星，“今天是我表姐生日唉！我什么都没准备，完喽！”\n“璐玲的生日？那我也没准备唉。”晨星回答道。\n二人商讨后，想着校外面去不了，买礼物是不可能了，送点学校小卖部的零食似乎又欠缺什么，思来想去建端还是觉得到时候周末补一个红包，但晨星却似乎打着誓死要送你个别致的礼物给玲，建端劝他没有必要，他本来也是放弃，但看到其她女生一个个对着玲说生日快乐时，他还是决定要做一个礼物，于是她找来几张纸折了一个纸船，在上面写下了对玲的寄语，同时还设计了从不同方向看，表达不同意思的文字，最后又以不同的角色写了六封信，这六个角色是在他们的中二病宫廷场景中才会出现，但这往往只有中二病未毕业的晨星见到那些角色。其他人虽已毕业，但也不反感与晨星共同融入这个故事，共同书写他们的宫廷日常。\n做完这些后，晨星又作了一首诗名《铃途芳辰赋》，诗曰：“路转溪桥鹤唳清，铃檐碎玉和风鸣。生来云翼披霞色，日暮携春踏月行。”\n“那可不是什么鸡汤语录，什么侍女，小宝，王太傅，皇上，皇后等等他们的信我还留着呢，就是你的诗我一直不知道什么意思。”\n“既然是生日那天送，当然是跟生日有关的啦！”\n“我只知道那是藏头诗其他的一概不知了。”玲微微一笑说道。\n玲看了看晨星许久，侧下头，道：“你要记得每天开开心心哈！”\n“我哪天不开心？”晨星两手揣衣兜，一摇一摆，微微笑道。\n“你看，星谐音高兴的‘兴’，也就是高兴的含义，晨意思是早上，我们在拓展一下，它的意思可以是每天，所以晨星就是‘每天都开开心心’”\n“这晨还可以翻译成‘每天’？你这是语文老师说的，过度解释！”晨星调侃道。\n“你管我，就是这意思。”玲道接着说道，“不知道为什么，激动得想睡觉了!”\n“刚才是不是家人叫你回家啊？”玲点头后，晨星接着说，“多谢你的生日礼物，你也早点回去吧！”\n告别玲后，晨星站在原地，他看了看手机，已经九点了，晨星环顾四周，又望了望天空，不知为何他无法释怀。\n回到家后他才注意到原来纸鹤里面还有一个小巧的手办，看到这他觉着自己当初送的礼物逊色太多了，他便开始盘算着以后送玲什么礼物好呢？\n那后的很长时间里，他和玲似乎都忘记了那串未解释的取件码，两人闹掰后，那串数字仿佛被封存在了时间里。\n一天晨星用自己弟弟的手机给建端发送生日祝福，发现弟弟的手机竟然使用九键，他在打出建端后，连续输入了SRKL，随着生日快乐出现的同时，一段记忆开始被抽拉出来，他又连续输入了两遍，对照着九键上面的数字，发现SRKL对应着数字7755，或许别人不会在意这数字，但对于晨星而言，随着记忆的展开，此时此刻他没有办法注意不到，他又输入了自己晨星的拼音，果然如他所料，字母C和X对应2和9，晨星心中似乎有一块大石头沉落海。\n他心想，这次终于是输对了取件码，那半个钟的礼物我算是收到了吧！",
    "description": "这是一个发生在寒冬夜晚的青春校园故事。西蚌县高中生仲晨星在生日当晚，意外收到同班同学璐玲送来的特殊礼物——奶茶店相遇、密码礼盒与暗藏玄机的2.9元红包，揭开了两人长达两年的微妙情谊。当贫困搬迁户出身的璐玲在冷风中送来手工纸鹤礼盒，用九键输入法暗藏姓名密码时，这场充满少年心事的生日惊喜，却在误会与时光中尘封。直到多年后晨星偶然破解数字密码，才真正接收到那个雪夜未曾领会的少女心意",
    "tags": [
      "校园",
      "青春",
      "爱情"
    ],
    "title": "半钟礼物",
    "uri": "/story/%E5%8D%8A%E9%92%9F%E7%A4%BC%E7%89%A9/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 博客搭建",
    "uri": "/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说 \u003e \r小说下载橱窗",
    "content": "附件\r《周易入门》曹胜高 刘银昌.mobi (4 MB)\r袁堂欣 - 易经-华艺出版社 (2010).epub (304 KB)\r知行合一王阳明套装（共3册）.azw3 (1 MB)",
    "description": "描述文章内容",
    "tags": [],
    "title": "国学经典",
    "uri": "/story/%E5%B0%8F%E8%AF%B4%E4%B8%8B%E8%BD%BD%E6%A9%B1%E7%AA%97/%E5%9B%BD%E5%AD%A6%E7%BB%8F%E5%85%B8/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 青春",
    "uri": "/tags/%E9%9D%92%E6%98%A5/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说 \u003e \r小说下载橱窗",
    "content": "附件\r败犬女主太多了!.epub (6 MB)",
    "description": "描述文章内容",
    "tags": [],
    "title": "轻小说",
    "uri": "/story/%E5%B0%8F%E8%AF%B4%E4%B8%8B%E8%BD%BD%E6%A9%B1%E7%AA%97/%E8%BD%BB%E5%B0%8F%E8%AF%B4/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 设计模式（C++）",
    "uri": "/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc\u0026#43;\u0026#43;/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说",
    "content": "天地初开时，赤色岩浆还在大地上蜿蜒流淌。女娲捏土造人的青烟尚未散尽，西王母的玉簪已划出天河沟壑。当三皇五帝执掌的人间迎来首个太平年岁，南疆密林深处，焚天烈焰正灼烧着部族征伐的狼烟。\n驩兜折断第十支青铜矛时，看见了终生难忘的奇景——赤红雀鸟自祭坛烈火中化出人形，赤足踏碎满地血污。苗疆最勇猛的战士放下染血的石斧，看那朱雀神女指尖轻点，战场上枯萎的曼陀罗竟重新绽放。\n“炎黄部族收容百川，南蛮勇士可愿共举大旗？“黄帝使者递来的龟甲契约还沾着兽血，驩兜却在朱雀眼底的火光里望见了另一种可能。他率三千藤甲兵北上的那日，神女化作朱红雀鸟，尾羽扫过的焦土生出漫山凤凰花。\n涿鹿之战的第七个满月，蚩尤的玄铁箭矢穿透朱雀左翼时，驩兜正深陷重围。当神鸟哀鸣震落九霄流火，这个能徒手撕裂犀牛的男人，竟用身躯为朱雀筑起最后屏障。他们在染血的凤凰花海里找到二人时，驩兜的青铜甲与朱雀的尾羽早已熔作赤金结晶，包裹着微微起伏的胸膛。\n百年后南疆流传起一桩奇闻：每逢月圆之夜，赤红雀鸟会驮着银发女童掠过十万大山。那孩子发间别着半片青铜甲，眨眼时瞳孔流转赤金灵纹，说起话来能让枯木抽新芽。\n“小凤凰，给本尊当坐骑可委屈你了？“扶桑大帝抚着断角青牛，戏谑地看着跪在云端的少女。翎凤攥紧袖中那片父亲遗留的青铜甲，抬头笑得眉眼弯弯：“若帝君允我每月归乡三日，便是天天被雷部仙官当箭靶也使得。”\n九重天从此多了道朱红流影，总伴着清脆铃音穿梭于三十三宫。当翎凤第一千次躲在蟠桃园偷望人间时，鬓角银铃忽然被月光染成霜色——那夜她学会了一个道理：神仙的眼泪坠入云海，会化作南疆经年不熄的凤凰火。\n赤红天穹裂开十道金痕时，羿的箭囊里还剩九支龙骨箭。第十个太阳在云层后狞笑，炙烤得龟甲上的占卜裂纹都蜷曲起来。他咬破舌尖将血抹上箭翎，弓弦震响的刹那，看见九轮烈日化作狰狞巨兽——缠雷的螣蛇、负山的屃屃、吞海的蒲牢……每只妖兽坠地时都在嘶吼同一个名字：椒图。\n当最后一支箭穿透螭吻咽喉，这个曾单手扼死修蛇的汉子踉跄跪地。箭簇沾染的神兽血在沙地上蜿蜒成河，倒映出昆仑山巅西王母的玄色裙裾。\n“想要什么？“神女的玉簪掠过羿龟裂的嘴唇，他眼前浮现出嫦娥夜夜纺织的油灯。茅屋漏风时，妻子总用脊背替他挡住霜雪，如今那截伶仃的脊椎怕是已弯成煮茧的竹弓。\n“但求人间再无哀嚎。“羿将喉头的血腥气咽成铿锵誓言。西王母却轻笑掷来两枚月光凝成的药丸，那清辉刺痛了他生满冻疮的手——昨夜嫦娥正是握着这双手，将省下的黍米粥倒回陶瓮。\n归途的雪夜比射日时更灼人。药丸在兽皮袋里发烫，烫得他想起妻子少女时的眼眸。林间突然炸响的鸦啼中，曾被射杀的大风鸟魂破土而出，骨翼掀起的飓风里裹着万千冤魂的呜咽。\n羿眼睁睁看着一枚仙药坠入冰河，碎成漫天流萤。恍惚间见黑袍仙人手持紫金葫芦收走妖魂，却不及抓住一缕萤光。他跪在结冰的河面疯刨，直到十指白骨森森，才惊觉冰层下映出的，是自己早生华发的狰狞面容。\n茅草屋的蛛网在月光里泛着银辉，羿解开兽皮囊的瞬间，两枚琉璃似的药丸滚入嫦娥掌心。她听着丈夫讲述昆仑山的风雪，指腹摩挲着药丸上细密的神纹——像极了织机上将断未断的蚕丝。\n当第一缕晨光刺破窗纸，慕名者已挤塌了竹篱。有背负青铜剑的侠士在院中舞出漫天寒星，有披着虎皮的猎户献上千年参精，更多人的眼睛却黏在嫦娥腰间药囊上。逢蒙送来麂子肉那日，粗粝的手指\"不小心\"擦过药囊系带，嫦娥颈后的汗毛在秋风中根根倒竖。\n第七个满月夜，尧帝的传令铜符撞碎了蝉鸣。羿前脚刚跨过门槛，后脚便传来陶瓮碎裂的脆响。嫦娥将药囊塞进灶膛的动作慢了半拍，逢蒙的青铜护腕已卡住她咽喉。两人在满地粟米间翻滚时，药丸沾了灶灰，嫦娥突然想起昨夜丈夫梦中呓语：“这仙药该用晨露送服…”\n腥甜的血液在齿间迸开，嫦娥生生咽下半枚药丸。逢蒙的巴掌扇得她撞向织机，飞溅的血珠在窗纱上晕出点点红梅。当染血的木椅砸中逢蒙后颈时，剩下的半枚药丸正巧滚进她袖中暗袋。\n“贱人！“逢蒙的斧风劈裂织机，嫦娥在翻飞的蚕丝里吞下完整的半枚。霎时月光如潮水漫进七窍，她飘起时看见逢蒙扭曲的脸正在下方缩小，而自己发间银簪正化作千缕流云。\n羿归来时，染血的蚕茧还在梁间摇晃。他捡起地上半片染着蓝血的药壳——那是西王母药匣特有的昆仑玉髓，此刻却嵌着嫦娥的半片指甲。\n螭吻的龙尾扫过人间茶馆瓦檐时，正听见说书人拍响惊堂木。那老者唾沫横飞地比划：“要说那嫦娥娘子，定是被九头鸟掳去当了压寨夫人！“酒肆醉汉却摔碗大笑：“分明是嫌后羿那莽夫不懂风情，带着仙药找小白脸去了！”\n龙爪捏碎茶肆幌子的瞬间，螭吻忽然嗅到一丝熟悉的气息——昆仑玉髓混着凡尘烟火，正是那日羿射落的仙药味道。他化出人形直奔广寒宫，却在穿越九重天时被罡风撕下半片龙鳞。月宫门前挂着的新匾还泛着桐油味，守门的玉兔却说他来晚了整整三个甲子。\n“仙籍上写着呢，嫦娥仙子是月母失散的小女儿。“司命星君捋着白须，看着西王母将凤钗插入云鬓，“情根未净者，当不得正神。”\n嫦娥赤足踏上月阶时，吴刚的斧头正卡在桂树第七道年轮里。这个沉默的伐木人突然扔了斧柄，用生满老茧的手捧起她一缕散发——那发丝在触到他掌心的瞬间，竟开出细小的桂花。\n“我的儿啊！“月母的泪珠坠地成霜，凝成案上那盘嫦娥最爱的荷花酥。当雪白兔儿跳进怀中时，嫦娥发现它琉璃似的眼珠里，竟映着人间某个茅屋前的歪脖子枣树。\n月桂的冷香第七次染透窗纱时，嫦娥忽然捏紧了怀中玉兔。琉璃瓦上映出的兽影正扭曲变形——螭吻的龙角刺破月华，鱼尾扫过处冰晶迸裂。她抱着玉兔急退时，整座望乡楼轰然坍作万千冰棱。\n“月宫岂容孽畜撒野！“月母的呵斥伴着冰凌倒卷，却在触及螭吻鳞片时蒸腾成雾。嫦娥跌坐在桂树根脉交织的囚笼里，看着吴刚的斧刃在百丈外迟疑——那个魅狐幻化的\"嫦娥”，此刻正倚在他肩头巧笑嫣然。\n翎凤就是在这时踏着南明离火闯入战局的。她发间银铃震碎三丈冰墙，却在看清嫦娥面容时愣怔当场——这张脸竟与苗疆石壁上雕刻的朱雀神女有七分相似。\n“好妹妹，替姐姐守着这个。“嫦娥将玉兔塞进翎凤怀中，自己却迎向螭吻的利齿。谁也没看见她悄悄扯断了腕间红绳，绳上铜钱坠子正巧滚入翎凤袖袋。\n水火相撞的爆鸣声里，翎凤的凤翎剑第三次脱手。螭吻的龙爪扣住她咽喉时，忽然嗅到某种熟悉的气息——那枚铜钱上沾着的，分明是百年前涿鹿战场上的血锈味。\n“朱雀…“龙瞳骤缩的瞬间，翎凤的指尖已戳进他逆鳞。螭吻咆哮着遁入地脉时，桂树根须间忽然睁开千万只血眼——那是被他吞噬的十日残魂，此刻正啃噬着月宫地基。\n赤脚大仙踏入月宫时，琉璃穹顶正簌簌震落星屑。他足底沾着的瑶池仙酿尚未干涸，抬脚便碾碎了螭吻布在门后的噬魂阵。三十三重天的罡风灌进裂缝，卷起嫦娥半幅染血的裙裾。\n“小凤凰，该你落子了。“螭吻的龙爪扣在嫦娥喉间，尾鳍却将翎凤逼至墙角。他故意露出逆鳞处那道陈年箭伤——正是百年前涿鹿战场上，翎凤母亲留下的印记。\n翎凤的指尖在袖中攥紧那枚铜钱，突然轻笑道：“你猜司命星君的命簿上，今日写的是谁魂飞魄散？“话音未落，赤脚大仙的脚影已穿透十二道冰墙。螭吻甩出玉兔挡在身前，却见那兔儿红瞳骤亮，竟化作万千道金线缠住龙尾。\n“接着！“翎凤将铜钱弹向赤脚大仙，自己却扑向嫦娥。螭吻的利齿擦着她后背掠过，撕下半幅绣着木棉花的衣料。当赤脚大仙的足印烙在螭吻脊背时，整个广寒宫都回荡着龙骨碎裂的哀鸣。\n众仙围上来时，翎凤正用那半幅衣料裹住嫦娥伤口。赤脚大仙望着天河边逃窜的龙影，突然抬脚碾碎一枚龙鳞：“这孽障吞过十日精魄，杀不死的。“他的脚底赫然映出半幅河图，月母见状，终于将月轮佩按进翎凤掌心。\n后来天界总传闻，说那堕龙与半神少女在兜率宫斗塌了八卦炉，在瑶池撕碎了百丈锦鲤。可每当值日功曹循着仙迹追查，总见焦土上并排的爪印与足迹，偶尔还夹杂着半片朱雀翎羽。\n扶桑大帝卸任那日，翎凤在月海尽头捡到一截焦黑建木。大帝的袍角扫过三界碑，留下句话：“用花果山的火、青驼峰的泪、石矶山的骨，给那丫头造个望乡台罢。”\n当三十三重天的工匠凿完最后一块星陨石，翎凤正用逆鳞匕在亭梁刻字。刀刃刮落的金粉飘向人间，化作苗疆新一代巫觋的占星盘。她在\"桑扶\"二字间嵌了片龙鳞，转身时撞见螭吻拎着西王母的药匣——里头少了两颗固魂丹，多了抔北冥的雪。\n他们在极光尽头搭了座冰屋。翎凤的银铃震碎极夜时，螭吻总会化出龙尾为她暖脚。直到某天冰屋梁上悬满星屑，翎凤攥着染血的建木碎块，在螭吻逆鳞处刻下\"烛沨\"二字。孩子诞生的那刻，月宫所有玉兔突然面向北方长跪。\n天帝的敕令来得比北冥风暴更急。水神的锁链缠住螭吻龙角时，翎凤正教孩子辨认南疆星图。“娘亲的银铃收好。“她把铃铛塞进烛沨襁褓，转身撞进雷神的诛仙网。最后一瞥看见螭吻震碎半数龙骨，将逆鳞匕钉入孩子掌心。\n桑扶大帝旧部跪满诛仙台时，嫦娥正拆解腕上红绳。她将历代月宫主的记忆凝成珠，趁乱塞进烛沨口中。天帝的判官笔落下时，翎凤的银铃突然响彻三十三重天——那声音竟与当年朱雀陨落时的哀鸣如出一辙。\n“抹去记忆，未尝不是慈悲。“月老剪断烛沨的红线时，孩子银发间忽现赤金瞳孔。北冥的雪暴吞没送遗队伍那刻，谁也没发现烛沨襁褓里渗出一缕朱雀火，正悄悄熔着捆仙索。",
    "description": "上古洪荒，爱恨燃尽三界。神兽朱雀与人族勇士的禁忌之恋，诞下灵慧半神翎凤；凡尘侠侣嫦娥后羿，因长生药掀起宿命波澜；堕天妖兽螭吻与月宫仙子的生死纠葛，更在神规铁律下撕开血色裂痕。当神性、兽性与人性在云端碰撞，那些跨越种族的痴缠，违逆天命的相守，终将星月劈成碎屑，散作照亮永夜的——最灼烫也最温柔的劫灰。",
    "tags": [],
    "title": "示月祈福语",
    "uri": "/story/%E7%A4%BA%E6%9C%88%E7%A5%88%E7%A6%8F%E8%AF%AD/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说 \u003e \r小说下载橱窗",
    "content": "附件\r余华 - 文城 (2021, 北京十月文艺出版社) - libgen.li.epub (471 KB)",
    "description": "描述文章内容",
    "tags": [],
    "title": "文学",
    "uri": "/story/%E5%B0%8F%E8%AF%B4%E4%B8%8B%E8%BD%BD%E6%A9%B1%E7%AA%97/%E6%96%87%E5%AD%A6/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r类别",
    "content": "",
    "description": "",
    "tags": [],
    "title": "类别 :: 小说",
    "uri": "/categories/%E5%B0%8F%E8%AF%B4/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r小说",
    "content": "国学经典描述文章内容\n轻小说描述文章内容\n文学描述文章内容",
    "description": "国学经典描述文章内容\n轻小说描述文章内容\n文学描述文章内容",
    "tags": [],
    "title": "小说下载橱窗",
    "uri": "/story/%E5%B0%8F%E8%AF%B4%E4%B8%8B%E8%BD%BD%E6%A9%B1%E7%AA%97/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 页面输出格式",
    "uri": "/tags/%E9%A1%B5%E9%9D%A2%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"
  },
  {
    "breadcrumb": "技术博客 | 智能物联时代 \u003e \r标签",
    "content": "",
    "description": "",
    "tags": [],
    "title": "标签 :: 主题",
    "uri": "/tags/%E4%B8%BB%E9%A2%98/"
  }
]
