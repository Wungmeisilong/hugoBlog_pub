<!DOCTYPE html>
<html lang="zh" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.145.0">
    <meta name="generator" content="Relearn 7.6.1">
    <meta name="description" content="17.C加加编程15.计算机图形学OpenGL与C&#43;&#43;14.新标准C加加程序设计13.从C到C&#43;&#43;12.其他库的介绍11.STL库学习之适配器10.STL库学习之仿函数9.STL库学习之迭代器与算法8.STL库学习之容器7.STL库学习之分配器6.STL库学习之筑基概要5.STL库之观其大略4.C&#43;&#43;2.0特性的使用3.导读2.组合与继承1.代码编写规范21.C语言程序设计（含面试）1.在线题库练习20.C&#43;&#43;面试1.网络编程1.代码编写规范嵌入式系统设计知识点ArkTS电子电路模拟电子技术基础笔记操作系统Linux期末复习AndroidStudioAndroidStudioAndroidStudio笔记2-1.Toolbar工具栏计算机组成原理过年计算机组成原理-复习51单片机pretues&#43;kiel5仿真软件配合使用时需要注意的地方19.设计模式（C&#43;&#43;）">
    <meta name="author" content="">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="课程 :: Maloudown">
    <meta name="twitter:description" content="17.C加加编程15.计算机图形学OpenGL与C&#43;&#43;14.新标准C加加程序设计13.从C到C&#43;&#43;12.其他库的介绍11.STL库学习之适配器10.STL库学习之仿函数9.STL库学习之迭代器与算法8.STL库学习之容器7.STL库学习之分配器6.STL库学习之筑基概要5.STL库之观其大略4.C&#43;&#43;2.0特性的使用3.导读2.组合与继承1.代码编写规范21.C语言程序设计（含面试）1.在线题库练习20.C&#43;&#43;面试1.网络编程1.代码编写规范嵌入式系统设计知识点ArkTS电子电路模拟电子技术基础笔记操作系统Linux期末复习AndroidStudioAndroidStudioAndroidStudio笔记2-1.Toolbar工具栏计算机组成原理过年计算机组成原理-复习51单片机pretues&#43;kiel5仿真软件配合使用时需要注意的地方19.设计模式（C&#43;&#43;）">
    <meta property="og:url" content="http://localhost:1313/class/">
    <meta property="og:site_name" content="Maloudown">
    <meta property="og:title" content="课程 :: Maloudown">
    <meta property="og:description" content="17.C加加编程15.计算机图形学OpenGL与C&#43;&#43;14.新标准C加加程序设计13.从C到C&#43;&#43;12.其他库的介绍11.STL库学习之适配器10.STL库学习之仿函数9.STL库学习之迭代器与算法8.STL库学习之容器7.STL库学习之分配器6.STL库学习之筑基概要5.STL库之观其大略4.C&#43;&#43;2.0特性的使用3.导读2.组合与继承1.代码编写规范21.C语言程序设计（含面试）1.在线题库练习20.C&#43;&#43;面试1.网络编程1.代码编写规范嵌入式系统设计知识点ArkTS电子电路模拟电子技术基础笔记操作系统Linux期末复习AndroidStudioAndroidStudioAndroidStudio笔记2-1.Toolbar工具栏计算机组成原理过年计算机组成原理-复习51单片机pretues&#43;kiel5仿真软件配合使用时需要注意的地方19.设计模式（C&#43;&#43;）">
    <meta property="og:locale" content="zh">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="课程 :: Maloudown">
    <meta itemprop="description" content="17.C加加编程15.计算机图形学OpenGL与C&#43;&#43;14.新标准C加加程序设计13.从C到C&#43;&#43;12.其他库的介绍11.STL库学习之适配器10.STL库学习之仿函数9.STL库学习之迭代器与算法8.STL库学习之容器7.STL库学习之分配器6.STL库学习之筑基概要5.STL库之观其大略4.C&#43;&#43;2.0特性的使用3.导读2.组合与继承1.代码编写规范21.C语言程序设计（含面试）1.在线题库练习20.C&#43;&#43;面试1.网络编程1.代码编写规范嵌入式系统设计知识点ArkTS电子电路模拟电子技术基础笔记操作系统Linux期末复习AndroidStudioAndroidStudioAndroidStudio笔记2-1.Toolbar工具栏计算机组成原理过年计算机组成原理-复习51单片机pretues&#43;kiel5仿真软件配合使用时需要注意的地方19.设计模式（C&#43;&#43;）">
    <meta itemprop="datePublished" content="2025-04-01T13:27:41+08:00">
    <meta itemprop="dateModified" content="2025-04-01T13:27:41+08:00">
    <meta itemprop="wordCount" content="401">
    <title>课程 :: Maloudown</title>
    <link href="http://localhost:1313/class/" rel="canonical" type="text/html" title="课程 :: Maloudown">
    <link href="/class/index.xml" rel="alternate" type="application/rss+xml" title="课程 :: Maloudown">
    <link href="/class/index.md" rel="alternate" type="text/markdown" title="课程 :: Maloudown">
    <link href="/images/favicon.svg?1744119132" rel="icon" type="image/svg+xml">
    <link href="/fonts/fontawesome/css/fontawesome-all.min.css?1744119132" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/fonts/fontawesome/css/fontawesome-all.min.css?1744119132" rel="stylesheet"></noscript>
    <link href="/css/perfect-scrollbar/perfect-scrollbar.min.css?1744119132" rel="stylesheet">
    <link href="/css/theme.css?1744119132" rel="stylesheet">
    <link href="/css/format-print.css?1744119132" rel="stylesheet" id="R-format-style">
    <link href="/css/auto-complete/auto-complete.min.css?1744119132" rel="stylesheet">
    <script src="/js/auto-complete/auto-complete.min.js?1744119132" defer></script>
    <script src="/js/lunr/lunr.min.js?1744119132" defer></script>
    <script src="/js/lunr/lunr.stemmer.support.min.js?1744119132" defer></script>
    <script src="/js/lunr/lunr.multi.min.js?1744119132" defer></script>
    <script src="/js/lunr/lunr.zh.min.js?1744119132" defer></script>
    <script src="/js/search.js?1744119132" defer></script>
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = ``;
      window.relearn.path='\/class\/';
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..';
      window.relearn.absBaseUri='http:\/\/localhost:1313';
      window.relearn.contentLangs=['zh'];
      window.relearn.index_js_url="/searchindex.zh.js?1744119132";
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=false;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // variant stuff
      window.relearn.themevariants = [ 'auto', 'relearn-light', 'red' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
      // translations
      window.T_Copy_to_clipboard = `复制到剪贴板`;
      window.T_Copied_to_clipboard = `复制到剪贴板！`;
      window.T_Copy_link_to_clipboard = `将链接复制到剪贴板`;
      window.T_Link_copied_to_clipboard = `链接复制到剪贴板！`;
      window.T_Reset_view = `重置视图`;
      window.T_View_reset = `查看重置！`;
      window.T_No_results_found = `找不到"{0}"的结果`;
      window.T_N_results_found = `为"{0}"找到 {1} 个结果`;
    </script>
<style>
  :root {
    --MENU-WIDTH-S: 14.375rem;
    --MENU-WIDTH-M: 14.375rem;
    --MENU-WIDTH-L: 18.75rem;
    --color-primary: #2c3e50;           
    --color-background-light: #f8f9fa;  
  }
   
  .cornell-notes {
    padding: 10px;
    margin: 10px;
    display: flex;
    flex-wrap: wrap;
  }

  .cues {
    background-image: url('/images/cornell-img/icon2.svg');
    border-right: 1px solid #080808;
    flex: 1;
    padding-right: 20px;
  }

  .notes {
    background-image: url('/images/cornell-img/icon1.svg');
    border-left: 1px solid #080808;
    flex: 2;
    padding-left: 20px;
  }

  .summary {
    width: 100%;
    clear: both;
    padding-top: 20px;
    background-image: url('/images/cornell-img/iconmonstr-menu-lined.svg');
    margin-top: 20px;
  }

   
  .svg-container {
    width: 100%; 
    height: 40px;  
    margin-bottom: 1rem;
  }
  
   
  .svg-container svg {
    width: 100%;
    height: 100%;
    fill: currentColor;  
  }
  </style>

  </head>
  <body class="mobile-support print" data-url="/class/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="导航 (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="目录 (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList">
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="/"><span itemprop="name">技术博客 | 智能物联时代</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">课程</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-markdown" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/class/index.md" title="显示 Markdown"><i class="fa-fw fab fa-markdown"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/class/index.print.html" title="打印整章 (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/log/10.%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89hugo%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/" title="10.如何自定义hugo主题页面输出格式？ (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/" title="17.C加加编程 (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="更多"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable class" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="课程">课程</h1>

<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/">17.C加加编程</a><ul>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/15.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6opengl%E4%B8%8Ec%E5%8A%A0%E5%8A%A0/">15.计算机图形学OpenGL与C&#43;&#43;</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">14.新标准C加加程序设计</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/">13.从C到C&#43;&#43;</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/">12.其他库的介绍</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/">11.STL库学习之适配器</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/">10.STL库学习之仿函数</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/">9.STL库学习之迭代器与算法</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/">8.STL库学习之容器</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/">7.STL库学习之分配器</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/6.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AD%91%E5%9F%BA%E6%A6%82%E8%A6%81/">6.STL库学习之筑基概要</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">5.STL库之观其大略</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/">4.C&#43;&#43;2.0特性的使用</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/">3.导读</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/">2.组合与继承</a><ul></ul></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/">1.代码编写规范</a><ul></ul></li></ul></li>
  <li class="children-title"><a href="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/">21.C语言程序设计（含面试）</a><ul>
  <li class="children-title"><a href="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/">1.在线题库练习</a><ul></ul></li></ul></li>
  <li class="children-title"><a href="/class/20.c%E5%8A%A0%E5%8A%A0%E9%9D%A2%E8%AF%95/">20.C&#43;&#43;面试</a><ul>
  <li class="children-title"><a href="/class/20.c%E5%8A%A0%E5%8A%A0%E9%9D%A2%E8%AF%95/1.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">1.网络编程</a><ul></ul></li></ul></li>
  <li class="children-title"><a href="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/">1.代码编写规范</a><ul></ul></li>
  <li class="children-title"><a href="/class/12.%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">嵌入式系统设计知识点</a><ul></ul></li>
  <li class="children-title"><a href="/class/1.arkts/">ArkTS</a><ul></ul></li>
  <li class="children-title"><a href="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/">电子电路</a><ul>
  <li class="children-title"><a href="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">模拟电子技术基础笔记</a><ul></ul></li></ul></li>
  <li class="children-title"><a href="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul>
  <li class="children-title"><a href="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">Linux期末复习</a><ul></ul></li></ul></li>
  <li class="children-title"><a href="/class/2.androidstudio/">AndroidStudio</a><ul>
  <li class="children-title"><a href="/class/2.androidstudio/androidstudio%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">AndroidStudio</a><ul></ul></li>
  <li class="children-title"><a href="/class/2.androidstudio/%E7%AC%94%E8%AE%B0/">AndroidStudio笔记</a><ul></ul></li>
  <li class="children-title"><a href="/class/2.androidstudio/toolbar/">2-1.Toolbar工具栏</a><ul></ul></li></ul></li>
  <li class="children-title"><a href="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a><ul>
  <li class="children-title"><a href="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%87%E5%B9%B4/">过年</a><ul></ul></li>
  <li class="children-title"><a href="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/">计算机组成原理-复习</a><ul></ul></li></ul></li>
  <li class="children-title"><a href="/class/8.51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机</a><ul>
  <li class="children-title"><a href="/class/8.51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%BB%A3%E7%A0%81%E7%83%A7%E5%BD%95/">pretues&#43;kiel5仿真软件配合使用时需要注意的地方</a><ul></ul></li></ul></li>
  <li class="children-title"><a href="/class/19.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc%E5%8A%A0%E5%8A%A0/">19.设计模式（C&#43;&#43;）</a><ul></ul></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2025年4月1日
  </footer>
</article>
          <section>
            <h1 class="a11y-only">课程 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
  </ul>
</div>
  </header>

<h1 id="17c加加编程">17.C加加编程</h1>

<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/15.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6opengl%E4%B8%8Ec%E5%8A%A0%E5%8A%A0/">15.计算机图形学OpenGL与C&#43;&#43;</a><p><h2 id="理解glfw和glad">理解GLFW和GLAD</h2>
<h3 id="glfw">GLFW（）</h3>
<p>GLFW是一个开源的、跨平台的库，用于创建窗口、处理输入和渲染图形。它提供了一种简单的方式来与OpenGL进行交互，使得开发图形应用程序变得更加容易。</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">14.新标准C加加程序设计</a><p><h2 id="内存分区模型">内存分区模型</h2>
<p>内存代码区的意义：程序代码放在不同的区域，有程序自动管理的代码，也有程序员管理的代码，灵活管理；</p>
<p>一、程序执行前</p>
<p>1.代码区
存放二进制指令，就是代码，特点：</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/">13.从C到C&#43;&#43;</a><p><h2 id="指针">指针</h2>
<p>指针的声明：
<a href="#R-image-f7de55886796993e8307fb99b28c274d" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f7de55886796993e8307fb99b28c274d"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image.png"></a></p>
<h2 id="数组">数组</h2>
<p>数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义：
<a href="#R-image-079d9cd3b5e103dbdb2f9596eb600a1e" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-079d9cd3b5e103dbdb2f9596eb600a1e"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-1.png"></a></p>
<p>2.字符串文字量</p>
<p>指的是用 &ldquo;&ldquo;括起来的字符串。</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/">12.其他库的介绍</a><p><h3 id="为什么需要哈希函数">为什么需要哈希函数？</h3>
<p>哈希函数在计算机科学中扮演着重要的角色，其主要作用包括：</p>
<ol>
<li>
<p><strong>数据检索</strong>：哈希函数可以将键（key）映射到哈希表中的一个位置，从而快速检索数据。这是哈希表（如 C++ 中的 <code>std::unordered_map</code> 和 <code>std::unordered_set</code>）的基础。</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/">11.STL库学习之适配器</a><p><h2 id="整体框架的回顾">整体框架的回顾</h2>
<p><a href="#R-image-7812b2acbe5986c16a7867ed6b2d1ce0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7812b2acbe5986c16a7867ed6b2d1ce0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image.png"></a></p>
<h2 id="存在多种适配器-adapters">存在多种适配器-adapters</h2>
<p>一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知道该容器需要迭代器，也就是一些智能指针来确定容器的头尾，以及内容位置，目的是方便后续的算法的怎删改查等操作，假设算法现在要做拿到位置8的数据，那么vector的指针要怎么移动呢？已知指针移动上，vector是随机访问指针，也就是前后都可以跑，而这个操作实际上是迭代器的其中一个内容，而这一内容就需要一个适配器去做适配。</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/">10.STL库学习之仿函数</a><p><h2 id="仿函数的个人理解">仿函数的个人理解</h2>
<p>仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了operate()，当调用这个类的()时就会返回响应的数据。</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/">9.STL库学习之迭代器与算法</a><p><h2 id="标准库常用算法">标准库常用算法</h2>
<p><a href="#R-image-fdc53975170a99c5b5da198d4afa1ac2" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fdc53975170a99c5b5da198d4afa1ac2"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image.png"></a></p>
<h2 id="迭代器">迭代器</h2>
<h3 id="迭代器-的分类">迭代器-的分类</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">input_iterator_tag</span> {}<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">output_iterator_tag</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">forward_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> input_iterator_tag{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">bidirectional_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> forward_iterator_tag{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">random_access_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> bidirectional_iterator_tag {};</span></span></code></pre></div>
<p>以上5中迭代器的继承关系，如下图所示。
<a href="#R-image-b05ab556d9f670b471b8d6bf3bbb8042" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b05ab556d9f670b471b8d6bf3bbb8042"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-1.png"></a></p>
<p>1.Input Iterator（输入迭代器）：
输入迭代器是最基本的迭代器类型，支持单向遍历，只能向前移动。</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/">8.STL库学习之容器</a><p><h2 id="list">list</h2>
<h2 id="vector">vector</h2>
<h2 id="deque">deque</h2>
<p><a href="#R-image-3cbb104bcbb495834824b39d8987d43f" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image.png?height=350px&width=600px" style=" height: 350px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3cbb104bcbb495834824b39d8987d43f"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image.png?height=350px&width=600px"></a></p>
<p>deque的迭代器
<a href="#R-image-75c26c0f335f3b268ef8057e2b65d673" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-1.png?height=350px&width=600px" style=" height: 350px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-75c26c0f335f3b268ef8057e2b65d673"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-1.png?height=350px&width=600px"></a></p>
<p>deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用<code>push_front()</code>（<code>push_back()</code>）,否则借助<code>insert_aux()</code>迭代器，实现如果欲插入位置靠近前端使用，就让前端的数据往前挪，否则往后挪。</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/">7.STL库学习之分配器</a><p><h2 id="分配器源代码位置xmemoryh">分配器源代码位置：xmemory.h</h2>
<p><a href="#R-image-39e2418d554b233f9e7ea793cf931454" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-39e2418d554b233f9e7ea793cf931454"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/image.png"></a></p>
<p>除了array和vector外，其他容器的适配器必须是一个类，
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div></p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/6.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AD%91%E5%9F%BA%E6%A6%82%E8%A6%81/">6.STL库学习之筑基概要</a><p><h2 id="stl程序源代码位置">STL程序源代码位置</h2>
<p>了解自身编译器STL程序源代码位置。</p>
<h2 id="oop-与-gp">OOP 与 GP</h2>
<p>面向对象编程（OOP）：</p>
<p>面向对象编程是一种编程范式，它将数据和处理这些数据的方法封装在对象中。这种方法强调了数据和函数的捆绑，使得代码更加模块化，易于理解和维护。对象可以包含属性（数据）和方法（函数），它们一起工作来模拟现实世界的行为。</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">5.STL库之观其大略</a><p><h2 id="一下主要讲stl组件的测试用例特别是容器的测试">一下主要讲STL组件的测试用例，特别是容器的测试</h2>
<h2 id="学习资料">学习资料</h2>
<ul>
<li>CPLusPlus.com</li>
<li>CppReference.com</li>
<li>gcc.gnu.org</li>
<li>《STL源码剖析》</li>
</ul>
<h2 id="stl六大组件">STL六大组件</h2>
<ul>
<li>容器-Containers，申请内存用于存储数据</li>
<li>分配器-Allocators，配合容器分配内存</li>
<li>算法- Algorithms，处理某一数据的最优办法</li>
<li>迭代器-  Iterators，指针的泛型，本质与指针类似</li>
<li>适配器- Adapters，</li>
<li>仿函数-Functors，类似函数。</li>
</ul>
<p>六者的关系</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/">4.C&#43;&#43;2.0特性的使用</a><p><h2 id="vs-2022的设置">VS 2022的设置</h2>
<p>首先你可以先用下面的代码测试使用可以执行：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printTypes</span>() {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span>... U<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> printTypes(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> t, <span style="color:#66d9ef">const</span> U<span style="color:#f92672">&amp;</span>... u) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> t <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        printTypes(u...);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>        printTypes(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#ae81ff">1.5</span>, <span style="color:#e6db74">&#39;b&#39;</span>);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>如果报错了，如typename&hellip;未定义，那么请你按照如下步骤操作，
<a href="#R-image-163292f3ffba00899ab884e5c0866733" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-163292f3ffba00899ab884e5c0866733"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image.png"></a></p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/">3.导读</a><p><h2 id="书籍推荐">书籍推荐</h2>
<ul>
<li>《C++ Premier》</li>
<li>《C++ Programming Language》</li>
<li>《Effective Modern C++》</li>
<li>《Efficient C++》</li>
<li>《The C++ standard library》</li>
<li>《STL C++》</li>
<li>《STL源码剖析》</li>
<li>《算法+数据结构=程序》</li>
<li><a href="CPLusPlus.com">&ldquo;网站CPLusPlus&rdquo;</a></li>
<li><a href="CppReference.com">&ldquo;网站CppReference&rdquo;</a></li>
<li><a href="gcc.gnu.org">&ldquo;网站gcc.gnu&rdquo;</a></li>
</ul>
<h2 id="学习路线">学习路线</h2>
<p><a href="#R-image-21989a9c8ed8fb27651f922466327641" class="lightbox-link"><img alt="路线" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-21989a9c8ed8fb27651f922466327641"><img alt="路线" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-4.png"></a></p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/">2.组合与继承</a><p><h2 id="类与类的三种关系">类与类的三种关系</h2>
<h3 id="composition-复合">Composition-复合</h3>
<p>以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构函数运行次序是，构造函数有内到外依次运行，析构函数则相反。可以使用下图表示这种关系</p></p></li>
  <li class="children-title"><a href="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/">1.代码编写规范</a><p><h2 id="如何写一个标准的h文件">如何写一个标准的.h文件</h2>
<p>以下内容来自<a href="https://www.bilibili.com/video/BV1ELHEewEms/?p=6&spm_id_from=pageDriver&vd_source=5e8e4e9e284af3291f1a3addff3fc2c3" rel="external" target="_blank">B站</a>。</p>
<p>接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">complex</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* data */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> re,im;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> complex<span style="color:#f92672">&amp;</span> __doapl (complex<span style="color:#f92672">*</span>,<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    complex (<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span>re(r),im(i)                <span style="color:#75715e">//这是一个构造函数，这种写法意思是初始化变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {};
</span></span><span style="display:flex;"><span>    complex<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+=</span> (complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> re;}  <span style="color:#75715e">//这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> im;}
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="构造函数的特性">构造函数的特性</h2>
<p>这一点需要关注下面的代码：</p></p></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2025年4月1日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">自学编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
          <section>
            <h1 class="a11y-only">17.C加加编程 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
    <li><a class="term-link" href="/tags/opengl/">OpenGL</a></li>
    <li><a class="term-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</a></li>
  </ul>
</div>
  </header>

<h1 id="15计算机图形学opengl与c">15.计算机图形学OpenGL与C&#43;&#43;</h1>

<h2 id="理解glfw和glad">理解GLFW和GLAD</h2>
<h3 id="glfw">GLFW（）</h3>
<p>GLFW是一个开源的、跨平台的库，用于创建窗口、处理输入和渲染图形。它提供了一种简单的方式来与OpenGL进行交互，使得开发图形应用程序变得更加容易。</p>
<p>GLFW的主要功能包括：</p>
<ul>
<li>创建窗口</li>
<li>定义上下文</li>
<li>处理用户输入</li>
</ul>
<h3 id="glad">GLAD（）</h3>
<p>GLAD是一个开源的、跨平台的库，用于管理OpenGL的函数指针。它提供了一种简单的方式来获取OpenGL的函数指针，使得开发OpenGL应用程序变得更加容易。</p>
<p>相关说明：</p>
<ul>
<li>OpenGL本身知识规范/标准</li>
<li>各个厂家具体实现方式可以不同</li>
<li>不同操作系统处理方式也可以不同</li>
</ul>
<p>主要功能：</p>
<ul>
<li>获取OpenGL函数指针</li>
<li>处理OpenGL版本兼容性问题</li>
<li>处理OpenGL扩展函数
……</li>
</ul>
<p>如果没有GLAD库，在Windows下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>GL_GENBUFFER) (GLsizei,GLuint<span style="color:#f92672">*</span>);<span style="color:#75715e">//声明函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>GL_GENBUUFFER glGenBuffer <span style="color:#f92672">=</span> (GL_GENBUFFER)wglGetProcAddress(<span style="color:#960050;background-color:#1e0010">&#39;</span>glGenBuffer<span style="color:#960050;background-color:#1e0010">&#39;</span>);<span style="color:#75715e">//获取函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> buffer;<span style="color:#75715e">//声明缓冲区对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glGenBuffer(<span style="color:#ae81ff">1</span>,<span style="color:#f92672">&amp;</span>buffer);<span style="color:#75715e">//调用函数
</span></span></span></code></pre></div>
<p>有了GLAD库，只需要：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> buffer;
</span></span><span style="display:flex;"><span>glGenBuffer(<span style="color:#ae81ff">1</span>,<span style="color:#f92672">&amp;</span>buffer);</span></span></code></pre></div>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2025年4月1日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c/">C</a></li>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
    <li><a class="term-link" href="/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</a></li>
    <li><a class="term-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></li>
  </ul>
</div>
  </header>

<h1 id="14新标准c加加程序设计">14.新标准C加加程序设计</h1>

<h2 id="内存分区模型">内存分区模型</h2>
<p>内存代码区的意义：程序代码放在不同的区域，有程序自动管理的代码，也有程序员管理的代码，灵活管理；</p>
<p>一、程序执行前</p>
<p>1.代码区
存放二进制指令，就是代码，特点：</p>
<ul>
<li>共享：多个进程的代码区是共享的，因为代码是相同的，所以只需要加载一份到内存中即可，节省内存空间。</li>
<li>只读：代码是只读的，防止程序意外地修改了代码。</li>
</ul>
<p>2.全局区
全局变量和静态变量存储在全局区，还包括常量区、字符串常量和其他常量（如：const）,特点：</p>
<ul>
<li>全局区是程序结束后由系统释放。</li>
<li>全局变量和静态变量在程序结束后系统会自动释放，而局部变量在函数结束后由系统自动释放。</li>
</ul>
<p>例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//全局变量 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> g_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g_b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//const 修饰的全局变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> c_g_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc,<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//局部变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//静态变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> s_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> s_b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//字符串常量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>P <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//const修饰的局部变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> c_l_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;局部变量a的地址：&#34;</span><span style="color:#f92672">&lt;&lt;&amp;</span>a<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;局部变量b的地址：&#34;</span><span style="color:#f92672">&lt;&lt;&amp;</span>b<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;全局变量a的地址：&#34;</span><span style="color:#f92672">&lt;&lt;&amp;</span>g_a<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;全局变量b的地址：&#34;</span><span style="color:#f92672">&lt;&lt;&amp;</span>g_b<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;静态变量a的地址：&#34;</span><span style="color:#f92672">&lt;&lt;&amp;</span>s_a<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;静态变量b的地址：&#34;</span><span style="color:#f92672">&lt;&lt;&amp;</span>s_b<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;字符串常量P的地址：&#34;</span><span style="color:#f92672">&lt;&lt;</span>P<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;const修饰的局部变量c_l_a的地址：&#34;</span><span style="color:#f92672">&lt;&lt;&amp;</span>c_l_a<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;const修饰的全局变量c_g_a的地址：&#34;</span><span style="color:#f92672">&lt;&lt;&amp;</span>c_g_a<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>3.总结</p>
<ul>
<li>代码区：存放二进制指令，共享，只读。</li>
<li>全局区：存放全局变量和静态变量，程序结束后由系统释放。</li>
</ul>
<p>二、程序运行后</p>
<p>1.栈区</p>
<p>由编译器自动分配释放，存放函数的参数值，局部变量等。</p>
<p><strong>注意：</strong> 不要返回局部变量的地址，因为局部变量在函数结束后会被系统释放，再次访问会导致程序崩溃。</p>
<p>例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">GetAddr</span>(<span style="color:#66d9ef">int</span> b){<span style="color:#75715e">//形参数据也放在栈区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>a;<span style="color:#75715e">//返回局部变量的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> GetAddr();
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;*</span>p<span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//第一次可以打印正确的数据，是因为编译器做了保留，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;*</span>p<span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">// 但是第二次访问将不再保留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>2.堆区</p>
<p>由程序员分配释放，如果程序员不释放，程序结束时由系统回收。</p>
<p>在C++中主要利用new和delete操作符进行动态内存管理。</p>
<p>例子1-在堆上开辟空间：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">getAddr</span>(){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//在堆上开辟空间，并初始化为10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">10</span>);<span style="color:#75715e">//new出来的数据返回的是一个指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//使用存在栈区的局部指针指向堆区的数据，栈区的内容会被程序自动释放，但是指向堆区的数据不会被释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> getAddr();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;*</span>p<span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//输出10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> p;<span style="color:#75715e">//释放空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>图解：
<a href="#R-image-46ad7a23298786a549ea1d964f1312e6" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-13.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-46ad7a23298786a549ea1d964f1312e6"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-13.png"></a></p>
<p>例子2-堆区上的数据开辟与释放</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>P <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;*</span>P<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> P;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test2</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        arr[i] <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span>arr[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span>[] arr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    test();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="引用">引用</h2>
<p>给变量取别名。</p>
<p>一、变量引用</p>
<p>引用注意事项：</p>
<ul>
<li>引用必须初始化，int &amp;b;//这样是不正确的</li>
<li>引用初始化后不能改变</li>
<li>通过引用参数产生的效果与指针地址传递效果一样，引用语法更清楚；</li>
</ul>
<p>测试代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//值传递
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test1</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//地址传递
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test2</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a,<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>b) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//引用传递
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test3</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a,<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>	a <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>	b <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>二、应用做函数的返回值</p>
<ul>
<li>不要返回局部变量的引用</li>
<li>函数返回值是引用，那么这个函数调用可以作为左值</li>
</ul>
<p>测试代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 二、引用做函数返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//1.不能返回应用返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> test04()<span style="color:#75715e">//以引用的方式返回b,相当于给这个b起了一个别名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;<span style="color:#75715e">//局部变量存放在栈区，函数结束后会被释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//2. 函数的调用可以作为左值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> test05()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;<span style="color:#75715e">//静态变量存放在全局区，程序结束后由系统自动释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ret04 <span style="color:#f92672">=</span> test04();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ret05 <span style="color:#f92672">=</span> test05();
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ret04= &#34;</span><span style="color:#f92672">&lt;&lt;</span>ret04 <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ret04= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ret04 <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;<span style="color:#75715e">//第二次访问返回的是乱码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ret05= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ret05 <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>	test05() <span style="color:#f92672">=</span> <span style="color:#ae81ff">130</span>;<span style="color:#75715e">//函数的返回是引用，函数的调用可以作为左值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ret05= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ret05 <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>测试代码结果
<a href="#R-image-a5f87e6a05f72ed157fc1c1209f5321d" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-14.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a5f87e6a05f72ed157fc1c1209f5321d"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-14.png"></a></p>
<p>三、引用的本质</p>
<p>引用的本质在C++内部实现是一个指针常量，引用类型必须和引用实体是同类型。</p>
<p>四、常量引用</p>
<p>作用：用来修饰形参，防止误操作。</p>
<p>代码说明：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//四、常量引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//int &amp;ref = 10; 这样的操作是不被允许的，因为赋值给引用的是一个字面量,引用需要一个合法的空间，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 程序运行时没有专门为其分配可修改的内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 但是如果在前面在上const，这条代码就通过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// const int &amp;ref = 10;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//用来修饰形参，防止误操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test06</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>val)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//val = 100;不被允许修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;val = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> val <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="函数进阶">函数进阶</h2>
<p>一、函数默认参数</p>
<p>返回值 函数名(参数 = 默认值){}</p>
<p>注意事项：</p>
<p>1.如果某个位置已经有了默认参数，那么该位置往后都必须有默认参数</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//函数默认参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> a ,<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>,<span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>2.函数的声明有默认参数，函数实现不能有默认参数,声明和实现只能有一个有默认值</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">//函数声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>,<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>);<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//函数实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> a ,<span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>二、函数占位参数</p>
<p>作用：为了函数声明和定义的统一
语法：返回类型 函数名(数据类型){}</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//函数占位参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span>)<span style="color:#75715e">//第二个参数为占位参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    test(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>);<span style="color:#75715e">//占位参数必须填补,否则无法运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>注意：占位参数可以有默认参数，此时调用时就不用在传值</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//函数占位参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>)<span style="color:#75715e">//第二个参数为占位参数，含默认值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    test(<span style="color:#ae81ff">10</span>);<span style="color:#75715e">//不需要传站位参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<p>三、函数重载</p>
<p>满足条件：</p>
<ul>
<li>在同一个作用域下。</li>
<li>函数名相同，</li>
<li>参数类型不同，</li>
<li>参数个数不同，</li>
<li>参数顺序不同。</li>
</ul>
<p>作用： 提高复用性</p>
<p>注意：</p>
<p>1.返回值不能作为重载的条件</p>
<p>2.引用作为重载的条件</p>
<p>加const和不加是可以重载的</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;fun(int &amp;a)&#34;</span><span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;fun(const int &amp;a)&#34;</span><span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>b <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>    fun(a);<span style="color:#75715e">//调用fun(int &amp;a)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fun(b);<span style="color:#75715e">//调用fun(const int &amp;a)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fun(<span style="color:#ae81ff">10</span>);<span style="color:#75715e">//调用fun(const int &amp;a)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>3.函数重载遇到默认参数</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun2</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;fun(int &amp;a)&#34;</span><span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun2</span>(<span style="color:#66d9ef">int</span> a){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;fun(const int &amp;a)&#34;</span><span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fun2(<span style="color:#ae81ff">10</span>);<span style="color:#75715e">//此时程序出现二义性，无法确定调用哪个函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="类和对象的基本概念">类和对象的基本概念</h2>
<p>C++的特性：封装、多态、继承</p>
<p>一、基本概念</p>
<ul>
<li>抽象：将事物所能进行的的行为归纳出来，形成函数，这些函数可以操作事物归纳后的数据结构。</li>
<li>类： 、</li>
</ul>
<h3 id="封装">封装</h3>
<p>将事物归纳的数据结构和操作该数据结构的算法呈现显而易见的紧密关系，叫封装。</p>
<p>一、 封装的意义</p>
<p>1.将属性和行为作为一个整体，表现生活中的事物。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> test_class
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//设计一个圆的类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define PI 3.14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//访问权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> m_r;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//行为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">calculateZC</span>()
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> PI <span style="color:#f92672">*</span> m_r;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>		Circle c1;
</span></span><span style="display:flex;"><span>		c1.m_r <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;圆的周长 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c1.calculateZC() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>2.访问权限</p>
<ul>
<li>public 公共权限</li>
<li>protected 保护权限</li>
<li>private 私有权限</li>
</ul>
<p>二、访问权限说明</p>
<ul>
<li>public修饰的成员，可以在类内或者类外直接访问</li>
<li>protected修饰的成员，只能在类内和子类中访问</li>
<li>private修饰的成员，只能在类内访问</li>
</ul>
<h3 id="继承">继承</h3>
<h3 id="多态">多态</h3>
<h3 id="类">类</h3>
<p>将数据结构和操作该数据结构的函数捆绑在一起形成一个类。</p>
<h3 id="在类中使用缺省函数">在类中使用缺省函数</h3>
<p>需要注意避免二义性：
<a href="#R-image-4984f44e44431ccc815ac0afbed7e32c" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4984f44e44431ccc815ac0afbed7e32c"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-5.png"></a></p>
<h2 id="构造函数">构造函数</h2>
<h3 id="类中为什么需要构造函数">类中为什么需要构造函数</h3>
<p><a href="#R-image-842c9922ab557d0faa74893660130669" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-842c9922ab557d0faa74893660130669"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-6.png"></a></p>
<h3 id="构造函数在数组中的使用">构造函数在数组中的使用</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        A(){std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;hello</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;}<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        A(<span style="color:#66d9ef">int</span> b){std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;value: &#34;</span><span style="color:#f92672">&lt;&lt;</span>b<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;}<span style="color:#75715e">//2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    A arr[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>上面的语句就调用了第1，2个构造函数，首先数据里的1会调用2，而数组的第二个是空值那么就会调用第1个。</p>
<h2 id="复制构造函数-copy-constructor">复制构造函数-copy constructor</h2>
<p>函数名与类名相同，参数为A(A&amp; a)或A(const A&amp; a)（二选一）。</p>
<p>三种情况下复制构造函数起作用</p>
<ul>
<li>同类对象a,b，将a的值初始化b；
<ul>
<li>A a; A b(a);</li>
</ul>
</li>
<li>将类当作参数传入函数；</li>
<li>将类作为返回值；</li>
</ul>
<p>注意：对象之间的复制是不会导致复制构造函数的</p>
<h2 id="转换构造函数">转换构造函数</h2>
<p>什么是转换构造函数
<a href="#R-image-b34484bdeebc27bce164ac5fa1780cb6" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b34484bdeebc27bce164ac5fa1780cb6"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-7.png"></a></p>
<p>示例代码：
<a href="#R-image-7e99a5135dcce1db8b51d13cfd123458" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e99a5135dcce1db8b51d13cfd123458"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-8.png"></a>
在上面的例子当中，<code>c1 = 9;</code>会被自动转换为调用转换构造函数，如果不想让这样的事情发生，可以在转换构造函数前面加上修饰字段 <code>explicit</code>，这样再次使用<code>c1 = 9;</code>时程序会报错。</p>
<h2 id="析构函数-destructors">析构函数-destructors</h2>
<p>这里补充几点，一个类只能有一个析构函数；</p>
<p><strong>析构函数与数组：</strong></p>
<p>数组成员的每一次结束时都会调用析构函数，假设类A数组array[2]，则生命周期结束时会调用两次析构函数。</p>
<p><strong>析构函数什么时候被调用呢？</strong></p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CMyclass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>CMyclass() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destructor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    CMyclass obj;
</span></span><span style="display:flex;"><span>    CMyclass <span style="color:#a6e22e">fun</span>(CMyclass sobj ) { <span style="color:#75715e">//参数对象消亡也会导致析
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//构函数被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> sobj; <span style="color:#75715e">//函数调用返回时生成临时对象返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    obj <span style="color:#f92672">=</span> fun(obj); <span style="color:#75715e">//函数调用的返回值（临时对象）被
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//用过后，该临时对象析构函数被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }</span></span></code></pre></div>
<p>上面结果输出三个destructor，在<code>fun(CMyclass sobj)</code>参数对象消亡调用析构函数（具体可以联想复制构造函数），会调用一次析构函数；当函数返回赋值给obj后，再次调用析构函数；整个程序结束再次调用析构函数。
<a href="#R-image-5251b4967fa4cd974e4db4815a0adf4a" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5251b4967fa4cd974e4db4815a0adf4a"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-9.png"></a></p>
<h2 id="this指针">this指针</h2>
<p><a href="#R-image-b4f306468d9371d3f5f399baa3af7e5a" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b4f306468d9371d3f5f399baa3af7e5a"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-10.png"></a></p>
<p>静态成员函数中可以直接使用this指针来代表指向该函数作用的对象的指针</p>
<p>示例1：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> real, imag;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Print</span>() { cout <span style="color:#f92672">&lt;&lt;</span> real <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> imag ; }
</span></span><span style="display:flex;"><span>Complex(<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)<span style="color:#f92672">:</span>real(r),imag(i)
</span></span><span style="display:flex;"><span>{ }
</span></span><span style="display:flex;"><span>Complex <span style="color:#a6e22e">AddOne</span>() {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>real <span style="color:#f92672">++</span>; <span style="color:#75715e">//等价于 real ++;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>Print(); <span style="color:#75715e">//等价于 Print
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>}; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>Complex c1(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>),c2(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>c2 <span style="color:#f92672">=</span> c1.AddOne();<span style="color:#75715e">//调用AddOne函数后内部this指针变为c1，所以是c1中的read++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">//输出 2,1
</span></span></span></code></pre></div>
<p>示例2：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Hello() { cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>}; <span style="color:#75715e">// 翻译为void Hello(A * this ) { cout &lt;&lt; this-&gt;i &lt;&lt; &#34;hello&#34;&lt;&lt; endl; }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">-&gt;</span>Hello(); <span style="color:#75715e">//翻译为Hello(p);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#75715e">//编译报错
</span></span></span></code></pre></div>
<p>报错的原因是p指针式一个空指针，它并不指向任何A的对象，所以编译到 <code>this-&gt;i</code> 会报错。</p>
<h2 id="静态成员变量和函数">静态成员变量和函数</h2>
<p><strong>基本特点：</strong></p>
<ul>
<li>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。</li>
<li>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。因此静态成员不需要通过对象就能访问。</li>
</ul>
<p>对第二句话的理解，如下代码示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 普通成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> bark() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Woof!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 静态成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>string getSpecies() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Canine&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>要调用bark我们需要先创建一个Dog的类对象，然后通过 <code>.</code> 调用，也就是非静态成员作用于对象的意思，但是对于 <code>getSpecies</code> 就不需要，可以直接 <code>Dog::getSpecies</code>调用。</p>
<p><strong>如何访问静态成员？</strong></p>
<ol>
<li>
<p>类名::成员名
CRectangle::PrintTotal();</p>
</li>
<li>
<p>对象名.成员名
CRectangle r; r.PrintTotal();</p>
</li>
<li>
<p>指针-&gt;成员名
CRectangle * p = &amp;r; p-&gt;PrintTotal();</p>
</li>
<li>
<p>引用.成员名
CRectangle &amp; ref = r; int n = ref.nTotalNumber;</p>
</li>
</ol>
<p><strong>设置静态成员变量的目的是什么？</strong></p>
<p>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。比如，考虑一个需要随时知道矩形总数和总面积的图形处理程序，可以用全局变量来记录总数和总面积，用静态成员将这两个变量封装进类中，就更容易理解和维护。</p>
<p>注意事项：</p>
<ul>
<li>必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。</li>
<li>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
<h2 id="成员对象和封闭类">成员对象和封闭类</h2>
<ul>
<li>有成员对象的类叫 封闭(enclosing)类。</li>
<li>任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。具体的做法就是：通过封闭类的构造函数的初始化列表。</li>
</ul>
<p><strong>封闭类的复制构造函数:</strong></p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    A() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;default&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>    A(A <span style="color:#f92672">&amp;</span> a) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;copy&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> { A a; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    B b1,b2(b1);<span style="color:#75715e">//b2调用自生默认复制构造函数，而内部的A a也会调用默认的复制构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h2 id="友元">友元</h2>
<ol>
<li>友元函数: 一个类的友元函数可以访问该类的私有成员。</li>
<li>可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元。</li>
<li>友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。</li>
<li>友元类之间的关系不能传递，不能继承。</li>
</ol>
<h2 id="常量成员">常量成员</h2>
<p>常量成员函数：内部不能改变属性的值，也不能调用非常量成员函数。</p>
<p>**注意：**如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，那么，最好将其写成常量成员函数。
mutable成员变量
可以在const成员函数中修改的成员变量</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CTest</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> GetData() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    m_n1<span style="color:#f92672">++</span>;<span style="color:#75715e">//这个值更可以更改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> m_b2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> m_n1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> m_b2;
</span></span><span style="display:flex;"><span>    };</span></span></code></pre></div>
<h2 id="运算符重载函数">运算符重载函数</h2>
<p><strong>浅拷贝与深拷贝：</strong>
<a href="#R-image-867ecfc2e8503f40895239e11ad6ed41" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-867ecfc2e8503f40895239e11ad6ed41"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image.png"></a></p>
<p>为解决这个问题，我们需要修改赋值运算符重载：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    String <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> String <span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span> s)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> [] str;
</span></span><span style="display:flex;"><span>        str <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(s.str)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy( str,s.str);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="自增自减运算法重载">自增自减运算法重载</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CDemo</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>CDemo(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span>n(i) { }
</span></span><span style="display:flex;"><span>CDemo <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(); <span style="color:#75715e">//用于前置形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>CDemo <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>( <span style="color:#66d9ef">int</span> ); <span style="color:#75715e">//用于后置形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">int</span> ( ) { <span style="color:#66d9ef">return</span> n; }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">friend</span> CDemo <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">--</span>(CDemo <span style="color:#f92672">&amp;</span> );
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">friend</span> CDemo <span style="color:#66d9ef">operator</span><span style="color:#f92672">--</span>(CDemo <span style="color:#f92672">&amp;</span> ,<span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><code>operator int ( ) {return n;}</code></p>
<p>这里，int 作为一个类型强制转换运算符被重载, 此后</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Demo s;
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">int</span>) s ; <span style="color:#75715e">//等效于 s.int();
</span></span></span></code></pre></div>
<p>类型强制转换运算符被重载时不能写返回值类型，实际上其返回值类型就是该类型强制转换运算符代表的类型。</p>
<h2 id="继承和派生">继承和派生</h2>
<p>**注意：**在派生类的各个成员函数中，不能访问基类中的private成员。</p>
<h3 id="派生类的内存空间">派生类的内存空间</h3>
<p><a href="#R-image-d75cf29790b4c1107f8edfd5262b2eab" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d75cf29790b4c1107f8edfd5262b2eab"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-1.png"></a></p>
<h3 id="类之间的关系">类之间的关系</h3>
<p><strong>继承：“是”关系。</strong></p>
<ul>
<li>基类 A，B是基类A的派生类。</li>
<li>逻辑上要求：“一个B对象也是一个A对象”。</li>
</ul>
<p><strong>复合：“有”关系。</strong></p>
<ul>
<li>类C中“有”成员变量k，k是类D的对象，则C和D是复合
关系</li>
<li>一般逻辑上要求：“D对象是C对象的固有属性或组成部
分”</li>
</ul>
<p>复合关系的示例：
<a href="#R-image-34fad1577e0f66fb4dd2e83e39a463b8" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-34fad1577e0f66fb4dd2e83e39a463b8"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-2.png"></a></p>
<h3 id="基类与派生类名字重名的情况">基类与派生类名字重名的情况</h3>
<p>一般来说，基类和派生类不定义同名成员变量。但如果要方位可以使用<code>基类::基类成员</code>来访问。</p>
<h3 id="访问权限">访问权限</h3>
<p><strong>• 基类的private成员：可以被下列函数访问</strong></p>
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
</ul>
<p><strong>• 基类的public成员：可以被下列函数访问</strong></p>
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数</li>
<li>派生类的友元函数</li>
<li>其他的函数</li>
</ul>
<p><strong>• 基类的protected成员：可以被下列函数访问</strong></p>
<ul>
<li>基类的成员函数</li>
<li>基类的友元函数</li>
<li>派生类的成员函数可以访问当前对象和其它对象的基类的保护成</li>
</ul>
<p>举一个例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Father</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> nPrivate; <span style="color:#75715e">//私有成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> nPublic; <span style="color:#75715e">//公有成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> nProtected; <span style="color:#75715e">// 保护成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Son</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Father{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">AccessFather</span> () {
</span></span><span style="display:flex;"><span>nPublic <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// ok;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>nPrivate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// wrong
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// OK，访问从基类继承的protected成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Son f;
</span></span><span style="display:flex;"><span>f.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//ok，派生类的成员函数可以访问当前对象和其它对象的基类的保护成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    Father f;
</span></span><span style="display:flex;"><span>    Son s;
</span></span><span style="display:flex;"><span>    f.nPublic <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s.nPublic <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Ok
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// error，因为只能在派生类（或友元类）中访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f.nPrivate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s.nProtected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s.nPrivate <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="派生类构造函数中包含成员变量时该如何写">派生类构造函数中包含成员变量时该如何写？</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bug</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nLegs; <span style="color:#66d9ef">int</span> nColor;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nType;
</span></span><span style="display:flex;"><span>    Bug ( <span style="color:#66d9ef">int</span> legs, <span style="color:#66d9ef">int</span> color);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintBug</span> (){ };
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Skill</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Skill(<span style="color:#66d9ef">int</span> n) { }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FlyBug</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Bug {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nWings;
</span></span><span style="display:flex;"><span>    Skill sk1, sk2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    FlyBug( <span style="color:#66d9ef">int</span> legs, <span style="color:#66d9ef">int</span> color, <span style="color:#66d9ef">int</span> wings);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    FlyBug<span style="color:#f92672">::</span>FlyBug( <span style="color:#66d9ef">int</span> legs, <span style="color:#66d9ef">int</span> color, <span style="color:#66d9ef">int</span> wings)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Bug(legs,color),sk1(<span style="color:#ae81ff">5</span>),sk2(color) ,nWings(wings) { }<span style="color:#75715e">//注意这种写法。
</span></span></span></code></pre></div>
<h3 id="private-和-protected的继承">private 和 protected的继承</h3>
<p>• protected继承时，基类的public成员和protected成员成为派生类的protected成员。
• private继承时，基类的public成员成为派生类的private成员，基类的protected成员成
为派生类的不可访问成员。
• protected和private继承不是“是”的关系。</p>
<p><strong>问题：</strong></p>
<p>即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有，而派生类中有的成员。</p>
<p><strong>解决办法：</strong></p>
<p>通过强制指针类型转换，可以把ptrBase转换成Derived类的指针</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    Base <span style="color:#f92672">*</span> ptrBase <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>objDerived;
</span></span><span style="display:flex;"><span>    Derived <span style="color:#f92672">*</span>ptrDerived <span style="color:#f92672">=</span> (Derived <span style="color:#f92672">*</span> ) ptrBase;</span></span></code></pre></div>
<p>程序员要保证ptrBase指向的是一个Derived类的对象，否则很容易会出错。</p>
<h2 id="虚函数和多态">虚函数和多态</h2>
<h3 id="多态的表现形式">多态的表现形式</h3>
<ul>
<li>派生类的指针（或引用）可以给基类赋值。</li>
<li>当指针指向基类时调用，基类的函数，当指针指向派生类时，调用调用派生类的函数，这叫做多态。</li>
<li>另外，在非虚函数和非构造、析构函数中调用虚函数，也叫做多态。
例子：
<a href="#R-image-3850f2912903942fd08165ab0dd36374" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3850f2912903942fd08165ab0dd36374"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-4.png"></a></li>
</ul>
<p>如果在构造、析构函数中调用虚函数，那么会怎么样呢？</p>
<p>如果这么做，那么编译器只会调用当前的虚函数，如果当前没有重写虚函数，则会从基类中找进行调用，为什么要这么做呢？其实这是为了防止未初始化就调用派生类的虚函数的情况。</p>
<p>你想想啊，一类的初始化先从基类的构造函数开始，如果这个时候构造函数具有多态性，那么此时将调用派生类的对应虚函数，但是派生类这个时候都还没有初始化。</p>
<p>例子：
<a href="#R-image-0233f37142ebd945c863244319494c97" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0233f37142ebd945c863244319494c97"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-3.png"></a>`</p>
<ul>
<li>补充：在上面的图例子中，派生类写了与基类虚函数相同的名字，但是没有在前面加修饰符virtual，这种情况编译器认为是虚函数。</li>
</ul>
<h3 id="多态的作用">多态的作用</h3>
<p>在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。</p>
<h3 id="虚函数的访问权限">虚函数的访问权限</h3>
<p><a href="#R-image-1ffac2c1d722a7e4d097ab0dbc2f3f04" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-11.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1ffac2c1d722a7e4d097ab0dbc2f3f04"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-11.png"></a></p>
<h3 id="动态联编的实现机制">动态联编的实现机制</h3>
<p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定 &mdash;- 这叫“动态联编”。</p>
<p>每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址。多出来的4个字节就是用来放虚函数表的地址的。
<a href="#R-image-4c981da330acf5b332ec352b80959899" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-12.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4c981da330acf5b332ec352b80959899"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/14.%E6%96%B0%E6%A0%87%E5%87%86c%E5%8A%A0%E5%8A%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-12.png"></a></p>
<p>下面一段代码将验证，对象的首地址是存了虚函数表的地址的：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Func() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A::Func&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> A {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Func() { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B::Func&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    A a;
</span></span><span style="display:flex;"><span>    A <span style="color:#f92672">*</span> pa <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> B();
</span></span><span style="display:flex;"><span>    pa<span style="color:#f92672">-&gt;</span>Func();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//64位程序指针为8字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span> ) <span style="color:#f92672">&amp;</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span> ) pa;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span> p1;
</span></span><span style="display:flex;"><span>    pa<span style="color:#f92672">-&gt;</span>Func();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="纯虚函数和抽象类">纯虚函数和抽象类</h3>
<ul>
<li>纯虚函数：没有函数体的虚函数</li>
<li>抽象类：有纯虚函数的类</li>
</ul>
<p>注意：</p>
<ul>
<li>包含纯虚函数的类叫抽象类
<ul>
<li>抽象类只能作为基类来派生新类使用，不能创建独立的抽象类的对象</li>
<li>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</li>
</ul>
</li>
</ul>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    A a ; <span style="color:#75715e">// 错，A 是抽象类，不能创建对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    A <span style="color:#f92672">*</span> pa ; <span style="color:#75715e">// ok,可以定义抽象类的指针和引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pa <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A ; <span style="color:#75715e">//错误, A 是抽象类，不能创建对象
</span></span></span></code></pre></div>
<ul>
<li><strong>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数。</strong></li>
<li>如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。</li>
</ul>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年11月3日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c/">C</a></li>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
    <li><a class="term-link" href="/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">基本概念</a></li>
    <li><a class="term-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></li>
  </ul>
</div>
  </header>

<h1 id="13从c到c">13.从C到C&#43;&#43;</h1>

<h2 id="指针">指针</h2>
<p>指针的声明：
<a href="#R-image-f7de55886796993e8307fb99b28c274d" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f7de55886796993e8307fb99b28c274d"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image.png"></a></p>
<h2 id="数组">数组</h2>
<p>数组的范围必须是常量表达式，同时如果需要变化的范围可以做如下定义：
<a href="#R-image-079d9cd3b5e103dbdb2f9596eb600a1e" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-079d9cd3b5e103dbdb2f9596eb600a1e"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-1.png"></a></p>
<p>2.字符串文字量</p>
<p>指的是用 &ldquo;&ldquo;括起来的字符串。</p>
<ul>
<li>长字符串编写：
<a href="#R-image-a661274da09fa72737ddd5d60fb04806" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a661274da09fa72737ddd5d60fb04806"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-2.png"></a></li>
<li>带有L的字符是宽字符，如L&quot;sddsf&rdquo;，类型是const wchar_t.</li>
</ul>
<p>3.指向数组的指针</p>
<p>4.常量
<a href="#R-image-c72a8bc43540766ec46211d9b1bdf0f1" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c72a8bc43540766ec46211d9b1bdf0f1"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-3.png"></a></p>
<p>5.指针和常量</p>
<p>使用一个指针时涉及到两个对象:该指针本身和被它所指的对象。将一个指针的声明用cons“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，我们必须使用声明运算符*const，而不能只用简单的const。</p>
<p>定义常量指针的声明运算符是<em>const。并没有cons** 声明符，所以出现在</em>之前的conr是作为基础类型的一部分。例如</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 到char的hconst指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> cp;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">*</span> pc;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 到const char的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> pc2;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//到const char的指针
</span></span></span></code></pre></div>
<p>有人发现从右向左读这种定义很有帮助。例如，&ldquo;cp是一个conse指针到char&rdquo;，以及“pe2是一个指针措到const chor&rdquo;</p>
<h2 id="引用">引用</h2>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ii<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>rr <span style="color:#f92672">=</span> ii;
</span></span><span style="display:flex;"><span>    rr<span style="color:#f92672">++</span>;<span style="color:#75715e">//实际上是ii++,rr不能像指针一样操作。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>ii;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><a href="#R-image-4444c745a235c5583a744148d1869701" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4444c745a235c5583a744148d1869701"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/13.%E4%BB%8Ec%E5%88%B0c%E5%8A%A0%E5%8A%A0/image-4.png"></a></p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月31日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="12其他库的介绍">12.其他库的介绍</h1>

<h3 id="为什么需要哈希函数">为什么需要哈希函数？</h3>
<p>哈希函数在计算机科学中扮演着重要的角色，其主要作用包括：</p>
<ol>
<li>
<p><strong>数据检索</strong>：哈希函数可以将键（key）映射到哈希表中的一个位置，从而快速检索数据。这是哈希表（如 C++ 中的 <code>std::unordered_map</code> 和 <code>std::unordered_set</code>）的基础。</p>
</li>
<li>
<p><strong>快速比较</strong>：在数据库和各种数据结构中，哈希函数可以快速比较字符串或对象，常用于检查两个字符串是否相等。</p>
</li>
<li>
<p><strong>数据分布</strong>：在分布式系统中，哈希函数可以将数据均匀地分布到多个节点上，以实现负载均衡。</p>
</li>
<li>
<p><strong>密码学应用</strong>：在密码学中，哈希函数用于生成数据的摘要，用于数据完整性验证和数字签名。</p>
</li>
<li>
<p><strong>缓存实现</strong>：哈希函数可以用于实现缓存机制，通过快速定位缓存中的数据。</p>
</li>
<li>
<p><strong>负载均衡</strong>：在网络流量管理中，哈希函数可以用于将请求分配到不同的服务器上。</p>
</li>
</ol>
<h3 id="c-库中哈希函数的实现和底层逻辑">C++ 库中哈希函数的实现和底层逻辑</h3>
<p>在 C++11 及以后的版本中，标准库提供了一个专门的哈希函数库 <code>&lt;functional&gt;</code>，其中包含了 <code>std::hash</code> 模板类。<code>std::hash</code> 为基本数据类型（如 <code>int</code>、<code>double</code>、<code>std::string</code> 等）提供了特化版本。</p>
<h4 id="实现底层逻辑">实现底层逻辑：</h4>
<ol>
<li>
<p><strong>整数类型</strong>：对于整数类型，<code>std::hash</code> 直接返回数值本身或其变体。例如，对于 <code>int</code> 类型，<code>std::hash&lt;int&gt;()(10)</code> 可能直接返回 10 或者 10 的一个简单变换。</p>
</li>
<li>
<p><strong>浮点类型</strong>：对于浮点类型，<code>std::hash</code> 通常会将浮点数的位表示转换为整数，然后应用整数的哈希函数。</p>
</li>
<li>
<p><strong>字符串类型</strong>：对于字符串，<code>std::hash</code> 通常会遍历字符串中的每个字符，将每个字符的哈希值组合起来，生成最终的哈希值。这可以通过位操作和数学函数（如乘法、加法、异或等）来实现。</p>
</li>
<li>
<p><strong>自定义类型</strong>：对于自定义类型，如果需要使用 <code>std::hash</code>，则需要为该类型提供自定义的哈希函数。</p>
</li>
<li>
<p><strong>组合哈希</strong>：对于复合类型（如结构体或类），哈希函数需要将各个成员的哈希值组合起来。这通常通过将成员的哈希值进行某种形式的数学运算（如加权求和、异或等）来实现。</p>
</li>
<li>
<p><strong>均匀分布</strong>：一个好的哈希函数应该能够产生均匀分布的哈希值，以减少哈希冲突。</p>
</li>
<li>
<p><strong>确定性</strong>：哈希函数应该是确定性的，即对于同一个输入总是产生相同的哈希值。</p>
</li>
<li>
<p><strong>快速计算</strong>：哈希函数的计算应该尽可能快，以减少对性能的影响。</p>
</li>
</ol>
<p>在 C++ 中，<code>std::hash</code> 的实现可能因编译器和平台而异，但基本原理是相似的。正确实现哈希函数对于哈希表的性能至关重要，因为它直接影响到哈希表的冲突率和检索效率。</p>
<h2 id="hash-function-哈希函数">hash function-哈希函数</h2>
<p>如果要自己给自己的数据写一个哈希函数，那又该怎么写呢？能否基于这些数据计算出hash code的呢？</p>
<h3 id="编写模版规范">编写模版规范</h3>
<div class="tab-panel" data-tab-group="4dfc4cbb0b1a40a535a13245500689c8">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="类型1fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('4dfc4cbb0b1a40a535a13245500689c8','类型1fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 类型1</span>
    </button>
    <button
      data-tab-item="类型1示例fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;"
      onclick="switchTab('4dfc4cbb0b1a40a535a13245500689c8','类型1示例fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 类型1示例</span>
    </button>
    <button
      data-tab-item="类型2fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;"
      onclick="switchTab('4dfc4cbb0b1a40a535a13245500689c8','类型2fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 类型2</span>
    </button>
    <button
      data-tab-item="类型3fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;"
      onclick="switchTab('4dfc4cbb0b1a40a535a13245500689c8','类型3fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 类型3</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="类型1fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_hash_function
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            string fname;
</span></span><span style="display:flex;"><span>            string lname;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                Customer( string fn,  string ln, <span style="color:#66d9ef">int</span> id) <span style="color:#f92672">:</span> fname(fn), lname(ln), on(id) {}
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> other) <span style="color:#66d9ef">const</span> {<span style="color:#75715e">//需要重载==
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">return</span> fname <span style="color:#f92672">==</span> other.fname <span style="color:#f92672">&amp;&amp;</span> lname <span style="color:#f92672">==</span> other.lname <span style="color:#f92672">&amp;&amp;</span> on <span style="color:#f92672">==</span> other.on;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>size_t <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> ...;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span>Customer, CustromerHash<span style="color:#f92672">&gt;</span> custsct;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="类型1示例fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>   <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_hash_function
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> hash_combine(size_t<span style="color:#f92672">&amp;</span> seed, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> val) {
</span></span><span style="display:flex;"><span>            seed <span style="color:#f92672">^=</span> hash<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>()(val) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ae81ff">0x9e3779b9</span> <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                (seed <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">6</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                (seed <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> hash_val(size_t<span style="color:#f92672">&amp;</span> seed, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> val) {
</span></span><span style="display:flex;"><span>            hash_combine(seed, val);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span>... Types<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> hash_val(	size_t<span style="color:#f92672">&amp;</span> seed,
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> val,
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">const</span> Types<span style="color:#f92672">&amp;</span>... args) 
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            hash_combine(seed, val);
</span></span><span style="display:flex;"><span>            hash_val(seed, args...);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Types<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">inline</span> size_t hash_val(<span style="color:#66d9ef">const</span> Types<span style="color:#f92672">&amp;</span>... args) {
</span></span><span style="display:flex;"><span>            size_t seed <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            hash_val(seed, args...);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> seed;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            string fname;
</span></span><span style="display:flex;"><span>            string lname;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            Customer( string fn,  string ln, <span style="color:#66d9ef">int</span> id) <span style="color:#f92672">:</span> fname(fn), lname(ln), on(id) {}
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> other) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> fname <span style="color:#f92672">==</span> other.fname <span style="color:#f92672">&amp;&amp;</span> lname <span style="color:#f92672">==</span> other.lname <span style="color:#f92672">&amp;&amp;</span> on <span style="color:#f92672">==</span> other.on;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            size_t <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hash_val</span>(c.fname, c.lname, c.on);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            unordered_set<span style="color:#f92672">&lt;</span>Customer, CustomerHash<span style="color:#f92672">&gt;</span> s;
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Asd&#34;</span>, <span style="color:#e6db74">&#34;dfw&#34;</span>, <span style="color:#ae81ff">1L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Dfg&#34;</span>, <span style="color:#e6db74">&#34;kjt&#34;</span>, <span style="color:#ae81ff">2L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;VVB&#34;</span>, <span style="color:#e6db74">&#34;ert&#34;</span>, <span style="color:#ae81ff">3L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;TgR&#34;</span>, <span style="color:#e6db74">&#34;uik&#34;</span>, <span style="color:#ae81ff">4L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">5L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">6L</span>));
</span></span><span style="display:flex;"><span>            s.insert(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">7L</span>));<span style="color:#75715e">//8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> s.bucket_count() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            CustomerHash hh;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Asd&#34;</span>, <span style="color:#e6db74">&#34;dfw&#34;</span>, <span style="color:#ae81ff">1L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Dfg&#34;</span>, <span style="color:#e6db74">&#34;kjt&#34;</span>, <span style="color:#ae81ff">2L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;VVB&#34;</span>, <span style="color:#e6db74">&#34;ert&#34;</span>, <span style="color:#ae81ff">3L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;TgR&#34;</span>, <span style="color:#e6db74">&#34;uik&#34;</span>, <span style="color:#ae81ff">4L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">5L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">6L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> hh(Customer(<span style="color:#e6db74">&#34;Gdf&#34;</span>, <span style="color:#e6db74">&#34;pii&#34;</span>, <span style="color:#ae81ff">7L</span>)) <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> s.bucket_count(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bucked #&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;has&#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.bucket_size(i) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;element</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// bucked #0has1element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #1has0element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #2has1element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #3has1element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #4has2element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #5has0element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #6has0element
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bucked #7has2element
</span></span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="类型2fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_hash_function
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Customer</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            string fname;
</span></span><span style="display:flex;"><span>            string lname;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> on;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                Customer( string fn,  string ln, <span style="color:#66d9ef">int</span> id) <span style="color:#f92672">:</span> fname(fn), lname(ln), on(id) {}
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> other) <span style="color:#66d9ef">const</span> {<span style="color:#75715e">//需要重载==
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">return</span> fname <span style="color:#f92672">==</span> other.fname <span style="color:#f92672">&amp;&amp;</span> lname <span style="color:#f92672">==</span> other.lname <span style="color:#f92672">&amp;&amp;</span> on <span style="color:#f92672">==</span> other.on;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerHash</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            size_t customer_hash_func(<span style="color:#66d9ef">const</span> Customer<span style="color:#f92672">&amp;</span> c) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> ...;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        unordered_set<span style="color:#f92672">&lt;</span>Customer, size_t(<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">const</span> Custromer<span style="color:#f92672">&amp;</span>)<span style="color:#f92672">&gt;</span> custsct(<span style="color:#ae81ff">20</span>,customer_hash_func);<span style="color:#75715e">//注意与类型1的不同写法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="类型3fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;">
      <div class="tab-content-text">
<p>第三种方式是对类里面的hash进行偏特化，比如你使用了unordered_set那么对于它的Hash，可以单独进行偏特化。
<a href="#R-image-1d2214ada9e066c00ca539a899f5b6eb" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1d2214ada9e066c00ca539a899f5b6eb"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/image.png"></a></p>
      </div>
    </div>
  </div>
</div>
<h2 id="tuple">tuple</h2>
<p>在C++中，tuple 是一个标准库模板类，它提供了一种方式来存储不同类型数据的集合。tuple 类似于一个固定大小的数组，但是数组中的每个元素可以是不同的类型。这个特性使得 tuple 非常灵活，可以用于多种场景。</p>
<p><a href="#R-image-7e6ffb0a09dfc1aa891375c1194cc6f3" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e6ffb0a09dfc1aa891375c1194cc6f3"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/12.%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D/image-1.png"></a>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div></p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月29日
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="11stl库学习之适配器">11.STL库学习之适配器</h1>

<h2 id="整体框架的回顾">整体框架的回顾</h2>
<p><a href="#R-image-7812b2acbe5986c16a7867ed6b2d1ce0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7812b2acbe5986c16a7867ed6b2d1ce0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image.png"></a></p>
<h2 id="存在多种适配器-adapters">存在多种适配器-adapters</h2>
<p>一个人理解，要将适配器理解透彻，我们需要先从别的组件入手，这里以vector容器为例，我们都知道该容器需要迭代器，也就是一些智能指针来确定容器的头尾，以及内容位置，目的是方便后续的算法的怎删改查等操作，假设算法现在要做拿到位置8的数据，那么vector的指针要怎么移动呢？已知指针移动上，vector是随机访问指针，也就是前后都可以跑，而这个操作实际上是迭代器的其中一个内容，而这一内容就需要一个适配器去做适配。</p>
<p>下面做一个模拟问答，来加以了解：</p>
<p>&mdash;c
模拟问答
算法：你好，vector的迭代器，我需要知道你的迭代器类别，这样我才能正确地进行操作。</p>
<pre><code>vector的迭代器：好的，我先问一下我的适配器。

vector的迭代器：适配器，算法想知道 iterator_traits&lt;InputIterator&gt;::iterator_category 是什么类型的迭代器？

vector_iterator的适配器：你好，我们这里是随机访问迭代器（Random Access Iterator）。

算法：太好了，随机访问迭代器可以让我进行更高效的操作。那么，如果我想访问第8个元素，我该怎么做？

vector_iterator的适配器：很简单，你可以直接通过加上偏移量来访问第8个元素。比如，如果你有一个指向第一个元素的迭代器 first，那么 first + 7（因为迭代器是从0开始计数的）就会给你第8个元素的迭代器。

算法：明白了，那我可以直接使用 *(first + 7) 来获取第8个元素的值了。

vector_iterator的适配器：是的，完全正确。

算法：如果我需要反向迭代器，或者插入迭代器，你们能提供吗？

vector_iterator的适配器：当然可以。我们 vector 提供了多种迭代器适配器，包括反向迭代器（reverse_iterator）、插入迭代器（insert_iterator）等，以满足不同的需求。

算法：那太好了，这样我可以更灵活地处理 vector 中的数据了。谢谢你的帮助！
</code></pre>
<hr>
<h2 id="stl中适配器的重要特性">STL中适配器的重要特性</h2>
<p>对于容器、迭代器和仿函数它们第二次迭代器都有一个重要的特性，就是适配器会包含（也有继承）对应的类，比如stack包含了deque，然后使用了deque的某些功能，屏蔽了deque的某些某能，实现了先进后出的功能。</p>
<h2 id="仿函数适配器">仿函数适配器</h2>
<h3 id="binder2nd适配器">binder2nd适配器</h3>
<p>该适配器是用于绑定的，比如对于一个容器，需要操作比88小于数，这使用可以用binder2nd，第一个参数可以传入比较大小的less仿函数，第二个传入比较的数值x，本质上在binder2nd中，less的第二个参数传入就是x,这样就达到比较的目的了。
<a href="#R-image-78b0ea978bc8b2c42174246f5f98d9a0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-78b0ea978bc8b2c42174246f5f98d9a0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-1.png"></a>
小结：把A类和数值a传入另一个类B中，在B中再操作A和a.这样就实现了绑定。</p>
<h3 id="not1">not1</h3>
<p>对结果取反
<a href="#R-image-923a71d8686f2a8cc939c02d72819a1e" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-923a71d8686f2a8cc939c02d72819a1e"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-2.png"></a></p>
<h3 id="一些新的适配器">一些新的适配器</h3>
<p><a href="#R-image-8b2eaf1f8376c4c3952ce31116a53b5d" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8b2eaf1f8376c4c3952ce31116a53b5d"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-3.png"></a></p>
<h3 id="bind">bind</h3>
<p><a href="#R-image-d87fad33358033c0720c4ff7bfd66e89" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d87fad33358033c0720c4ff7bfd66e89"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-4.png"></a></p>
<h2 id="迭代器适配器">迭代器适配器</h2>
<h3 id="reverseiterator">reverse——iterator</h3>
<p>三个细节：</p>
<ul>
<li>1.begin=rend,end=rbigin</li>
<li>2.取值是取后一个，所以内部实现的*是做&ndash;操作；</li>
<li>3.operate ++()操作重载后内部实现为&ndash;，operate &ndash;()重载后内部实现++操作。</li>
</ul>
<p>具体图下图所示
<a href="#R-image-0ee36e7019234161763ed36713e0be36" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0ee36e7019234161763ed36713e0be36"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-6.png"></a></p>
<h3 id="insert_iterator">insert_iterator</h3>
<p>在下面的案例中<code>copy(bar.begin(),bar.end(),inserter(foo,it));</code>欲将list的bar数据从it指向的位置
开始插入，但是foo的空间不够，为什么还能成功？</p>
<p>设计的小技巧，当传入copy中时，因为inserter对operate =()做了重载，重载中调用了insert()该函数能决绝以上问题，
因此不会因为foo的内存不足导致插入失败。
<a href="#R-image-2651e18ca127b3190a49c1cf37c23a92" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2651e18ca127b3190a49c1cf37c23a92"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-7.png"></a></p>
<h3 id="ostream_iterator">ostream_iterator</h3>
<p>下面通过一个案例说明该迭代器的一些特性和使用方法：</p>
<p>1.当执行初始化操作std::ostream_iterator<int> out_it(std::cout,&quot;,&quot;)时调用构造函数，并初始化。
2.执行copy操作时，因为ostream_iterator对operate =()重载，所以会将值value传给*out_stream，通过这个方法把数据打印在屏幕上。
<a href="#R-image-f4373287eea385903da3bd7a4749dcd0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f4373287eea385903da3bd7a4749dcd0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-5.png"></a></p>
<h3 id="istream_iterator">istream_iterator</h3>
<p>下面也是两个例子说明istream_iterator的特性：</p>
<p>1.<code>std::istream_iterator&lt;double&gt; iit(std::cin);</code>时同样会调用对应的构造函数，并且此处会调用<code>operate ++()</code>重载，在该重载中，<code>*in_stream</code>接收按键输入的一个值，也就是说才定义时，就已经在准备接收一个值，如果此时在该语句下写一段打印操作没见无法看到输出！
<a href="#R-image-521e74999d65834d5286ac6709f04d59" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-521e74999d65834d5286ac6709f04d59"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-8.png"></a></p>
<p>2.下面是<code>copy</code>操作，对于这个操作，我们可以观察是否有对<code>*</code>和<code>=</code>的操作符进行重载，对于<code>=</code>的重载上述已经介绍， <code>*</code>的重载是将value返回，也就是 <code>*first</code>的操作取得的是容器中的值。
<a href="#R-image-edf4de79b9a3b1897e8a6ecd307dfa1c" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-edf4de79b9a3b1897e8a6ecd307dfa1c"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/11.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8/image-9.png"></a></p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月29日
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="10stl库学习之仿函数">10.STL库学习之仿函数</h1>

<h2 id="仿函数的个人理解">仿函数的个人理解</h2>
<p>仿函数是行为类似函数的一个类，比较明显的特征是仿函数重载了operate()，比如你写了一个struct，并在里面重载了operate()，当调用这个类的()时就会返回响应的数据。</p>
<p>你的理解是正确的，仿函数（functor）是 C++ 中的一个概念，它指的是那些可以像函数一样被调用的对象。这些对象通常重载了函数调用操作符 <code>operator()</code>，使得对象可以被当作函数来使用。以下是对你描述的一些补充说明：</p>
<h3 id="仿函数的特点">仿函数的特点</h3>
<ol>
<li>
<p><strong>重载 <code>operator()</code></strong>：仿函数类必须重载函数调用操作符 <code>operator()</code>，这样对象就可以被像函数那样调用。</p>
</li>
<li>
<p><strong>可以携带状态</strong>：与普通函数不同，仿函数可以拥有成员变量，这意味着它们可以携带状态。这些状态可以是私有的，也可以是公开的，取决于仿函数的设计。</p>
</li>
<li>
<p><strong>可以进行重载</strong>：仿函数可以重载 <code>operator()</code>，以接受不同数量和类型的参数。</p>
</li>
<li>
<p><strong>可以定义在类中</strong>：仿函数可以是类的成员函数，也可以是独立的类。</p>
</li>
<li>
<p><strong>可以有返回值</strong>：当仿函数被调用时，可以返回一个值，就像普通函数那样。</p>
</li>
<li>
<p><strong>可以作为参数传递</strong>：由于仿函数可以像函数一样被调用，它们可以作为参数传递给接受函数作为参数的函数。</p>
</li>
</ol>
<h3 id="仿函数的应用">仿函数的应用</h3>
<ol>
<li>
<p><strong>算法的参数</strong>：仿函数经常用作 STL 算法的参数，例如 <code>std::sort</code> 和 <code>std::find_if</code>，因为这些算法需要一个可以被调用的实体来比较元素或测试条件。</p>
</li>
<li>
<p><strong>回调函数</strong>：在事件驱动的编程中，仿函数可以作为回调函数，响应特定的事件。</p>
</li>
<li>
<p><strong>策略模式</strong>：在设计模式中，仿函数可以用于实现策略模式，允许算法的行为在运行时动态改变。</p>
</li>
<li>
<p><strong>简化代码</strong>：通过使用仿函数，可以减少函数指针和全局函数的使用，使得代码更加简洁和易于管理。</p>
</li>
</ol>
<h3 id="示例代码">示例代码</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Max</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重载()操作符，使其可以被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (a <span style="color:#f92672">&gt;</span> b) <span style="color:#f92672">?</span> a : b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Max max_functor;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> max_functor(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>); <span style="color:#75715e">// 使用仿函数对象调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Max value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>在这个例子中，<code>Max</code> 是一个仿函数，它重载了 <code>operator()</code> 来比较两个整数并返回最大值。然后，我们可以像调用函数一样调用 <code>max_functor</code> 对象。</p>
<h2 id="仿函数内部一般设计什么">仿函数内部一般设计什么？</h2>
<p>仿函数一般重载operate()后，会在内部设计运算操作，如算数、逻辑、相对关系等运算。如下图所示。
<a href="#R-image-5cbbc3a60920b71bd1332d1e2656ba4c" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5cbbc3a60920b71bd1332d1e2656ba4c"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image.png"></a>
从上面一张图也可以发现，plus,minus,logical_and,equal_to,less类都集成了binary_function，该类的作用是什么呢？</p>
<p><code>std::binary_function</code> 的主要作用是：</p>
<ol>
<li><strong>泛型框架</strong>：提供一个泛型框架，允许函数对象接受任意类型的参数。</li>
<li><strong>类型转换</strong>：允许参数类型和返回类型的转换，使得函数对象可以用于不同的数据类型。</li>
<li><strong>模板编程</strong>：支持模板编程，使得可以创建通用的算法和函数。</li>
</ol>
<ul>
<li><strong>原型</strong></li>
</ul>
<p><code>std::binary_function</code> 的原型如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Arg1Type</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Arg2Type</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResultType</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">binary_function</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> Arg1Type first_argument_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> Arg2Type second_argument_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> ResultType result_type;
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<ul>
<li>
<p><code>Arg1Type</code>：第一个参数的类型。</p>
</li>
<li>
<p><code>Arg2Type</code>：第二个参数的类型。</p>
</li>
<li>
<p><code>ResultType</code>：函数返回值的类型。</p>
</li>
<li>
<p><strong>继承和使用</strong></p>
</li>
</ul>
<p>函数对象如 <code>std::plus</code>, <code>std::minus</code>, <code>std::logical_and</code>, <code>std::equal_to</code>, <code>std::less</code> 等都继承自 <code>std::binary_function</code>。这意味着这些函数对象都定义了 <code>first_argument_type</code>, <code>second_argument_type</code>, 和 <code>result_type</code> 这三个类型别名，它们分别表示函数对象接受的第一个参数类型、第二个参数类型和返回值类型。</p>
<p>关于 <code>std::binary_function</code>的具体细节在适配器一节会重点讲到。</p>
<p>下图是是否继承binary_function的一些示例，如果不继承会怎么样呢？以我个人的理解，继承会让仿函数的扩展性更高，它将来可以扩展出更好的功能。如下图所示。
<a href="#R-image-20b40c6edcd715f6493e8b7b974de6b0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-20b40c6edcd715f6493e8b7b974de6b0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image-1.png"></a></p>
<p>除了上面讲到的binary_function还有unary_function，该类是针对单个变量的操作，比如取反，加加。如下图：
<a href="#R-image-0e7a273debc509f9568cee9555a593c9" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0e7a273debc509f9568cee9555a593c9"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/10.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BB%BF%E5%87%BD%E6%95%B0/image-2.png"></a></p>
<p>关于binary_function的细节此处先不介绍，下一节将着重说明。</p>
<p>对于仿函数，鲜明的特点就是对operate()做了重载，这样的类创建出来的对象叫仿函数对象，具有函数的行为。如果要对重载做更多操作需要结合一些仿函数适配器，比如相面讲到的binary_function和unary_funtion。</p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月29日
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="9stl库学习之迭代器与算法">9.STL库学习之迭代器与算法</h1>

<h2 id="标准库常用算法">标准库常用算法</h2>
<p><a href="#R-image-fdc53975170a99c5b5da198d4afa1ac2" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fdc53975170a99c5b5da198d4afa1ac2"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image.png"></a></p>
<h2 id="迭代器">迭代器</h2>
<h3 id="迭代器-的分类">迭代器-的分类</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">input_iterator_tag</span> {}<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">output_iterator_tag</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">forward_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> input_iterator_tag{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">bidirectional_iterator_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> forward_iterator_tag{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">random_access_tag</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> bidirectional_iterator_tag {};</span></span></code></pre></div>
<p>以上5中迭代器的继承关系，如下图所示。
<a href="#R-image-b05ab556d9f670b471b8d6bf3bbb8042" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b05ab556d9f670b471b8d6bf3bbb8042"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-1.png"></a></p>
<p>1.Input Iterator（输入迭代器）：
输入迭代器是最基本的迭代器类型，支持单向遍历，只能向前移动。</p>
<p>用法示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>input_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> vec.begin();
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span> (it <span style="color:#f92672">!=</span> vec.end()) {
</span></span><span style="display:flex;"><span>         std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>     }</span></span></code></pre></div>
<p>2.Forward Iterator（前向迭代器）：
前向迭代器支持双向遍历，可以向前和向后移动。</p>
<p>用法示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lst <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>forward_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> lst.begin();
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span> (it <span style="color:#f92672">!=</span> lst.end()) {
</span></span><span style="display:flex;"><span>         std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>     }</span></span></code></pre></div>
<p>3.Output Iterator（输出迭代器）：
输出迭代器允许对容器中的元素进行写操作，但不支持读操作。</p>
<p>用法示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>back_insert_iterator<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> it(vec);
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">*</span>it <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 写操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">*</span>it <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 写操作
</span></span></span></code></pre></div>
<p>4.Bidirectional Iterator（双向迭代器）：
双向迭代器支持双向遍历，可以向前和向后移动。</p>
<p>用法示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> lst <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>bidirectional_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> lst.end();
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span> (it <span style="color:#f92672">!=</span> lst.begin()) {
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">--</span>it;
</span></span><span style="display:flex;"><span>         std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>     }</span></span></code></pre></div>
<p>5.Random Access Iterator（随机访问迭代器）：
随机访问迭代器支持任意位置的快速访问，类似于指针操作。</p>
<p>用法示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>     std<span style="color:#f92672">::</span>random_access_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> it <span style="color:#f92672">=</span> vec.begin();
</span></span><span style="display:flex;"><span>     it <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 随机访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;</span></span></code></pre></div>
<h2 id="各种容器的迭代器类型">各种容器的迭代器类型</h2>
<p>测试代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iterator&gt;</span><span style="color:#75715e"> 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_iterator_category
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> display_category(T itr) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>iterator_category cagy; <span style="color:#75715e">// 使用 std::iterator_traits 获取迭代器类别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 这里不需要递归调用 display_iterator 函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">typeid</span>(cagy).name() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_iterator_category....................</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            display_category(array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(forward_list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            display_category(set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(multiset<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>            display_category(multiset<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            display_category(istream_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>());
</span></span><span style="display:flex;"><span>            display_category(ostream_iterator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(cout,<span style="color:#e6db74">&#34;&#34;</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>此处可以参考一下<code>display_category(array&lt;int, 10&gt;::iterator());</code>中传递<code>array&lt;int, 10&gt;::iterator()</code>的方法。</p>
<p>测试结果：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>test_iterator_category....................
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>random_access_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>random_access_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>forward_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>random_access_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>bidirectional_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>input_iterator_tag
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">std</span><span style="color:#f92672">::</span>output_iterator_tag</span></span></code></pre></div>
<h2 id="迭代器对算法的影响">迭代器对算法的影响</h2>
<h3 id="例子1-distance">例子1-distance</h3>
<p>迭代器如何计算容器元素之间的距离呢？当调用迭代器时，迭代器是如何操作以协助算法完成后续的增删改查的？</p>
<p>在计算距离方面，我们可以看到调用接口需要传入容器的头，以及容器尾部，接着使用：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>InputIterator<span style="color:#f92672">&gt;::</span>itrerator_category category;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__distance</span>(first,last, category);</span></span></code></pre></div>
<p><code>typedef typename iterator_traits&lt;InputIterator&gt;::itrerator_category category;</code>这一句会判断迭代器的类型，进而执行加操作或一步一步加操作。详细如下图所示。
<a href="#R-image-fc653536eb4bb961a531cd12b5560696" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fc653536eb4bb961a531cd12b5560696"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-2.png"></a></p>
<h3 id="例子2-copy">例子2-copy</h3>
<p>copy的动作也不仅仅是对迭代器类型的判断，还做了许多特化、偏特化。如下图所示。
<a href="#R-image-1b6d8c55197c70d7a74e25fd02e6114b" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1b6d8c55197c70d7a74e25fd02e6114b"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-3.png"></a></p>
<h3 id="例子3-destroy">例子3-destroy</h3>
<p><a href="#R-image-53bdc7654c24b7996ca7bd8fe4de5c22" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-53bdc7654c24b7996ca7bd8fe4de5c22"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-4.png"></a></p>
<h3 id="例子4-__unique_copy">例子4-__unique_copy</h3>
<p><a href="#R-image-31103bdbb65347f959dc754366083bd7" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-31103bdbb65347f959dc754366083bd7"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-5.png"></a></p>
<h2 id="对传入的迭代器类型的暗示">对传入的迭代器类型的暗示</h2>
<p>在调用一些需要传入迭代器的函数时，从函数的形参名可以判断传入的迭代器类型，如InputIterator，由于forward_iterator_tag、bidirection_iterator_tag、random_asccess_iterator_tag与input_iterator的继承关系可知，前三者都可以传入，以此类推如果形参是forward_iterator_tag那么除了其本身，bidirection_iterator_tag、random_asccess_iterator_tag也可传入。</p>
<p><a href="#R-image-82a7fe0a8213cd768c38af94a708e599" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-82a7fe0a8213cd768c38af94a708e599"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-6.png"></a></p>
<h2 id="算法源码剖析">算法源码剖析</h2>
<h3 id="accumulate-累计">accumulate-累计</h3>
<p><a href="#R-image-a0f08e4c2a3839b8d7bc2f46599c8d66" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a0f08e4c2a3839b8d7bc2f46599c8d66"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-7.png"></a></p>
<p>测试用例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;functional&gt;</span><span style="color:#75715e">//std::minus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;numeric&gt;</span><span style="color:#75715e">//std::accumulate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> test_accumulate
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">myfcn</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) { <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> y; }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">myclass</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) { <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> y; }
</span></span><span style="display:flex;"><span>        } myobj;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> init <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nums[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>};
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> accumulate(nums, nums <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>, init)<span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//40
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> accumulate(nums, nums <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>, init, test_accumulate<span style="color:#f92672">::</span>myfcn)<span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//70
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> accumulate(nums, nums <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>, init, test_accumulate<span style="color:#f92672">::</span>myobj) <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }</span></span></code></pre></div>
<h3 id="for_each">for_each</h3>
<p>拿到每一个元素时都对该元素执行某一操作。
<a href="#R-image-6e11c139b6657ad13dd590e700980ab3" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6e11c139b6657ad13dd590e700980ab3"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-8.png"></a></p>
<p>测试用例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> test_for_each
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myfcn</span>(<span style="color:#66d9ef">int</span> i) { cout<span style="color:#f92672">&lt;&lt;</span>i<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;-&#34;</span>; }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">myclass</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span> i) { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;] &#34;</span>; }
</span></span><span style="display:flex;"><span>        } myobj;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>            vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            c.push_back(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>            c.push_back(<span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>            c.push_back(<span style="color:#ae81ff">30</span>);
</span></span><span style="display:flex;"><span>            for_each(c.begin(), c.end(), test_for_each<span style="color:#f92672">::</span>myfcn);<span style="color:#75715e">//10-20-30-
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            for_each(c.begin(), c.end(), test_for_each<span style="color:#f92672">::</span>myobj);<span style="color:#75715e">//[10] [20] [30]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="replacereplace_ifrreplace_copy">replace,replace_if,rreplace_copy</h3>
<p>replace用于将新值替换为旧值，例如将数组中所有的8替换为9.详细源码如下图所示。
<a href="#R-image-432844fdd331e16c7013da60736e5fe9" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-432844fdd331e16c7013da60736e5fe9"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-9.png"></a></p>
<p><code>replace</code>、<code>replace_if</code> 和 <code>replace_copy</code> 是 C++ 标准库中的算法，它们用于在容器或数组中替换元素。这些函数属于 <code>&lt;algorithm&gt;</code> 头文件。下面是每个函数的详细介绍和作用：</p>
<h3 id="1-replace">1. <code>replace</code></h3>
<p><code>replace</code> 函数用于将容器中所有满足特定条件的元素替换为另一个值。这个函数直接在原容器上操作，不创建新的容器。</p>
<p><strong>函数原型</strong>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">replace</span>(ForwardIterator first, ForwardIterator last, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> old_value, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> new_value);</span></span></code></pre></div>
<ul>
<li><code>first</code>, <code>last</code>：定义了要替换元素的范围。</li>
<li><code>old_value</code>：要被替换的值。</li>
<li><code>new_value</code>：替换后的值。</li>
</ul>
<p><strong>示例</strong>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>replace(v.begin(), v.end(), <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// v 变为 {1, 5, 3, 4, 3, 5}
</span></span></span></code></pre></div>
<h3 id="2-replace_if">2. <code>replace_if</code></h3>
<p><code>replace_if</code> 函数用于将容器中满足特定条件的元素替换为另一个值。与 <code>replace</code> 不同，<code>replace_if</code> 需要一个谓词（条件函数），只有满足这个条件的元素才会被替换。这个函数也直接在原容器上操作。</p>
<p><strong>函数原型</strong>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">replace_if</span>(ForwardIterator first, ForwardIterator last, Predicate pred, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> new_value);</span></span></code></pre></div>
<ul>
<li><code>first</code>, <code>last</code>：定义了要替换元素的范围。</li>
<li><code>pred</code>：一个谓词函数，返回 <code>true</code> 表示替换，<code>false</code> 表示不替换。</li>
<li><code>new_value</code>：替换后的值。</li>
</ul>
<p><strong>示例</strong>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>replace_if(v.begin(), v.end(), [](<span style="color:#66d9ef">int</span> i) { <span style="color:#66d9ef">return</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>; }, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// v 变为 {1, 5, 3, 4, 3, 5}
</span></span></span></code></pre></div>
<h3 id="3-replace_copy">3. <code>replace_copy</code></h3>
<p><code>replace_copy</code> 函数用于将容器中所有满足特定条件的元素复制到另一个容器中，并替换为另一个值。这个函数不会改变原容器，而是创建一个新的容器，其中包含替换后的元素。</p>
<p><strong>函数原型</strong>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIterator</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OutputIterator</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> old_value, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> new_value);</span></span></code></pre></div>
<ul>
<li><code>first</code>, <code>last</code>：定义了要替换元素的范围。</li>
<li><code>result</code>：指向目标容器的迭代器，用于存储替换后的元素。</li>
<li><code>old_value</code>：要被替换的值。</li>
<li><code>new_value</code>：替换后的值。</li>
</ul>
<p><strong>示例</strong>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>};
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v2(v.size());
</span></span><span style="display:flex;"><span>replace_copy(v.begin(), v.end(), v2.begin(), <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// v 保持不变，v2 变为 {1, 5, 3, 4, 3, 5}
</span></span></span></code></pre></div>
<h3 id="countcount_if">count，count_if</h3>
<p>源代码如下：
<a href="#R-image-b59c0d0748d99a029a91b350a83dc4c1" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b59c0d0748d99a029a91b350a83dc4c1"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-10.png"></a></p>
<p>小结：
<a href="#R-image-7e4b7e0bc85c4ba7a194abaf7dbe975d" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-11.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7e4b7e0bc85c4ba7a194abaf7dbe975d"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-11.png"></a></p>
<h3 id="findfind_if">find，find_if</h3>
<p><a href="#R-image-3f4bcad645dd2a0ebb29673f5ec78710" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-12.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3f4bcad645dd2a0ebb29673f5ec78710"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-12.png"></a></p>
<h3 id="sort">sort</h3>
<p><a href="#R-image-1df3a06e1ba2fe630a28a8b9511b745a" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-13.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1df3a06e1ba2fe630a28a8b9511b745a"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-13.png"></a></p>
<h3 id="binary_search">binary_search</h3>
<p><a href="#R-image-dc5e312486c0fd02aa7118d97814e68c" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-14.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dc5e312486c0fd02aa7118d97814e68c"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/9.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%AE%97%E6%B3%95/image-14.png"></a></p>
<p><strong>算法原理：</strong></p>
<p>二分查找的基本思想是将一个有序序列分为两半，通过比较中间元素和目标值来缩小搜索范围。如果中间元素正好是目标值，则查找成功；如果目标值小于中间元素，则在序列的左半部分继续查找；如果目标值大于中间元素，则在右半部分继续查找。这个过程不断重复，直到找到目标值或搜索范围为空。</p>
<p><strong>函数原型：</strong></p>
<p><code>binary_search</code> 的函数原型如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForwardIterator</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> binary_search(ForwardIterator first,
</span></span><span style="display:flex;"><span>                   ForwardIterator last,
</span></span><span style="display:flex;"><span>                   <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> value);</span></span></code></pre></div>
<ul>
<li><code>first</code>, <code>last</code>：定义了要搜索的范围，<code>first</code> 是序列的开始迭代器，<code>last</code> 是序列的结束迭代器（指向序列末尾的下一个位置）。</li>
<li><code>value</code>：要查找的值。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果在序列中找到 <code>value</code>，则返回 <code>true</code>。</li>
<li>如果没有找到，则返回 <code>false</code>。</li>
</ul>
<p><strong>示例代码：</strong></p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> data <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> found <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>binary_search(data.begin(), data.end(), target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (found) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Element found in the array.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Element not found in the array.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p><strong>注意事项：</strong></p>
<ol>
<li><strong>有序序列</strong>：<code>binary_search</code> 要求序列必须是有序的，否则查找结果将不可预测。</li>
<li><strong>效率</strong>：二分查找的时间复杂度为 O(log n)，其中 n 是序列中的元素数量。这使得它比线性查找（O(n)）更高效，尤其是在大数据集上。</li>
<li><strong>稳定性</strong>：如果存在多个相同的目标值，<code>binary_search</code> 将返回第一个匹配的位置。如果需要找到所有匹配项，可能需要使用其他方法。</li>
</ol>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月26日
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="8stl库学习之容器">8.STL库学习之容器</h1>

<h2 id="list">list</h2>
<h2 id="vector">vector</h2>
<h2 id="deque">deque</h2>
<p><a href="#R-image-3cbb104bcbb495834824b39d8987d43f" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image.png?height=350px&width=600px" style=" height: 350px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3cbb104bcbb495834824b39d8987d43f"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image.png?height=350px&width=600px"></a></p>
<p>deque的迭代器
<a href="#R-image-75c26c0f335f3b268ef8057e2b65d673" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-1.png?height=350px&width=600px" style=" height: 350px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-75c26c0f335f3b268ef8057e2b65d673"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-1.png?height=350px&width=600px"></a></p>
<p>deque实现中间插入值的做法：如果欲插入值在最前端（最尾端）调用<code>push_front()</code>（<code>push_back()</code>）,否则借助<code>insert_aux()</code>迭代器，实现如果欲插入位置靠近前端使用，就让前端的数据往前挪，否则往后挪。</p>
<p>deque中+=的实现：1.先计算+=后是否超过缓冲区，如果没有则直接+=，否则需要判断需要跨几个缓冲区，然后再去确定前进几个缓冲区。
<a href="#R-image-504264951e00bb5c555a1b2366f7c4ba" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-2.png?height=350px&width=600px" style=" height: 350px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-504264951e00bb5c555a1b2366f7c4ba"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-2.png?height=350px&width=600px"></a></p>
<p><strong>Vector的内存扩充：</strong></p>
<p>std::vector 在需要更多空间时，通常会将容量增加到当前大小的两倍（这是最常见的增长策略，但不是唯一的，具体实现可能有所不同）。</p>
<p>当发生扩充时，std::vector 会分配一个新的更大的内存块，然后将所有元素从旧内存块复制到新内存块，最后释放旧内存块。</p>
<p><strong>Deque的内存扩充：</strong></p>
<p>std::deque（双端队列）的内存管理机制与 std::vector 不同。std::deque 是一个使用多个固定大小的内存块来存储元素的容器，这些内存块被称为“chunks”或“maps”。</p>
<p>当 std::deque 需要更多空间时，它可能会在已有的内存块之后添加新的内存块，或者在前面添加，这取决于哪个方向上的空间更紧张。
std::deque 不会像 std::vector 那样将所有元素复制到一个新的连续内存块中，而是在多个内存块之间分配元素。</p>
<h2 id="stack和queue">stack和queue</h2>
<p>stack和queue默认使用deque的功能来分别实现先进后出和先进先出的功能，除此之外还可以使用list，stack还可以使用vector，但是deque就不能用vector，以我的理解，是因为vector不提供后端操作。</p>
<h2 id="rb-tree">Rb-tree</h2>
<p>在C++中，set和map的底层实现都是基于红黑树（RB-tree）。红黑树是一种自平衡的二叉搜索树，能够保证在最坏情况下，插入、删除和查找操作的时间复杂度均为O(log n)。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>  <span style="color:#66d9ef">int</span> key,
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> value,
</span></span><span style="display:flex;"><span>                identity<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>                less<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>                alloc
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">rb_tree</span>;</span></span></code></pre></div>
<p><strong>set 和 map 的区别：</strong></p>
<p>set：set中的元素是唯一的键值，即Key和Value是同一个。插入时使用insert_unique()方法，确保键值不重复。</p>
<p>map：map中的元素是键值对（Key-Value），键值用于索引，值表示与索引相关联的数据。插入时使用insert_equal()方法，允许键值重复。</p>
<p><strong>红黑树的结构：</strong></p>
<p>红黑树的结构包括节点、根节点、最左节点和最右节点等。根节点通过header.parent保存，最左节点通过header.left保存，最右节点通过header.right保存。</p>
<ul>
<li>插入操作
<ul>
<li>set：插入操作调用insert_unique()，确保键值唯一。</li>
<li>map：插入操作调用insert_equal()，允许键值重复。</li>
</ul>
</li>
<li>迭代器
<ul>
<li>set：迭代器是RB-tree的const_iterator，不允许修改元素值。</li>
<li>map：迭代器也是RB-tree的const_iterator，但允许修改元素的值（因为值部分不是键）。</li>
</ul>
</li>
</ul>
<h2 id="set和multiset">set和multiset</h2>
<p>set与map的底层实现基本可以参考下面的源码图，</p>
<p><a href="#R-image-1e95a74dddaa7716a20f3730877481a0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-3.png?height=350px&width=600px" style=" height: 350px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1e95a74dddaa7716a20f3730877481a0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-3.png?height=350px&width=600px"></a></p>
<p>需要说明的一点是，在不允许更改键值上，二者的设计还是有区别，主要体现在set使用const_iterator,这样迭代器指向的键值就无法更改，而map在设计上在传进来的Key设置为const，确保键值不会被更改。</p>
<h2 id="hashtable-哈希表">hashtable-哈希表</h2>
<p>在C++中，hash_set、hash_map、hash_multiset和hash_multimap等数据结构的底层实现确实采用了哈希表的思想。具体来说，这些数据结构的设计核心是通过哈希函数将键（key）映射到数组的索引位置，从而实现高效的插入、删除和查找操作。</p>
<h3 id="数据存储的设计思想">数据存储的设计思想</h3>
<p>每个键值通过一个哈希函数计算出一个哈希值。这个哈希值通常是一个整数，用于确定键值在数组中的存储位置。例如，对于一个整数键值12，哈希函数可能会直接返回12，这样12就会被存储在数组的第12个位置。</p>
<p>哈希表的核心是一个数组（通常是一个vector），数组的每个元素（即每个位置）可以存储一个指针。这个指针指向一个单向链表的头节点。如果多个键值通过哈希函数计算出相同的哈希值，它们会被存储在同一个位置的链表中。参考下图：
<a href="#R-image-50bfca8aaee1f2a090886f0578052533" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-4.png?height=350px&width=600px" style=" height: 350px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-50bfca8aaee1f2a090886f0578052533"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-4.png?height=350px&width=600px"></a>
当多个键值映射到同一个哈希值时，这些键值会被存储在一个链表中。链表的每个节点包含一个键值和指向下一个节点的指针。这种设计允许在发生哈希冲突时，通过遍历链表来查找或插入特定的键值。
<a href="#R-image-7924ff04be559e443424266590ae394f" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-5.png?height=350px&width=600px" style=" height: 350px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7924ff04be559e443424266590ae394f"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-5.png?height=350px&width=600px"></a>
为了保持高效的性能，哈希表通常会有一个动态扩容机制。当哈希表中的元素数量超过一定阈值时，哈希表会自动重新分配更大的数组，并重新计算所有键值的哈希值，以减少链表的长度，从而提高查找效率。</p>
<p>在实际应用中，哈希函数可能会导致不同的键值计算出相同的哈希值，这种现象称为哈希冲突。常见的解决策略包括链地址法（即使用链表存储冲突的元素）和开放地址法（即在数组中寻找下一个空闲位置）。</p>
<h3 id="具体实现过程">具体实现过程</h3>
<ul>
<li>当插入一个新键值时，首先通过哈希函数计算出其哈希值，然后根据哈希值找到对应的数组位置。如果该位置已经有元素（即发生冲突），则将新元素插入到该位置的链表中。</li>
<li>查找操作同样通过哈希函数计算出键值的哈希值，然后根据哈希值找到对应的数组位置。如果该位置有元素，则遍历链表，直到找到匹配的键值或链表结束。</li>
<li>删除操作首先通过哈希函数计算出键值的哈希值，然后根据哈希值找到对应的数组位置。如果该位置有元素，则遍历链表，找到并删除匹配的键值。</li>
</ul>
<h3 id="实现代码">实现代码</h3>
<p>hashtable类的实现提供了六个模板参数。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">value</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">key</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">hashFcn</span>,<span style="color:#75715e">//计算编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">extractKey</span>,<span style="color:#75715e">//取出键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EqualKey</span>,<span style="color:#75715e">//判断类型是否相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Alloc</span><span style="color:#f92672">=</span>alloc
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p><a href="#R-image-986e15b58c057c9c8b63f19b9017602f" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-6.png?height=300px&width=600px" style=" height: 300px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-986e15b58c057c9c8b63f19b9017602f"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-6.png?height=300px&width=600px"></a></p>
<p>如果要自己使用这个哈希表，需要写hashFcn()的重载，对齐进行偏特化等操作,如下图：
<a href="#R-image-912d1a5b4ebecce79bb911b091409768" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-7.png?height=300px&width=600px" style=" height: 300px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-912d1a5b4ebecce79bb911b091409768"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-7.png?height=300px&width=600px"></a></p>
<p>如果传入的是字符串，那么字符串的编号计算可以参考下图计算方法：
<a href="#R-image-7c4c9b7b70c4deb070ba088ee0759a8c" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-8.png?height=300px&width=600px" style=" height: 300px; width: 600px;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7c4c9b7b70c4deb070ba088ee0759a8c"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/8.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8/image-8.png?height=300px&width=600px"></a>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div></p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月26日
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
  </ul>
</div>
  </header>

<h1 id="7stl库学习之分配器">7.STL库学习之分配器</h1>

<h2 id="分配器源代码位置xmemoryh">分配器源代码位置：xmemory.h</h2>
<p><a href="#R-image-39e2418d554b233f9e7ea793cf931454" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-39e2418d554b233f9e7ea793cf931454"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/7.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E9%85%8D%E5%99%A8/image.png"></a></p>
<p>除了array和vector外，其他容器的适配器必须是一个类，
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div></p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月23日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
  </ul>
</div>
  </header>

<h1 id="6stl库学习之筑基概要">6.STL库学习之筑基概要</h1>

<h2 id="stl程序源代码位置">STL程序源代码位置</h2>
<p>了解自身编译器STL程序源代码位置。</p>
<h2 id="oop-与-gp">OOP 与 GP</h2>
<p>面向对象编程（OOP）：</p>
<p>面向对象编程是一种编程范式，它将数据和处理这些数据的方法封装在对象中。这种方法强调了数据和函数的捆绑，使得代码更加模块化，易于理解和维护。对象可以包含属性（数据）和方法（函数），它们一起工作来模拟现实世界的行为。</p>
<p>补充说明：OOP 通过类（Class）来定义对象的蓝图，支持继承、封装和多态等特性，从而提高代码的重用性和灵活性。例如list中有自己的sort()函数，专门为list而设计，比::sort()的算法更优。</p>
<p>泛型编程（GP）：</p>
<p>泛型编程是一种编程范式，它允许开发者定义操作类型数据结构的函数和类，而不需要在编译时指定具体的数据类型。这种方法强调了数据和处理方法的分离，提供了更高的代码复用性和类型安全性。</p>
<p>补充说明：GP 通过模板（Templates）或泛型容器（如 std::vector、std::map）来实现，允许开发者写出与数据类型无关的代码，从而在不同的数据类型间共享相同的算法逻辑。例如vector和deque没有为自身设计sort(),在做排序操作时，需要调用::sort()来实现。</p>
<h2 id="操作符重载">操作符重载</h2>
<p>STL源码程序中会包含很多的操作符重载，一般你会看到operate修饰符，后面就紧跟着操作符。注意：<code>::</code>、<code>.</code>、<code>.*</code>和 <code>:?</code>不能进行操作符重载。</p>
<p>在我看来操作符重载是一个重要的特性，它可以让你实现任何类的运算法则，这些法则有你自己规定，操作空间还是比较宽泛。</p>
<h2 id="模版-template">模版-template</h2>
<p>最常见的写法如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FOO</span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="类模板">类模板</h3>
<p>最常见的写法如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FOO</span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="成员模版">成员模版</h3>
<h3 id="泛化特化和偏特化">泛化、特化和偏特化</h3>
<p>以我个人的理解，泛化是为了应对大部分的情况，特化是为了应对特殊的情况，或使用单独的方法处理对某些情况而言更好，偏特化比偏特化更近一步，把处理的手段限定在一定范围内，举个简单的例子，假设为设计计算两种情况的相加做如下定义：</p>
<p>1.泛化</p>
<p>泛化编程在C++中通过模板实现。以下是一个泛化编程的示例，其中 AND 类是一个模板类，可以处理任何类型的数据。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>,<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>2.特化</p>
<p>特化是对模板类或函数的特定实例化。以下是特化的示例，其中 AND 类被特化为处理 string 和 Text 类型：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 类的泛型实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span><span style="color:#f92672">&lt;</span>string, Text<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 类的特化实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };</span></span></code></pre></div>
<p>3.偏特化</p>
<p>偏特化允许对模板类的部分参数进行特化。以下是偏特化的示例，其中 AND 类被偏特化为处理第一个类型为 int 的情况：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 类的泛型实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AND</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 类的偏特化实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };</span></span></code></pre></div>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月23日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
    <li><a class="term-link" href="/tags/stl%E5%BA%93/">STL库</a></li>
  </ul>
</div>
  </header>

<h1 id="5stl库之观其大略">5.STL库之观其大略</h1>

<h2 id="一下主要讲stl组件的测试用例特别是容器的测试">一下主要讲STL组件的测试用例，特别是容器的测试</h2>
<h2 id="学习资料">学习资料</h2>
<ul>
<li>CPLusPlus.com</li>
<li>CppReference.com</li>
<li>gcc.gnu.org</li>
<li>《STL源码剖析》</li>
</ul>
<h2 id="stl六大组件">STL六大组件</h2>
<ul>
<li>容器-Containers，申请内存用于存储数据</li>
<li>分配器-Allocators，配合容器分配内存</li>
<li>算法- Algorithms，处理某一数据的最优办法</li>
<li>迭代器-  Iterators，指针的泛型，本质与指针类似</li>
<li>适配器- Adapters，</li>
<li>仿函数-Functors，类似函数。</li>
</ul>
<p>六者的关系</p>
<p><a href="#R-image-afc113180c10772a743ee57fecec4ec7" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-afc113180c10772a743ee57fecec4ec7"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png"></a></p>
<h2 id="begin和end">begin()和end()</h2>
<p>以迭代器为例，begin()指向迭代器的首地址，而end()指向迭代器尾地址的下一位，可以用前闭后开区间来表示，即**[ )**</p>
<h2 id="容器的分类">容器的分类</h2>
<p><a href="#R-image-57c2141206adc47a85f163d7b72a3b66" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-57c2141206adc47a85f163d7b72a3b66"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-1.png"></a>
<a href="#R-image-2c7ec244d45e3e7ae51891879d0147df" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c7ec244d45e3e7ae51891879d0147df"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-2.png"></a></p>
<h2 id="数组容器的使用">数组容器的使用</h2>
<h3 id="array-的使用">array 的使用</h3>
<div class="tab-panel" data-tab-group="f1a3c6470b470ceff909d78bb45dad1b">
  <div class="tab-nav">
    <div class="tab-nav-title">示例1</div>
    <button
      data-tab-item="h文件"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('f1a3c6470b470ceff909d78bb45dad1b','h文件')"
    >
      <span class="tab-nav-text">.h文件</span>
    </button>
    <button
      data-tab-item="testcode"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('f1a3c6470b470ceff909d78bb45dad1b','testcode')"
    >
      <span class="tab-nav-text">testCode</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('f1a3c6470b470ceff909d78bb45dad1b','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="h文件"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#75715e">#ifndef __AUXFUN__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#define __AUXFUN__
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#define RAMD_MAX 32767
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">get_a_target_long</span>()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;target (0--&#34;</span> <span style="color:#f92672">&lt;&lt;</span> RAMD_MAX <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;):&#34;</span>;
</span></span><span style="display:flex;"><span>            cin <span style="color:#f92672">&gt;&gt;</span> target;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> target;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//将数值转为string，这样可以测试类似object的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        string <span style="color:#a6e22e">get_a_target_string</span>()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;target (0--&#34;</span> <span style="color:#f92672">&lt;&lt;</span> RAMD_MAX <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;):&#34;</span>;
</span></span><span style="display:flex;"><span>            cin <span style="color:#f92672">&gt;&gt;</span> target;
</span></span><span style="display:flex;"><span>            snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> string(buf);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compareLongs</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> b)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)a <span style="color:#f92672">-</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)b);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            1.类型转换：因为参数是const void* 类型，你需要将它们转换为具体的数据类型指针（在这个例子中是long* ），以便可以解引用并获取它们的值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            2.解引用：在转换之后，通过在类型转换的结果前使用* 操作符来获取指针指向的实际值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            3.强制转换的结果：* (long*)a实际上是一个long值，它是通过解引用转换后的指针得到的。*/</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compareString</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> b)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)a <span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)b)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)a <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)b)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#endif </span><span style="color:#75715e">// !__ENTRY__
</span></span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="testcode"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;TestHeardFiles/AuxFun.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ctime&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">//qsort()、 bsearch()、 NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;array&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> size_t ASIZE <span style="color:#f92672">=</span> <span style="color:#ae81ff">50000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> t01
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_array</span>()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_array().............. </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>, ASIZE<span style="color:#f92672">&gt;</span> c;<span style="color:#75715e">//使用数组容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ASIZE; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                c[i] <span style="color:#f92672">=</span> rand();<span style="color:#75715e">//可以产生随机数的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli_seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//返回数组大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//返回数组最后一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;array.data: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.data() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//返回第一个数的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> get_a_target_long();
</span></span><span style="display:flex;"><span>            timeStart <span style="color:#f92672">=</span> clock();<span style="color:#75715e">//clock()返回毫秒数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            qsort(c.data(), ASIZE, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>), compareLongs);<span style="color:#75715e">//数组排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span> pItem <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span><span style="color:#f92672">*</span>)bsearch(<span style="color:#f92672">&amp;</span>target, (c.data()), ASIZE, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>), compareLongs);<span style="color:#75715e">//数组查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;qsort()+bsearch(),milli-seconds:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> clock() <span style="color:#f92672">-</span> timeStart <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>        t01<span style="color:#f92672">::</span>test_array();
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<p><a href="#R-image-2f5a89bf61865739fb70de6067d553c0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2f5a89bf61865739fb70de6067d553c0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-3.png"></a></p>
      </div>
    </div>
  </div>
</div>
<h3 id="vector-的使用">vector 的使用</h3>
<p>vector是一种向后自动以2次方增加的内存的容器，一般使用push_back向后添加数据；</p>
<p>vector也有一定的缺点，假设我只需要5个内存空间，但是vector分配的是8个，剩下的3个后面如果不使用就会浪费。</p>
<div class="tab-panel" data-tab-group="0e31efcfe03017b560a1c216bbf7132a">
  <div class="tab-nav">
    <div class="tab-nav-title">示例2</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('0e31efcfe03017b560a1c216bbf7132a','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('0e31efcfe03017b560a1c216bbf7132a','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdexcept&gt;</span><span style="color:#75715e"> </span><span style="color:#75715e">//obort()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">	</span><span style="color:#75715e">//snprintf()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">//sort()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t02
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_vector</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value) {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_vector()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_back(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_back()将数据存入容器尾部，这是vector的特性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">//同时值得注意，当空间不足时，内存会自动增加，怎么加方式是2的平方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.data(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.data() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;vector.capacity(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.capacity() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//返回的是向量当前分配的存储空间可以容纳的元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//进行排序后使用bsearch查找。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                sort(c.begin(), c.end());<span style="color:#75715e">//该算法将任何类型进行排序，需要提供相应的比较函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                string<span style="color:#f92672">*</span> pItem <span style="color:#f92672">=</span> (string<span style="color:#f92672">*</span>)bsearch(<span style="color:#f92672">&amp;</span>target, (c.data()), c.size(), <span style="color:#66d9ef">sizeof</span>(string), compareString);
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;sort()+bsearch(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<p><a href="#R-image-4e29432865d8b5b9bfdc9617fe7223c6" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4e29432865d8b5b9bfdc9617fe7223c6"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-4.png"></a></p>
      </div>
    </div>
  </div>
</div>
<p>从上面的结果来看，排序后使用二分查找反而比循环查找慢，原因在于排序话费了很多时间，因为string类型是一个object，其本身大小比较大，所以面对一个object进行查找时不建议使用排序后二分查找。</p>
<p>在实际应用中，选择排序加二分查找还是直接线性查找，需要根据具体情况来决定：</p>
<ul>
<li>如果容器已经排序，或者数据量不大，直接使用二分查找可能更简单、更快。</li>
<li>如果容器未排序，且数据量很大，那么可能需要考虑是否值得为了一次查找而进行排序，或者是否可以通过其他方式（如使用更高效的数据结构，如哈希表）来提高查找效率。</li>
<li>如果查找操作非常频繁，而插入和删除操作不频繁，那么维护一个已排序的容器可能是合理的，这样每次查找都可以利用二分查找的效率。</li>
</ul>
<p>总之，选择哪种方法取决于具体的应用场景和性能要求。在某些情况下，可能需要通过实验或性能分析来确定最佳的策略。</p>
<h3 id="链表容器-list">链表容器-list</h3>
<p>std::list 是 C++ 标准库中的一个容器，它提供了双向链表的实现。</p>
<p><strong>std::list 容器的特点：</strong></p>
<ul>
<li>双向链表结构：std::list 由一系列节点组成，每个节点包含一个元素和两个指针，分别指向前一个节点和后一个节点。</li>
<li>动态内存分配：std::list 中的每个节点都是独立分配内存的。这意味着当你添加或删除元素时，std::list 会为新元素分配内存，或释放不再使用的元素所占用的内存。</li>
<li>内存空间利用：由于 std::list 的元素是单独分配的，因此不存在像 std::vector 那样的连续内存块，也就不会有额外的内存浪费。每个元素恰好占用它所需的空间，加上一些指针存储开销。</li>
</ul>
<p><strong>查询操作效率：</strong></p>
<ul>
<li>查询效率较低：与 std::vector 或 std::array 这样的随机访问容器相比，std::list 的查询操作通常较慢。这是因为 std::list 没有提供快速的随机访问能力。</li>
<li>顺序访问：在 std::list 中，要访问一个特定位置的元素，你需要从头开始遍历，直到到达那个位置。这意味着访问时间与列表的大小成正比，最坏情况下的时间复杂度为 O(n)。</li>
<li>没有跳跃访问：与数组或 std::vector 不同，std::list 没有提供直接跳到任意位置的能力。在数组中，你可以通过简单的指针算术来访问任意位置的元素，而在 std::list 中，你必须遍历链表。</li>
</ul>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="ac04d327d590ab36c3bac43cd6f58e06">
  <div class="tab-nav">
    <div class="tab-nav-title">示例3</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('ac04d327d590ab36c3bac43cd6f58e06','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('ac04d327d590ab36c3bac43cd6f58e06','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t03
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_list</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_list()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_back(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_back()将数据存入容器尾部，这是vector的特性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">//同时值得注意，当空间不足时，内存会自动增加，怎么加方式是2的平方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//测试排序花费的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                c.sort();<span style="color:#75715e">//使用list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;list.sort(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_list</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1073</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">329406144173384850</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">41</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">back</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    found,<span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    list.<span style="color:#a6e22e">sort</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1611</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<p><strong>总结：</strong>
std::list 的优点在于它的灵活性和高效的插入/删除操作，这些操作可以在 O(1) 时间内完成，因为它们只需要修改几个指针。然而，这种灵活性的代价是牺牲了快速随机访问的能力。因此，如果你的应用场景中需要频繁地在序列中间插入或删除元素，而不太关心随机访问性能，std::list 是一个很好的选择。反之，如果随机访问是一个关键操作，那么可能需要考虑使用其他类型的容器。</p>
<h3 id="链表容器-forward_list">链表容器-forward_list</h3>
<p>std::forward_list 是 C++ 标准库中的一个容器，它提供了单向链表的实现。</p>
<p><strong>std::forward_list 容器的特点：</strong></p>
<ul>
<li>单向链表结构：std::forward_list 由一系列节点组成，每个节点包含一个元素和一个指向下一个节点的指针。</li>
<li>内存分配：与 std::list 类似，std::forward_list 的元素也是动态分配内存的。但是，由于它是单向链表，所以只能从链表的前端（头部）开始进行内存分配。</li>
<li>操作限制：由于 std::forward_list 的单向特性，它只提供了 push_front() 和 pop_front() 操作来在链表的前端添加或删除元素。不支持快速的随机访问，也不支持在链表的中间或末尾进行插入和删除操作。</li>
</ul>
<p><strong>内存使用效率：</strong></p>
<ul>
<li>无尾插法：std::forward_list 没有 push_back() 方法，只能使用 push_front() 在链表的头部插入元素。这意味着，如果你需要在链表的末尾添加元素，你将不得不遍历整个链表以到达末尾，这在大型数据集中可能效率较低。</li>
<li>节省空间：与 std::list 相比，std::forward_list 每个节点只需要存储一个指向下一个节点的指针，因此它的内存开销比 std::list 小。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>空间敏感的应用：如果你的应用对内存使用非常敏感，且需要从链表的前端进行频繁的插入和删除操作，std::forward_list 是一个不错的选择。</li>
<li>单向遍历：如果你的应用只需要从链表的前端开始遍历元素，那么 std::forward_list 可以提供良好的性能。</li>
</ul>
<p><strong>测试代码</strong></p>
<div class="tab-panel" data-tab-group="5c9f2c67be93c89850f5649945bbaa84">
  <div class="tab-nav">
    <div class="tab-nav-title">示例3</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('5c9f2c67be93c89850f5649945bbaa84','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('5c9f2c67be93c89850f5649945bbaa84','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;forward_list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t04
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_forward_list</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">forward_list()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            forward_list<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_front(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_frond()将数据存入容器头部，forward_list没有push_back()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//cout &lt;&lt; &#34;forward_list.back(): &#34; &lt;&lt; c.back() &lt;&lt; endl;	没有该函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//cout &lt;&lt; &#34;forward_list.size(): &#34; &lt;&lt; c.size() &lt;&lt; endl;	没有该函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//测试排序花费的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                c.sort();<span style="color:#75715e">//使用forward_list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.sort(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">forward_list</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">965</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">384307168202282325</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    found,<span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">sort</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1595</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<p>值得注意的是：
std::forward_list 专为高效的前端插入和删除操作设计，std::forward_list 没有 push_back() 是因为它是单向链表，
只能高效地从前面操作。它没有 size() 函数，因为计算链表长度需要遍历整个链表，这与它优化前端操作的设计目标不符。</p>
<p><strong>总结：</strong></p>
<p>std::forward_list 是一个轻量级的容器，它在内存使用上比 std::list 更为高效，但在功能上也更为有限。它适合于那些只需要单向遍历和操作的场景。由于其单向链表的特性，std::forward_list 在进行元素插入和删除时，只能从链表的前端进行，这限制了它的使用场景。在选择 std::forward_list 时，需要根据应用的具体需求来权衡其优势和局限性。</p>
<h3 id="链表容器-slist">链表容器-slist</h3>
<p>slist容器与forward_list容器一样，只是slis容器存在于ext\slist头文件中。</p>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="6873066fe35183152cd4a4ebef73d716">
  <div class="tab-nav">
    <div class="tab-nav-title">示例3</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('6873066fe35183152cd4a4ebef73d716','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('6873066fe35183152cd4a4ebef73d716','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;forward_list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t04
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_forward_list</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">forward_list()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            forward_list<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_front(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_frond()将数据存入容器头部，forward_list没有push_back()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//cout &lt;&lt; &#34;forward_list.back(): &#34; &lt;&lt; c.back() &lt;&lt; endl;	没有该函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//cout &lt;&lt; &#34;forward_list.size(): &#34; &lt;&lt; c.size() &lt;&lt; endl;	没有该函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//测试排序花费的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                c.sort();<span style="color:#75715e">//使用forward_list自带的排序函数，当然也可以用全局的sort，一般如果容器自带，则选择自带的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;forward_list.sort(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">forward_list</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">965</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">384307168202282325</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    found,<span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    forward_list.<span style="color:#a6e22e">sort</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1595</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="双向容器-deque">双向容器-deque</h2>
<p><a href="#R-image-68f837ac0230f59f9eb910da565d9023" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-68f837ac0230f59f9eb910da565d9023"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-5.png"></a></p>
<p>std::deque（双端队列）是一种容器，它允许在序列的前端和后端快速插入和删除元素。尽管从概念图上看，
std::deque 似乎是一个连续的存储空间，但实际上它并不是连续的。std::deque 的实现通常是由一个或多个固定大小的连续内存块
（通常称为“节点”或“块”）组成的，这些块通过指针连接在一起。</p>
<p>以下是对您提供内容的整理：</p>
<ul>
<li>存储机制：std::deque 由多个指针组成，每个指针指向一个具有一定容量的连续内存块。这些内存块被组织在一起，形成一个能够从两端快速增长的容器。</li>
<li>内存管理：当 std::deque 中的一个内存块满了，需要更多的空间时，它会“自动跳转”到下一个空闲的内存块的开始位置。如果所有现有的内存块都已满，std::deque 会分配一个新的内存块，并更新指针以指向这个新的块。</li>
<li>内存效率：使用固定容量的内存块可以减少内存浪费。例如，如果每个内存块的大小为8个元素，那么即使只存储一个元素，也只会浪费7个元素的空间（因为第一个块始终被使用）。这与 std::vector 相比，后者可能会因为频繁的内存重新分配而导致更多的内存浪费。</li>
<li>动态增长：当 std::deque 需要更多内存时，它会动态地增加新的内存块。这种设计使得 std::deque 能够在不牺牲太多内存的情况下，提供快速的插入和删除操作。</li>
<li>连续性：尽管 std::deque 在内部不是完全连续的，但它提供了随机访问的能力，这意味着你可以像访问 std::vector 或数组一样，通过索引来访问 std::deque 中的任何元素。</li>
</ul>
<p>总的来说，std::deque 是一个灵活且高效的容器，适用于需要在序列的两端进行频繁插入和删除操作的场景。它的设计既考虑了性能，
也考虑了内存使用效率。</p>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="c1707f7c3d2c4e7b1e18fa51f08ccdf6">
  <div class="tab-nav">
    <div class="tab-nav-title">示例3</div>
    <button
      data-tab-item="代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('c1707f7c3d2c4e7b1e18fa51f08ccdf6','代码')"
    >
      <span class="tab-nav-text">代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('c1707f7c3d2c4e7b1e18fa51f08ccdf6','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;deque&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t05
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_deque</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_deque()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            deque<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push_back(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push_back()将数据存入容器尾部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();<span style="color:#75715e">//获取输入的数字，并转为string类型返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//使用算法find查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//返回类型是：使用全局::find()寻找目标，这是循环寻找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断有没有找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//测试排序花费的时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                sort(c.begin(), c.end());<span style="color:#75715e">//使用全局的sort,deque没有自己的sort。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;deque.sort(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_deque</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1055</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">461168601842738790</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">41</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">back</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    found,<span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    deque.<span style="color:#a6e22e">sort</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">3838</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="特殊容器-stack和queue">特殊容器-stack和queue</h2>
<h3 id="stdstack栈">std::stack（栈）</h3>
<p><strong>定义：</strong></p>
<p>std::stack 是一个遵循后进先出（LIFO，Last In First Out）原则的容器适配器。它只能在序列的一端（栈顶）进行添加（push）和移除（pop）操作。</p>
<p><strong>主要操作：</strong></p>
<ul>
<li>push()：在栈顶添加一个元素。</li>
<li>pop()：移除栈顶元素。</li>
<li>top()：返回栈顶元素的引用，不移除它。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>只能单端操作，即只能在栈顶进行操作。</li>
<li>没有提供直接的迭代器支持，但提供了 top() 方法来访问栈顶元素。</li>
</ul>
<h3 id="stdqueue队列">std::queue（队列）</h3>
<p><strong>定义：</strong></p>
<p>std::queue 是一个遵循先进先出（FIFO，First In First Out）原则的容器适配器。它只能在序列的一端（队尾）进行添加（push）操作，在另一端（队首）进行移除（pop）操作。</p>
<p><strong>主要操作：</strong></p>
<ul>
<li>push()：在队尾添加一个元素。</li>
<li>pop()：移除队首元素。</li>
<li>front()：返回队首元素的引用，不移除它。</li>
<li>back()：返回队尾元素的引用，不移除它。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>双端操作，即在队首进行移除操作，在队尾进行添加操作。</li>
<li>提供了迭代器支持，允许遍历队列中的所有元素。</li>
</ul>
<p><strong>与 std::deque 的不同.</strong></p>
<ul>
<li>操作限制：std::stack 和 std::queue 限制了操作的位置，而 std::deque 允许在两端自由操作。</li>
<li>迭代器支持：std::stack 不支持迭代器，std::queue 支持迭代器但只能访问队列中的元素，而 std::deque 提供了随机访问迭代器，可以高效地访问序列中的任何位置。</li>
<li>使用场景：如果你需要一个简单的后进先出或先进先出的数据结构，std::stack 或 std::queue 可能更适合。如果你需要一个能够在两端快速操作且支持随机访问的容器，std::deque 是更好的选择。</li>
</ul>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="d30a4f1c2c43be93c7303459817cd3b8">
  <div class="tab-nav">
    <div class="tab-nav-title">示例4</div>
    <button
      data-tab-item="stack代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('d30a4f1c2c43be93c7303459817cd3b8','stack代码')"
    >
      <span class="tab-nav-text">stack代码</span>
    </button>
    <button
      data-tab-item="queue代码"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('d30a4f1c2c43be93c7303459817cd3b8','queue代码')"
    >
      <span class="tab-nav-text">queue代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('d30a4f1c2c43be93c7303459817cd3b8','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="stack代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t06
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_stack</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_stack()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            stack <span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;<span style="color:#75715e">//stack又叫栈，特点是先进后出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push()将数据压入容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack.top(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.top() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            c.pop();
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack.top(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.top() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//与前面的容器不同，stack不可以进行查找操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="queue代码"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t07
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_queue</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_queue()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            queue <span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;<span style="color:#75715e">//queue又叫队列，特点是先进先出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.push(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用push()将数据压入容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            c.pop();
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.front(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.front() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;queue.back(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.back() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//与前面的容器不同，queue也不提供查找操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_stack</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1050</span>
</span></span><span style="display:flex;"><span>    stack.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    stack.<span style="color:#a6e22e">top</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">12679</span>
</span></span><span style="display:flex;"><span>    stack.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">999999</span>
</span></span><span style="display:flex;"><span>    stack.<span style="color:#a6e22e">top</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">17172</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_queue</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1027</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">21384</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">back</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1461</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">999999</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">front</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">10793</span>
</span></span><span style="display:flex;"><span>    queue.<span style="color:#a6e22e">back</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1461</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="红黑树-multiset容器">红黑树-multiset容器</h2>
<p>multiset容器结构类似二叉树，准确说是红黑树，这种结构的的查找会快很多，但是插入则会耗费一定时间，这些时间都花费在了排序上。</p>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="02ddc745e97befebfabb82db2a13193b">
  <div class="tab-nav">
    <div class="tab-nav-title">示例8</div>
    <button
      data-tab-item="multiset代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('02ddc745e97befebfabb82db2a13193b','multiset代码')"
    >
      <span class="tab-nav-text">multiset代码</span>
    </button>
    <button
      data-tab-item="multimap代码"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('02ddc745e97befebfabb82db2a13193b','multimap代码')"
    >
      <span class="tab-nav-text">multimap代码</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('02ddc745e97befebfabb82db2a13193b','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="multiset代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t08
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_multiset</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_multiset()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            multiset <span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;<span style="color:#75715e">//multiset结构式红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.insert(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用insert()将数据存入容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;multiset.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;multiset.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//使用全局::fingd()查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);<span style="color:#75715e">//使用multiset自身的fingd()查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c.find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="multimap代码"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t09
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_multimap</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_multimap()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            multimap <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>,string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.insert(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>,string<span style="color:#f92672">&gt;</span>(i,buf));<span style="color:#75715e">//此处使用了pair设置键值对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">//值得注意，multimap不可以用[]做insert，这一点可以结合map容器理解,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">//另外key是不会重复的，因为接收的是0-1000000，而值可能会重复，因为值是通过随机数函数rand()产生，范围为0-32767
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;multimap.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;multimap.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> get_a_target_long();
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c.find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, (&#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>pItem).first <span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">&lt;&lt;</span>pItem<span style="color:#f92672">-&gt;</span>second<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_multiset</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">3235</span>
</span></span><span style="display:flex;"><span>    multiset.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    multiset.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">256204778801521550</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">23456</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">59</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">23456</span>
</span></span><span style="display:flex;"><span>    c.<span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">23456</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_multimap</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1843</span>
</span></span><span style="display:flex;"><span>    multimap.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    multimap.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">230584300921369395</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">23456</span>
</span></span><span style="display:flex;"><span>    c.<span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    found, (<span style="color:#ae81ff">23456</span>, <span style="color:#ae81ff">31622</span>)</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<p>从测试结果看，因为不会抛弃重复的值，multiset的元素个数与大小相等，且存值会话费很多时间。
相比之下multimap存值时间会话费少一些。</p>
<h2 id="unordered_multiset和unordered_multimap">unordered_multiset和unordered_multimap</h2>
<p>std::unordered_map 和 std::unordered_set 是 C++ 标准库中的两种容器，它们基于哈希表实现。这两种容器提供平均时间复杂度为 O(1) 的快速访问，插入和删除操作。下面简单解释它们的概念图，包括桶和负载因子的说明。</p>
<p><strong>概念图简述：</strong></p>
<p><strong>桶（Buckets）：</strong></p>
<p>在 std::unordered_map 和 std::unordered_set 中，哈希表被分为多个“桶”。
每个桶存储指向一个链表的指针（在 std::unordered_map 的情况下）或直接存储元素（在 std::unordered_set 的情况下）。
当元素被插入时，它们的哈希值决定了它们将被存储在哪个桶中。</p>
<p><strong>链表（Chaining）：</strong></p>
<p>如果多个元素具有相同的哈希值（哈希冲突），它们将被存储在同一个桶中，并通过链表连接起来。
在 std::unordered_map 中，每个桶可能包含一个链表，链表中的每个节点存储一个键值对。
在 std::unordered_set 中，每个桶可能包含一个链表，链表中的每个节点存储一个元素。</p>
<p><strong>负载因子（Load Factor）：</strong></p>
<p>负载因子是哈希表中已存储元素数量与桶数量的比率。
负载因子影响哈希表的性能。较高的负载因子可能导致更多的哈希冲突，从而增加链表的长度，降低性能。
当负载因子超过一个预设的最大值时，哈希表可能会进行重新哈希（rehashing），即增加桶的数量并重新分配所有元素到新的桶中。</p>
<p><strong>概念图说明：</strong></p>
<p><a href="#R-image-c73e6e46999209e02119300dc21109e7" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c73e6e46999209e02119300dc21109e7"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-6.png"></a></p>
<ul>
<li>桶：哈希表被分为多个桶，每个桶可以存储一个链表的头部指针。</li>
<li>指针：在 std::unordered_map 中，每个指针指向一个链表节点，该节点包含一个键值对。在 std::unordered_set 中，每个指针直接指向存储的元素。</li>
<li>元素：链表中的元素，可能是键值对或单个值。</li>
</ul>
<p><strong>负载因子说明：</strong></p>
<p>重新哈希（Rehashing）：当负载因子超过 max_load_factor() 时，哈希表会进行重新哈希，增加桶的数量，并将所有元素重新分配到新的桶中。
动态调整：这种动态调整机制使得 std::unordered_map 和 std::unordered_set 能够根据元素数量的变化自动调整大小，以保持操作的性能。
通过这种结构，std::unordered_map 和 std::unordered_set 能够在大多数情况下提供快速的访问和修改操作，但需要注意，极端情况下（如所有元素哈希到同一个桶中）性能可能会退化到 O(n)。</p>
<p><strong>测试代码：</strong></p>
<div class="tab-panel" data-tab-group="9aa71efc630be8c55110bb5d6f569826">
  <div class="tab-nav">
    <div class="tab-nav-title">示例9</div>
    <button
      data-tab-item="unordere_multiset代码"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('9aa71efc630be8c55110bb5d6f569826','unordere_multiset代码')"
    >
      <span class="tab-nav-text">unordere_multiset代码</span>
    </button>
    <button
      data-tab-item="unordere_multiset结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('9aa71efc630be8c55110bb5d6f569826','unordere_multiset结果')"
    >
      <span class="tab-nav-text">unordere_multiset结果</span>
    </button>
    <button
      data-tab-item="unordere_multimap代码"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('9aa71efc630be8c55110bb5d6f569826','unordere_multimap代码')"
    >
      <span class="tab-nav-text">unordere_multimap代码</span>
    </button>
    <button
      data-tab-item="unordere_multimap结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('9aa71efc630be8c55110bb5d6f569826','unordere_multimap结果')"
    >
      <span class="tab-nav-text">unordere_multimap结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="unordere_multiset代码"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t10
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_unordered_multiset</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_unordered_multiset()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            unordered_multiset <span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.insert(string(buf));<span style="color:#75715e">//将随机数转为string类型，并使用insert()将数据存入容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multiset.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">// 打印 unordered_multiset 能存储的最大元素数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multiset.bucket_count(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.bucket_count() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">// 打印 unordered_multiset 中桶的数量，即存储指向一定长度链表的指针的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multiset.max_load_factor(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_load_factor() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">// 打印 unordered_multiset 可以使用的最大负载因子，它影响桶中链表的最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multiset.max_bucket_count(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_bucket_count() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">// 打印 unordered_multiset 可以使用的最大桶的数量，这个值通常由桶的增长策略和哈希表的容量决定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;bucket # &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; has &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.bucket_size(i) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; element.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            string target <span style="color:#f92672">=</span> get_a_target_string();
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);<span style="color:#75715e">//使用全局::fingd()查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);<span style="color:#75715e">//使用multiset自身的fingd()查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c.find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="unordere_multiset结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_unordered_multiset</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1867</span>
</span></span><span style="display:flex;"><span>    unordered_multiset.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">329406144173384850</span>
</span></span><span style="display:flex;"><span>    unordered_multiset.<span style="color:#a6e22e">bucket_count</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1048576</span>
</span></span><span style="display:flex;"><span>    unordered_multiset.<span style="color:#a6e22e">max_load_factor</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    unordered_multiset.<span style="color:#a6e22e">max_bucket_count</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1152921504606846975</span>
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">0</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">1</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">2</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">3</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">4</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">5</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">6</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">7</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">8</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">9</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">10</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">11</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">12</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">13</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">14</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">15</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">16</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">17</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">18</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    bucket <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">19</span> has <span style="color:#ae81ff">0</span> element.
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">108</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    c.<span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">12345</span></span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="unordere_multimap代码"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> t11
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_unordered_multimap</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_unordered_multimap()..............</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            multimap <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>, string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c.insert(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>, string<span style="color:#f92672">&gt;</span>(i, buf));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();<span style="color:#75715e">//发生异常使用该函数退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multimap.size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;unordered_multimap.max_size(): &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> get_a_target_long();
</span></span><span style="display:flex;"><span>            timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c.find(),milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, (&#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>pItem).first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> pItem<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not found!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="unordere_multimap结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_unordered_multimap</span>()..............
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1942</span>
</span></span><span style="display:flex;"><span>    unordered_multimap.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    unordered_multimap.<span style="color:#a6e22e">max_size</span>()<span style="color:#f92672">:</span> <span style="color:#ae81ff">230584300921369395</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    c.<span style="color:#a6e22e">find</span>(),milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found, (<span style="color:#ae81ff">12345</span>, <span style="color:#ae81ff">5839</span>)</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="set和map容器">set和map容器</h2>
<p>测试代码：</p>
<div class="tab-panel" data-tab-group="4bba683a8cf01f45bd682f586919fa65">
  <div class="tab-nav">
    <div class="tab-nav-title">示例10</div>
    <button
      data-tab-item="set"
      class="tab-nav-button tab-panel-style cstyle initial active" tabindex="-1"
      onclick="switchTab('4bba683a8cf01f45bd682f586919fa65','set')"
    >
      <span class="tab-nav-text">set</span>
    </button>
    <button
      data-tab-item="map"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('4bba683a8cf01f45bd682f586919fa65','map')"
    >
      <span class="tab-nav-text">map</span>
    </button>
    <button
      data-tab-item="结果"
      class="tab-nav-button tab-panel-style cstyle initial"
      onclick="switchTab('4bba683a8cf01f45bd682f586919fa65','结果')"
    >
      <span class="tab-nav-text">结果</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="set"
      class="tab-content tab-panel-style cstyle initial active">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> t12
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_set</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value){
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test-set()............................</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            set<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                        c.insert(string(buf));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                        abort();
</span></span><span style="display:flex;"><span>                    } 
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;set.max_size() &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;set.size() &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                string target <span style="color:#f92672">=</span> get_a_target_string();
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> <span style="color:#f92672">::</span>find(c.begin(), c.end(), target);
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(), milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;find(), milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pItem <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not fount!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="map"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>   <span style="color:#66d9ef">namespace</span> t13
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_map</span>(<span style="color:#66d9ef">long</span><span style="color:#f92672">&amp;</span> value) {
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">test_map()............................</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">long</span>,string<span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>            clock_t timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> value; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    snprintf(buf, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;%d&#34;</span>, rand());
</span></span><span style="display:flex;"><span>                    c[i] <span style="color:#f92672">=</span> string(buf);<span style="color:#75715e">//注意这种使用方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">catch</span> (exception<span style="color:#f92672">&amp;</span> p)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;i = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> p.what() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                    abort();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;map.max_size() &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.max_size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;map.size() &#34;</span> <span style="color:#f92672">&lt;&lt;</span> c.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> target <span style="color:#f92672">=</span> get_a_target_long();
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                timeStart <span style="color:#f92672">=</span> clock();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> pItem <span style="color:#f92672">=</span> c.find(target);
</span></span><span style="display:flex;"><span>                cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;::find(), milli-seconds: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (clock() <span style="color:#f92672">-</span> timeStart) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (pItem <span style="color:#f92672">!=</span> c.end()) {
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;found value, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> pItem<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not fount value!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="结果"
      class="tab-content tab-panel-style cstyle initial">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    How much memory space you need: <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    test<span style="color:#f92672">-</span><span style="color:#a6e22e">set</span>()............................
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">2133</span>
</span></span><span style="display:flex;"><span>    set.<span style="color:#a6e22e">max_size</span>() <span style="color:#ae81ff">256204778801521550</span>
</span></span><span style="display:flex;"><span>    set.<span style="color:#a6e22e">size</span>() <span style="color:#ae81ff">32768</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(), milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">find</span>(), milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found, <span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test_map</span>()............................
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">1937</span>
</span></span><span style="display:flex;"><span>    map.<span style="color:#a6e22e">max_size</span>() <span style="color:#ae81ff">230584300921369395</span>
</span></span><span style="display:flex;"><span>    map.<span style="color:#a6e22e">size</span>() <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">--</span><span style="color:#ae81ff">32767</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">12345</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span><span style="color:#a6e22e">find</span>(), milli<span style="color:#f92672">-</span>seconds: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    found value, <span style="color:#ae81ff">5839</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="分配器测试程序">分配器测试程序</h2>
<p><a href="#R-image-d4050b5e1d9a3c6df96bfb917293042a" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d4050b5e1d9a3c6df96bfb917293042a"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/5.stl%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image.png"></a></p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月21日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
  </ul>
</div>
  </header>

<h1 id="4c20特性的使用">4.C&#43;&#43;2.0特性的使用</h1>

<h2 id="vs-2022的设置">VS 2022的设置</h2>
<p>首先你可以先用下面的代码测试使用可以执行：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printTypes</span>() {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span>... U<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> printTypes(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> t, <span style="color:#66d9ef">const</span> U<span style="color:#f92672">&amp;</span>... u) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> t <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        printTypes(u...);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>        printTypes(<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#ae81ff">1.5</span>, <span style="color:#e6db74">&#39;b&#39;</span>);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>如果报错了，如typename&hellip;未定义，那么请你按照如下步骤操作，
<a href="#R-image-163292f3ffba00899ab884e5c0866733" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-163292f3ffba00899ab884e5c0866733"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image.png"></a></p>
<ul>
<li>C++语言标准选择<code>预览 - 最新 C++ 工作草案中的功能 (/std:c++latest)</code></li>
<li>启用实验性C++标准库模块&ndash;<code>是</code></li>
<li>生成ISO C++23标准库模块 &ndash; <code>是</code></li>
</ul>
<h2 id="const补充">const补充</h2>
<table>
  <thead>
      <tr>
          <th></th>
          <th>const 参数</th>
          <th>non-const 参数</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>const 函数</td>
          <td>可执行</td>
          <td>可执行</td>
      </tr>
      <tr>
          <td>non-const 函数</td>
          <td>报错</td>
          <td>可执行</td>
      </tr>
  </tbody>
</table>
<p>使用const需要注意两个问题，参数是否需要修改，参数进入函数内后数据是都会修改。解决这两个问题，在需要的地方加上const</p>
<p>还有一种情况，</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        T fooTo(T str) <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> str; };
</span></span><span style="display:flex;"><span>        T <span style="color:#a6e22e">fooTo</span>(T str)  {<span style="color:#66d9ef">return</span> str;};
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>        foo <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">&gt;</span> f;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> y <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;c&#39;</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span>  f.fooTo(x) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span>  f.fooTo(y) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>运行结果如下:
<a href="#R-image-40ddeacb7ec8705b0ab83f67776c50cf" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-40ddeacb7ec8705b0ab83f67776c50cf"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/4.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%802.0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/image-1.png"></a>
在这个例子中，带const的参数只会执行带const的函数，而不带const的参数会只会执行不带const的函数，这就是带const和不带const函数出现时的情况。
但是这个结果我并不是很满意，应为我试着在不带const函数内部修改传入的参数，代码执行时将不会以我上面说的结论出现。或许还需要在研究研究……</p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月17日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
  </ul>
</div>
  </header>

<h1 id="3导读">3.导读</h1>

<h2 id="书籍推荐">书籍推荐</h2>
<ul>
<li>《C++ Premier》</li>
<li>《C++ Programming Language》</li>
<li>《Effective Modern C++》</li>
<li>《Efficient C++》</li>
<li>《The C++ standard library》</li>
<li>《STL C++》</li>
<li>《STL源码剖析》</li>
<li>《算法+数据结构=程序》</li>
<li><a href="CPLusPlus.com">&ldquo;网站CPLusPlus&rdquo;</a></li>
<li><a href="CppReference.com">&ldquo;网站CppReference&rdquo;</a></li>
<li><a href="gcc.gnu.org">&ldquo;网站gcc.gnu&rdquo;</a></li>
</ul>
<h2 id="学习路线">学习路线</h2>
<p><a href="#R-image-21989a9c8ed8fb27651f922466327641" class="lightbox-link"><img alt="路线" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-21989a9c8ed8fb27651f922466327641"><img alt="路线" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-4.png"></a></p>
<ul>
<li><a href="https://www.icourse163.org/learn/PKU-1002029030?tid=1473325453#/learn/content" rel="external" target="_blank">慕课C++学习</a></li>
<li><a href="cxsjsxmooc.openjudge.cn">练习网站</a></li>
</ul>
<h2 id="conversion-function-转换函数">conversion function-转换函数</h2>
<p>接下来以一个分数的代码例子说明转换函数。</p>
<p>情况1：让值转为其他类型</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m_num, m_den;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Fraction(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> m_num(num),m_den(den){}
</span></span><span style="display:flex;"><span>        opertaor <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)(m_num<span style="color:#f92672">/</span>m_den);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//使用示例：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Fraction <span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> d <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">+</span>f;</span></span></code></pre></div>
<p>在上述的示例中，<code>d = 4+f;</code>程序会先判断有没有写<code>opertaor +</code>，如果没有会试着将f通过<code>opertaor double()</code>转为double类型。</p>
<p>情况2：<strong>non-explicit-one-argument-ctor</strong>，不带explicit的一个参数的构造函数，将其他类型转为预所写类的类型</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m_num, m_den;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Fraction(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> m_num(num),m_den(den){}
</span></span><span style="display:flex;"><span>        opertaor <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)(m_num<span style="color:#f92672">/</span>m_den);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//使用示例：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Fraction <span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    Fraction f2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">+</span>f1;</span></span></code></pre></div>
<p>同样在这个地方会先将4转为Fraction，然后在进行相加，转换函数使用的是构造函数，构造函数默认第二个参数是1，也就一个参数时也可用，但这个意思并不是说f1(2)你不写第二个参数。</p>
<p>虽然向上面的情况可行，但是当你把两个情况结合在一起时，就会报错，例如你如下写：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m_num, m_den;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        Fraction(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> m_num(num),m_den(den){}
</span></span><span style="display:flex;"><span>        opertaor <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)(m_num<span style="color:#f92672">/</span>m_den);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Fraction <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> Fraction<span style="color:#f92672">&amp;</span> f){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Fraction</span>(<span style="color:#960050;background-color:#1e0010">……</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };</span></span></code></pre></div>
<p>情况3：<strong>explicit-one-argument-ctor</strong>，带explicit的一个参数的构造函数
这个时候再使用刚才的例子，程序就会报错，因为此时是两种情况的结合，意味着两种情况都可以实现，编译器此时就不知道该使用哪个方法，为了解决这个问题，你可以使用关键字explicit来约束构造函数，让其他类型如法转为所写类，这个时候编译器会报错说无法将double类型转为Fraction。如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m_num, m_den;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">explicit</span> Fraction(<span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> m_num(num),m_den(den){}
</span></span><span style="display:flex;"><span>        opertaor <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)(m_num<span style="color:#f92672">/</span>m_den);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Fraction <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> Fraction<span style="color:#f92672">&amp;</span> f){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Fraction</span>(<span style="color:#960050;background-color:#1e0010">……</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Fraction <span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    Fraction f2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">+</span>f1;</span></span></code></pre></div>
<h2 id="编写的类大两个大方向">编写的类大两个大方向</h2>
<h3 id="智能指针">智能指针</h3>
<p><a href="#R-image-e53ec90193b98fcfb97b9f71e5909461" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e53ec90193b98fcfb97b9f71e5909461"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image.png"></a>
<a href="#R-image-0eb1b573aa822242e57330b28a35b558" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0eb1b573aa822242e57330b28a35b558"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-1.png"></a></p>
<h3 id="伪函数">伪函数</h3>
<p>这样的类会像函数一样接收参数，返回某一类型的值通常会看到类中重载<code>operate() (……){……}</code>函数。</p>
<h2 id="特化">特化</h2>
<p><a href="#R-image-e68df2cf03d1f8c91660cf485f298e75" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e68df2cf03d1f8c91660cf485f298e75"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-2.png"></a></p>
<h2 id="偏特化对应泛化">偏特化&ndash;对应泛化</h2>
<ul>
<li>个数上的偏</li>
</ul>
<p>以我的理解就是假设原先设计的模版为</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> a, <span style="color:#66d9ef">typename</span> b<span style="color:#960050;background-color:#1e0010">……</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#960050;background-color:#1e0010">……</span>}</span></span></code></pre></div>
<p>现在我使用偏特化，写为</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> b<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>, <span style="color:#66d9ef">typename</span> b<span style="color:#960050;background-color:#1e0010">……</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#960050;background-color:#1e0010">……</span>}</span></span></code></pre></div>
<p>也就是第一个参数已经确定是bool类型了。（大概先这么理解吧:smile: :smile: :smile:）</p>
<ul>
<li>范围上的偏特化</li>
</ul>
<p>一般我们的类模版你可以任意指定类型，但是现在我想写一个用指针指向的类模板，那么他就被限制在一定的范围内了</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> a<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#960050;background-color:#1e0010">……</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//范围偏特化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> a<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span><span style="color:#f92672">*</span> a<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#960050;background-color:#1e0010">……</span>}</span></span></code></pre></div>
<h2 id="模板模板类">模板模板类</h2>
<p>假设我要创建一个容器，并指定这个容器内容的类型，这个时候可以使用模版模版类，详细看下图：
<a href="#R-image-2fe138b6f80414ce36e1c8a3bb399329" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2fe138b6f80414ce36e1c8a3bb399329"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/3.%E5%AF%BC%E8%AF%BB/image-3.png"></a></p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
      <li><a href="/Class/17.C%e5%8a%a0%e5%8a%a0%e7%bc%96%e7%a8%8b/3.%e5%af%bc%e8%af%bb/_index.files/Fraction.hpp">Fraction.hpp</a> (355 B)</li>
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月16日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
  </ul>
</div>
  </header>

<h1 id="2组合与继承">2.组合与继承</h1>

<h2 id="类与类的三种关系">类与类的三种关系</h2>
<h3 id="composition-复合">Composition-复合</h3>
<p>以我个人的理解，复合就是一个类中包含有另外一个类，使用到另一个类的内容。复合的类他们的构造和析构函数运行次序是，构造函数有内到外依次运行，析构函数则相反。可以使用下图表示这种关系</p>
<p><a href="#R-image-d94cf765f0449a7c8603a430849ed9d8" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d94cf765f0449a7c8603a430849ed9d8"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image.png"></a></p>
<h3 id="delegation-委托">delegation-委托</h3>
<p>当一个类欲用一个指针指向另一个类，以达到想使用时就指向这个类的这种关系就叫delegation，假设我要实现一个计算，此时指针指向这个函数，让函数去做这个计算。这有些类似于复合，但是这里重点在于指针的使用。在写一些功能的时候也建议使用这种关系的特性，因为这样就将两者隔开，起到一定的保护作用。参考下图：
<a href="#R-image-6bf73cfba33212ba720b596883a73351" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6bf73cfba33212ba720b596883a73351"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-1.png"></a></p>
<h3 id="inheritance-继承">Inheritance-继承</h3>
<p>在C++有三种继承方式，其中public是常用的一种，继承表示从一个类中集成某些属性成为 <strong>另外一种</strong> 类。</p>
<p><a href="#R-image-62b30b284c4ea06f7b3e95822507b308" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-62b30b284c4ea06f7b3e95822507b308"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-2.png"></a></p>
<p>Inheritance关系的两个类它们的构造函数与析构函数执行次序与之前描述复合时一样。如下图是这种关系的表示方法：
<a href="#R-image-658888ec35778de65a45bd0c1162d0a7" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-658888ec35778de65a45bd0c1162d0a7"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/2.%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/image-3.png"></a></p>
<ul>
<li>构造函数（constructor）：由内到外，代码表示为<code>SunFunction::SunFunction(…):base(){…};</code></li>
<li>析构函数（destructor）：由外到内，代码表示为<code>SunFunction::SunFunction(…){……~base();};</code></li>
</ul>
<p>值得注意的是，如果一个类将来可能是父类，那么需要在析构函数前加<strong>virtual</strong>关键字，否则会报错<code>undefine behavior</code>。</p>
<h2 id="设计模式">设计模式</h2>
<p>**参考书籍：**<em>Design PatternsExplained Simply</em></p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月16日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
  </ul>
</div>
  </header>

<h1 id="1代码编写规范">1.代码编写规范</h1>

<h2 id="如何写一个标准的h文件">如何写一个标准的.h文件</h2>
<p>以下内容来自<a href="https://www.bilibili.com/video/BV1ELHEewEms/?p=6&spm_id_from=pageDriver&vd_source=5e8e4e9e284af3291f1a3addff3fc2c3" rel="external" target="_blank">B站</a>。</p>
<p>接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">complex</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* data */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> re,im;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> complex<span style="color:#f92672">&amp;</span> __doapl (complex<span style="color:#f92672">*</span>,<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    complex (<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span>re(r),im(i)                <span style="color:#75715e">//这是一个构造函数，这种写法意思是初始化变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {};
</span></span><span style="display:flex;"><span>    complex<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+=</span> (complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> re;}  <span style="color:#75715e">//这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> im;}
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="构造函数的特性">构造函数的特性</h2>
<p>这一点需要关注下面的代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>complex (<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span>re(r),im(i)                <span style="color:#75715e">//这是一个构造函数，这种写法意思是初始化变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {};</span></span></code></pre></div>
<h2 id="关于const修饰符">关于const修饰符</h2>
<p>如上面说到的，函数返回最好是加const，这样可以应付下面情况的发生。</p>
<div class="tab-panel" data-tab-group="29f176cf946cb2fc69acfc698662bef5">
  <div class="tab-nav">
    <div class="tab-nav-title">const的使用</div>
    <button
      data-tab-item="加constfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('29f176cf946cb2fc69acfc698662bef5','加constfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 加const</span>
    </button>
    <button
      data-tab-item="不加constfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;"
      onclick="switchTab('29f176cf946cb2fc69acfc698662bef5','不加constfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 不加const</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="加constfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> re;}  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> im;}</span></span></code></pre></div>
<p>此时做如下两种使用都是正确的</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="不加constfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> ()  {<span style="color:#66d9ef">return</span> re;}  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> ()  {<span style="color:#66d9ef">return</span> im;}</span></span></code></pre></div>
<p>此时做如下两种使用只有第一种可以被执行，第二种会报错。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="函数传递和返回值的两种方式">函数传递和返回值的两种方式</h2>
<p>pass by values:传值。在传输的事单字节或者字节数较少的情况下使用，比如传一个字符。</p>
<p>pass by reference:传引用。在C++中引用的底层逻辑就是传指针，也就是类似穿了地址，也就是只传输4个字节，
在这种情况下你可以使用const修饰符，迫使函数不能修改值，如果希望函数对值进行处理则可以不加</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">re</span>(<span style="color:#66d9ef">const</span> classname<span style="color:#f92672">&amp;</span> cl){};<span style="color:#75715e">//加了const
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">re</span>(classname cl){};<span style="color:#75715e">//没有加const
</span></span></span></code></pre></div>
<p>对于返回值，我们可以返回值，也可以返回引用，但什么情况下返回的是引用呢？</p>
<p>在设计类中的函数时，可以先考虑返回类型适不适合<code>引用</code>,如果返回的是已经存在的地址，那么可以选择返回类型为引用，否则不使用。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex<span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span>        __ap(complex <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span> ,<span style="color:#66d9ef">const</span> complex <span style="color:#f92672">&amp;</span> c){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>re <span style="color:#f92672">+=</span> c.re;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>im <span style="color:#f92672">+=</span> c.im;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        }</span></span></code></pre></div>
<p>向上面的函数就是使用了引用返回。</p>
<h2 id="操作符重载-1成员函数">操作符重载-1：成员函数</h2>
<p><a href="#R-image-2b5d6f9c8a39370a259b796f61f44663" class="lightbox-link"><img alt="操作符重载" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2b5d6f9c8a39370a259b796f61f44663"><img alt="操作符重载" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image.png"></a></p>
<h2 id="操作符重载-2非成员函数">操作符重载-2：非成员函数</h2>
<p>假设现在要计算复数的加减，如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com2</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>    complex com3;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> com1 <span style="color:#f92672">+</span> com2;
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> com1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> com2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span></span></span></code></pre></div>
<p>对于这段代码在库文件中，要对加法做非成员函数重载，以应付 不同的情况。</p>
<p>接下来在考虑一个问题，就是如果我们只是做<code>cout&lt;&lt;com1;</code>那么对于&laquo;函数返回值可以是void类,但是如果我们做的是<code>cout&lt;&lt;com1&lt;&lt;com2&lt;&lt;endl;</code>
这样的操作返回类型为void类型，那么当运行<code>cout&lt;&lt;com1</code>后就无法运行<code>&lt;&lt;com2&lt;&lt;endl</code>的代码.</p>
<p>很显然要让代码继续运行，我们还需要返回iostream类型，而且使用<code>return by reference</code>返回方法，也就是返回引用。如下图：
<a href="#R-image-bf28d4a96b9c23d34da5d064a470c7b5" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf28d4a96b9c23d34da5d064a470c7b5"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-1.png"></a></p>
<h2 id="小结">小结</h2>
<p>通过以上的简单讲解，我们可以总结一下，再写一个类的时候，我们需要注意以下几点：</p>
<ul>
<li>确定类的数据并写在private中;</li>
<li>对于构造函数要善于使用初始化数据方法；</li>
<li>对于函数要想一想，返回类型是否可以改变，要不要写const；</li>
<li>对于函数类型和返回值，要传值还是传引用，要返回值还是返回引用。</li>
</ul>
<p>是否返回引用最最好的判断标准就是，值在经过函数运算后存储在函数外，或说是一个以存在的存储地址，否则不返回引用</p>
<h2 id="接下来通过学习stringh库进一步了解指针的使用">接下来通过学习string.h库，进一步了解指针的使用</h2>
<p>一般有指针的类需要写三个特殊函数拷贝构造、拷贝析构、拷贝赋值，</p>
<p><a href="#R-image-c2c2ba2705fc6e4e39e01a91b04a711f" class="lightbox-link"><img alt="String" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c2c2ba2705fc6e4e39e01a91b04a711f"><img alt="String" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-2.png"></a>
<a href="#R-image-b40a5b15cf406894314324851671e74b" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b40a5b15cf406894314324851671e74b"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-3.png"></a>
<a href="#R-image-32c44a6439fb15d035d7b1f368561996" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-32c44a6439fb15d035d7b1f368561996"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-4.png"></a>
<a href="#R-image-616225f994e0a09b0cd14a2cf8a72de3" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-616225f994e0a09b0cd14a2cf8a72de3"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-5.png"></a></p>
<p>有时候还需要用到new 和 delete。</p>
<h2 id="stack栈和heap堆">stack（栈）和heap（堆）</h2>
<p>如下代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        String str1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String();
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>上面的{}内的代码就是存储在stack中，而经过new的变量存在heap中；</p>
<h3 id="stack-object-的生命周期">stack object 的生命周期</h3>
<p>在{}内的代码执行结束后，<strong>自动调用析构函数</strong>将变量清理掉，如下代码，</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="static-local-object-的生命周期">static local object 的生命周期</h3>
<p>添加关键字static的变量成为静态变量，在作用于如下面代码的{}结束后不会被析构函数清理掉，
变量会存储直到程序结束。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="global-objects-生命周期">global objects 生命周期</h3>
<p>全局变量在程序接收后才会被清理掉。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="调用new和delete的过程">调用new和delete的过程</h3>
<p>在使用new的地方需要使用delete清理内存，防止内存泄露。</p>
<p>调用new过程：</p>
<p><a href="#R-image-922ea5fdeac4ed76171fd32581e4f5df" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-922ea5fdeac4ed76171fd32581e4f5df"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-6.png"></a></p>
<p>调用delete的过程：</p>
<p><a href="#R-image-fcc8bd2670e19cc6cb572a0cdde2d608" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fcc8bd2670e19cc6cb572a0cdde2d608"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-7.png"></a>
<a href="#R-image-8e2ba7fcf1eb6de5e9af6503c5c5838b" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8e2ba7fcf1eb6de5e9af6503c5c5838b"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-8.png"></a></p>
<p>代码 分配内存大小左图是调试模式下的内存分配，右图是非调试模式下分配的内存</p>
<p><a href="#R-image-ede09e6841fe40a95495dfeec83199c5" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ede09e6841fe40a95495dfeec83199c5"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-9.png"></a></p>
<p>new与delete的搭配，在删除数组时需要加上[]否则编译器不知道你要删的是数组：</p>
<p><a href="#R-image-8d7a1135dc2938cc73f9576a09638b56" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8d7a1135dc2938cc73f9576a09638b56"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-10.png"></a></p>
<h2 id="new和delete的补充">new和delete的补充</h2>
<p>对new和delete的重载，用于设计内存管理，如内存池等操作。</p>
<h3 id="重载newdelete">重载::new,::delete</h3>
<p>重载的函数中，new操作会接收一个大小，该大小由编译器传入，而delete传入的是一个指针，如下图；
<a href="#R-image-d645e59e3b05d1ddacb94c9bb6274ee7" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-16.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d645e59e3b05d1ddacb94c9bb6274ee7"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-16.png"></a></p>
<p>如果不想使用类中的new和delete，可以在二者之前加上:,如::new,::delete，这样在调用函数时就不会调用类设计中的new和delete重载，而是全局的。</p>
<h3 id="类中重载的new和delete">类中重载的new和delete</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">F</span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> operate <span style="color:#66d9ef">new</span>(size_t);<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> operate <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>,size_t);<span style="color:#75715e">//2,size_t可不写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段1的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> mem <span style="color:#f92672">=</span> operate <span style="color:#66d9ef">new</span>(size_t);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">*&gt;</span>(mem);<span style="color:#75715e">//类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>F<span style="color:#f92672">::</span>F();<span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段2的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">-&gt;~</span>F();
</span></span><span style="display:flex;"><span>operate <span style="color:#a6e22e">delete</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// main函数调用示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    F<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> F();
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> p;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="类中重载的new和delete-1">类中重载的new[]和delete[]</h3>
<p>代码整体流程与上一个情况类似，区别在于new[]是申请数组内存，在销毁的时候如果不使用delete[]释放内存，delete只会执行一次，导致内存没有完全释放，详细代码如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">F</span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> operate <span style="color:#66d9ef">new</span>(size_t);<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> operate <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>,size_t);<span style="color:#75715e">//2,size_t可不写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段1的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> mem <span style="color:#f92672">=</span> operate <span style="color:#66d9ef">new</span>(size_t<span style="color:#f92672">*</span>N <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>);<span style="color:#75715e">//指针占4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">*&gt;</span>(mem);<span style="color:#75715e">//类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>F<span style="color:#f92672">::</span>F();<span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段2的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">-&gt;~</span>F();<span style="color:#75715e">//析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>operate <span style="color:#a6e22e">delete</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// main函数调用示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    F<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> F[N];
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span>[] p;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="newdelete使用示例">new,delete使用示例</h2>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> _id;<span style="color:#75715e">//4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> _data;<span style="color:#75715e">//4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    string _str;<span style="color:#75715e">//40个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Foo() <span style="color:#f92672">:</span>_id(<span style="color:#ae81ff">0</span>)       { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;default ctor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    Foo(<span style="color:#66d9ef">int</span> i) <span style="color:#f92672">:</span>_id(i)  { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ctor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>Foo()              { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;dtor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (Foo<span style="color:#f92672">*</span>)malloc(size);
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;new size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;delete size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    free(p);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (Foo<span style="color:#f92672">*</span>)malloc(size);
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;new[] size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;delete[] size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    free(p);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>运行结果如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>new size <span style="color:#f92672">=</span> <span style="color:#ae81ff">48</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC67A460id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC67A460id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>delete size <span style="color:#f92672">=</span> <span style="color:#ae81ff">48</span>
</span></span><span style="display:flex;"><span>_____________________________________________
</span></span><span style="display:flex;"><span>new[] size <span style="color:#f92672">=</span> <span style="color:#ae81ff">104</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673438id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673468id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673468id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673438id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>delete[] size <span style="color:#f92672">=</span> <span style="color:#ae81ff">104</span></span></span></code></pre></div>
<h3 id="为什么new操作会多出8个字节呢">为什么new[]操作会多出8个字节呢？</h3>
<p>我看课程视频，老师说new[]分配的内存块会在最前面存储计数量，占用4个字节，表示数组大小，但是我在电脑上运行会多出8个字节，查阅资料可能与系统、对齐方式、编译器等有关。</p>
<p><a href="#R-image-e118329c4410fc7a86bc2915f386e56f" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-17.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e118329c4410fc7a86bc2915f386e56f"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-17.png"></a></p>
<h2 id="对new的分配额外内存">对new的分配额外内存</h2>
<p>假设分配内存的同时需要额外分配一定的内存，可以参考下面的代码：
<a href="#R-image-98e7543946a7a3d5768308216cb0dfee" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-18.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-98e7543946a7a3d5768308216cb0dfee"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-18.png"></a></p>
<h2 id="小结-1">小结</h2>
<p>对于包含有指针的类，在必要时写上拷贝构造、拷贝赋值、析构函数，如下代码</p>
<div class="tab-panel" data-tab-group="f8b116e22bfd6090891b554be8cdc976">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="class-stringfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('f8b116e22bfd6090891b554be8cdc976','class-stringfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> class String</span>
    </button>
    <button
      data-tab-item="destructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;"
      onclick="switchTab('f8b116e22bfd6090891b554be8cdc976','destructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Destructor</span>
    </button>
    <button
      data-tab-item="constructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;"
      onclick="switchTab('f8b116e22bfd6090891b554be8cdc976','constructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Constructor</span>
    </button>
    <button
      data-tab-item="copy-constructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: origin;"
      onclick="switchTab('f8b116e22bfd6090891b554be8cdc976','copy-constructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Copy Constructor</span>
    </button>
    <button
      data-tab-item="copy-assignment-operatorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;"
      onclick="switchTab('f8b116e22bfd6090891b554be8cdc976','copy-assignment-operatorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Copy Assignment Operator</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="class-stringfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> m_data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        String(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cstr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>);           <span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        String(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str);              <span style="color:#75715e">//拷贝构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        String<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str);  <span style="color:#75715e">//拷贝赋值函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">~</span>String();                              <span style="color:#75715e">//析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">get_c_str</span>() <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> m_data;}
</span></span><span style="display:flex;"><span>    };</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="destructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    String<span style="color:#f92672">::~</span>String()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="constructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> 
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">::</span>String(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cstr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cstr)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(cstr)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            strcpy(m_data, cstr);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            strcpy(m_data,<span style="color:#e6db74">&#39;\0&#39;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="copy-constructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: origin;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">::</span>String(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> cstr){
</span></span><span style="display:flex;"><span>        m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(cstr.m_data) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy(m_data, cstr);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="copy-assignment-operatorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> 
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">&amp;</span> String<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>str)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>        m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(str.m_data) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy(m_data, str);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="补充内容static">补充内容static</h2>
<p><a href="#R-image-feeffd735f99a387009b967e2430311e" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/053bb0f3f18235ed9a9ba76e717a1673.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-feeffd735f99a387009b967e2430311e"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/053bb0f3f18235ed9a9ba76e717a1673.png"></a></p>
<h3 id="static在private中的使用例子">static在private中的使用例子</h3>
<p><a href="#R-image-647e15c84ebf9fb2861065e55f7415ae" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-11.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-647e15c84ebf9fb2861065e55f7415ae"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-11.png"></a>
<a href="#R-image-ef96632345c2a648c086616f61201eb6" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-12.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ef96632345c2a648c086616f61201eb6"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-12.png"></a></p>
<h3 id="class-template">class template</h3>
<p><a href="#R-image-c5fac545096227b85e2fc275c2f65679" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-13.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c5fac545096227b85e2fc275c2f65679"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-13.png"></a></p>
<h3 id="function-template">function template</h3>
<h3 id="member-template-成员模板">member template 成员模板</h3>
<p>类模板中，还有类模板，通常是对构造函数的操作，如下图：
<a href="#R-image-c8994f8ddbb320388db9af5aca0a31b8" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-14.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c8994f8ddbb320388db9af5aca0a31b8"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-14.png"></a></p>
<p>如下图代码
<a href="#R-image-2e0ff0f902b55e94723d133d0679a3c1" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-15.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e0ff0f902b55e94723d133d0679a3c1"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/17.c%E5%8A%A0%E5%8A%A0%E7%BC%96%E7%A8%8B/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-15.png"></a></p>
<p>用意就是当一个指针指向父类时，初始化让他指向子类，那么此时需要实现上图类中的代码。</p>
<h3 id="namespace命令空间">namespace（命令空间）</h3>
<p>使用示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>使用方法：</p>
<div class="tab-panel" data-tab-group="9467843f44a2c4a9de938868cac31547">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="using-directionfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('9467843f44a2c4a9de938868cac31547','using-directionfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> using direction</span>
    </button>
    <button
      data-tab-item="using-declarationfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;"
      onclick="switchTab('9467843f44a2c4a9de938868cac31547','using-declarationfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> using declaration</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="using-directionfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="using-declarationfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>或者</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
      <li><a href="/Class/17.C%e5%8a%a0%e5%8a%a0%e7%bc%96%e7%a8%8b/1.%e4%bb%a3%e7%a0%81%e7%bc%96%e5%86%99%e8%a7%84%e8%8c%83/_index.files/complex.h">complex.h</a> (546 B)</li>
      <li><a href="/Class/17.C%e5%8a%a0%e5%8a%a0%e7%bc%96%e7%a8%8b/1.%e4%bb%a3%e7%a0%81%e7%bc%96%e5%86%99%e8%a7%84%e8%8c%83/_index.files/Foo.hpp">Foo.hpp</a> (1 KB)</li>
      <li><a href="/Class/17.C%e5%8a%a0%e5%8a%a0%e7%bc%96%e7%a8%8b/1.%e4%bb%a3%e7%a0%81%e7%bc%96%e5%86%99%e8%a7%84%e8%8c%83/_index.files/String.h">String.h</a> (1 KB)</li>
  </ul>
</div>
  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月15日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/">C语言程序</a></li>
  </ul>
</div>
  </header>

<h1 id="21c语言程序设计含面试">21.C语言程序设计（含面试）</h1>

<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/">1.在线题库练习</a><p><h2 id="网站">网站</h2>
<ul>
<li><a href="https://www.dotcpp.com/oj/ybt-cpp/?page=1" rel="external" target="_blank">&ldquo;语言网【基础】&rdquo;</a></li>
<li><a href="http://cxsjsxmooc.openjudge.cn/2023t1spring/" rel="external" target="_blank">&ldquo;大学慕课对应习题【算法基础】&rdquo;</a></li>
<li><a href="https://ac.nowcoder.com/acm/skill/detail/noip-tg/1582" rel="external" target="_blank">&ldquo;牛客竞赛【中等】&rdquo;</a></li>
<li><a href="https://leetcode.cn/studyplan/top-100-liked/" rel="external" target="_blank">&ldquo;LeetCode【较难】&rdquo;</a></li>
</ul>
<h2 id="课程学习">课程学习</h2>
<ul>
<li><a href="https://sse.hit.edu.cn/book/" rel="external" target="_blank">&ldquo;书籍&rdquo;</a></li>
<li><a href="https://www.icourse163.org/learn/PKU-1001553023?tid=1473340448#/learn/announce" rel="external" target="_blank">&ldquo;大学慕课&rdquo;</a>
Github项目</li>
<li><a href="https://github.com/huihut/interview?tab=readme-ov-file#cc-development-direction" rel="external" target="_blank">&ldquo;C/C++面试总结项目&rdquo;</a></li>
<li><a href="https://github.com/ZhongYi-LinuxDriverDev/CS-EmbeddedLinux-Book?tab=readme-ov-file#c" rel="external" target="_blank">&ldquo;书籍：Github项目&rdquo;</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md" rel="external" target="_blank">&ldquo;C/C++面试总结&rdquo;</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" rel="external" target="_blank">&ldquo;系统设计&rdquo;</a></li>
</ul>
<h2 id="题目笔记">题目笔记</h2>
<p>1.<code>cahr *s = &quot;AAAA&quot;</code>指针接受一个字符串（右值），当想通过s[0] = &lsquo;B&rsquo;修改时是无法修改成功的，因为&quot;AAAA&quot;只能读，不能写。
2.一般函数内如果返回char s[] = {&ldquo;abcd&rdquo;};那么一般会报错，因为这是一个局部变量，但s[]修改为*s就不会有问题。因为 *s指向的地址是固定的。
3.在自动类型转换中：</p></p></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年11月18日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E8%87%AA%E5%AD%A6%E8%AF%BE%E7%A8%8B/">自学课程</a></li>
  </ul>
</div>
  </footer>
</article>
          <section>
            <h1 class="a11y-only">21.C语言程序设计（含面试） 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;%E9%9D%A2%E8%AF%95/">C&#43;&#43;面试</a></li>
    <li><a class="term-link" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></li>
  </ul>
</div>
  </header>

<h1 id="1在线题库练习">1.在线题库练习</h1>

<h2 id="网站">网站</h2>
<ul>
<li><a href="https://www.dotcpp.com/oj/ybt-cpp/?page=1" rel="external" target="_blank">&ldquo;语言网【基础】&rdquo;</a></li>
<li><a href="http://cxsjsxmooc.openjudge.cn/2023t1spring/" rel="external" target="_blank">&ldquo;大学慕课对应习题【算法基础】&rdquo;</a></li>
<li><a href="https://ac.nowcoder.com/acm/skill/detail/noip-tg/1582" rel="external" target="_blank">&ldquo;牛客竞赛【中等】&rdquo;</a></li>
<li><a href="https://leetcode.cn/studyplan/top-100-liked/" rel="external" target="_blank">&ldquo;LeetCode【较难】&rdquo;</a></li>
</ul>
<h2 id="课程学习">课程学习</h2>
<ul>
<li><a href="https://sse.hit.edu.cn/book/" rel="external" target="_blank">&ldquo;书籍&rdquo;</a></li>
<li><a href="https://www.icourse163.org/learn/PKU-1001553023?tid=1473340448#/learn/announce" rel="external" target="_blank">&ldquo;大学慕课&rdquo;</a>
Github项目</li>
<li><a href="https://github.com/huihut/interview?tab=readme-ov-file#cc-development-direction" rel="external" target="_blank">&ldquo;C/C++面试总结项目&rdquo;</a></li>
<li><a href="https://github.com/ZhongYi-LinuxDriverDev/CS-EmbeddedLinux-Book?tab=readme-ov-file#c" rel="external" target="_blank">&ldquo;书籍：Github项目&rdquo;</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md" rel="external" target="_blank">&ldquo;C/C++面试总结&rdquo;</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" rel="external" target="_blank">&ldquo;系统设计&rdquo;</a></li>
</ul>
<h2 id="题目笔记">题目笔记</h2>
<p>1.<code>cahr *s = &quot;AAAA&quot;</code>指针接受一个字符串（右值），当想通过s[0] = &lsquo;B&rsquo;修改时是无法修改成功的，因为&quot;AAAA&quot;只能读，不能写。
2.一般函数内如果返回char s[] = {&ldquo;abcd&rdquo;};那么一般会报错，因为这是一个局部变量，但s[]修改为*s就不会有问题。因为 *s指向的地址是固定的。
3.在自动类型转换中：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    unsiged <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%d&#34;</span>, b<span style="color:#f92672">+</span>a);</span></span></code></pre></div>
<p>此处会触发隐式转换——int类型转为uniged int 类型。</p>
<p>4.大端模式和小端模式的作用是什么，为什么会出现这两种模式？</p>
<p>作用：
**大端模式：**在这种模式下，数据的高字节（最重要的字节）保存在内存的低地址处，而数据的低字节（最不重要的字节）保存在内存的高地址处。这种方式类似于人类读写数值的习惯，即从高位到低位
。
**小端模式：**在这种模式下，数据的低字节保存在内存的低地址处，而数据的高字节保存在内存的高地址处。这种方式在进行数据类型转换时不需要调整字节内容，直接截取低字节即可</p>
<p>测试代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">test</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> arr[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">test</span> num;
</span></span><span style="display:flex;"><span>        num.n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x12345678</span>;<span style="color:#75715e">//注意:12所在位置是高位 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;&amp;arr[%d]  = %p, arr[%d] = %#x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i,<span style="color:#f92672">&amp;</span>num.arr[i],i,num.arr[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    代码解释：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            代码中，%x表示输出16进制，x前加 # 标志表示，如果使用 %ox（八进制），
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            则输出的数前面会加上前缀 0；如果使用 %#x 或 %#X（十六进制），
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            则输出的数前面会加上前缀 0x 或 0X。这样做可以明确地表示数值的进制，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            便于阅读和理解。 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    结果：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        &amp;arr[0]  = 000000000062FE10, arr[0] = 0x78
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        &amp;arr[1]  = 000000000062FE11, arr[1] = 0x56
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        &amp;arr[2]  = 000000000062FE12, arr[2] = 0x34
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        &amp;arr[3]  = 000000000062FE13, arr[3] = 0x12 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    结论：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        高位存储在高地址，所以是小端模式。 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span> 
</span></span></code></pre></div>
<p>5.printf的返回值类型是变量的字符个数。
6.#和##运算符的使用</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define T(x) printf(&#34;&#34;#x&#34; square is the &#34;,(x)*(x))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define TEST(n) X##n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>        T(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> TEST(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> TEST(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%d&#34;</span>,X1);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>结果：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#ae81ff">4</span> square is the <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>    X1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span></span></span></code></pre></div>
<p>7.结构体中存储字符串时我们可以使用字符指针或者字符数组，但是一般推荐字符数组。选择字符数组还是字符指针取决于具体的应用场景和需求。如果字符串长度固定或较短，且对性能和内存连续性有要求，字符数组可能是更好的选择。如果需要灵活处理不同长度的字符串，或者字符串长度可能非常大，使用字符指针可能更合适，但需要更加小心地管理内存。</p>
<p>8.strlen()和strcpy()</p>
<p><code>strlen()</code> 和 <code>strcpy()</code> 是 C 语言标准库中的两个常用函数，它们用于处理字符串。下面分别解释它们的用途和使用时需要注意的事项。</p>
<h3 id="strlen-函数">strlen() 函数</h3>
<p><strong>用途</strong>：
<code>strlen()</code> 函数用于计算一个以空字符（<code>'\0'</code>）结尾的字符串的长度。它返回字符串的长度，不包括最后的空字符。</p>
<p><strong>函数原型</strong>：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">strlen</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str);</span></span></code></pre></div>
<p><strong>使用注意事项</strong>：</p>
<ol>
<li><strong>参数必须是以空字符结尾的字符串</strong>：如果传入的参数不是以空字符结尾的字符串，<code>strlen()</code> 会一直读取内存直到遇到空字符，这可能导致程序读取到未分配的内存区域，造成越界错误。</li>
<li><strong>返回值类型</strong>：<code>strlen()</code> 返回的是 <code>size_t</code> 类型，它是一个无符号整数类型，用于表示大小或长度。在比较时，需要注意不要与有符号整数类型进行比较，以避免潜在的负值问题。</li>
<li><strong>效率问题</strong>：<code>strlen()</code> 需要遍历整个字符串直到找到空字符，因此对于非常长的字符串，可能会有一定的性能开销。</li>
</ol>
<h3 id="strcpy-函数">strcpy() 函数</h3>
<p><strong>用途</strong>：
<code>strcpy()</code> 函数用于将源字符串（包括空字符）复制到目标字符串中。它会覆盖目标字符串原有的内容。</p>
<p><strong>函数原型</strong>：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">strcpy</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>dest, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>src);</span></span></code></pre></div>
<p><strong>使用注意事项</strong>：</p>
<ol>
<li><strong>目标字符串必须足够大</strong>：在使用 <code>strcpy()</code> 之前，必须确保目标字符串 <code>dest</code> 有足够的空间来存储源字符串 <code>src</code> 的内容，包括最后的空字符。否则，可能会导致缓冲区溢出，这是常见的安全漏洞。</li>
<li><strong>不检查目标字符串大小</strong>：<code>strcpy()</code> 不会自动检查目标字符串的大小，如果目标字符串空间不足，会发生溢出。</li>
<li><strong>不进行类型检查</strong>：<code>strcpy()</code> 不会对传入的参数类型进行检查，因此传入的参数必须是字符数组或字符指针。</li>
<li><strong>返回值</strong>：<code>strcpy()</code> 返回目标字符串的指针，通常用于链式操作，但需要注意不要因此覆盖了重要的指针值。</li>
<li><strong>安全性问题</strong>：由于上述原因，<code>strcpy()</code> 在很多情况下被认为是不安全的。在实际编程中，推荐使用 <code>strncpy()</code> 或其他更安全的字符串复制函数，这些函数允许指定最大复制的字符数，从而避免溢出。</li>
</ol>
<p>9.修改字节对齐方式 ：<code>#pragma pack(n) //n表示字节对起数，如2，4，8，</code></p>
<p>10.不同位数电脑的字节对齐方式</p>
<p>解释代码含义：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define offsetof(TYPE, MEMBER) ((size_t ) &amp;((TYPE *)0)-&gt;MEMBER)</span></span></span></code></pre></div>
<ul>
<li><code>(TYPE *)0</code>:将0强制转换为TYPE类型指针，p = (TYPE *)0;</li>
<li><code>((TYPE *)0)-&gt; MEMNER</code>:通过指针访问MEMBER成员，</li>
<li><code>&amp;((TYPE *)0)-&gt; MEMNER</code>：取得成员地址</li>
<li><code>((size_t ) &amp;((TYPE *)0)-&gt;MEMBER)</code>：将成员地址转为size_t类型
总结：该宏定义的作用是求出MEMBER成员变量在TYPE中的偏移量。</li>
</ul>
<p>示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">//#pragma pack(4) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">#define offsetof(TYPE, MEMBER) ((size_t ) &amp;((TYPE *)0)-&gt;MEMBER)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* data */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a;<span style="color:#75715e">//4字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">char</span> str[<span style="color:#ae81ff">10</span>];<span style="color:#75715e">//10字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">s</span><span style="color:#f92672">*</span> next;
</span></span><span style="display:flex;"><span>    }S;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%ld&#34;</span>,offsetof(S, next));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;    
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>结果为16，因为电脑是64位的，所以以8字节对齐，联合体字节大小以最大的成员变量为准，故联合体的字节大小是10个字节</p>
<p>12.返回二进制数中1的个数（经典题目）
<a href="#R-image-3c585406aabfb840569b1511dda8099a" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3c585406aabfb840569b1511dda8099a"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image.png"></a></p>
<p>13.求2的n次方
<a href="#R-image-03ead4202f0dd3b78e06de410e95e773" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-03ead4202f0dd3b78e06de410e95e773"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-1.png"></a></p>
<p>14.操作符[]的重载，代码实现读和写。
<a href="#R-image-0b6ff7fbb83d10dc4f54947be7173db1" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0b6ff7fbb83d10dc4f54947be7173db1"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-2.png"></a></p>
<p>15.与操作与位操作</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">|=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">3</span>);<span style="color:#75715e">//将a的第3位设置为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,a);
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">3</span>);<span style="color:#75715e">//将a的第3位设置为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,a);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>知识点：</p>
<ul>
<li>只要出现置1：或操作</li>
<li>只要出现置0：与操作
<a href="#R-image-d006fd36923c506c98fa9511820927a1" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d006fd36923c506c98fa9511820927a1"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-3.png"></a></li>
</ul>
<p>16.sizeof的使用</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,a);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#66d9ef">sizeof</span>(a<span style="color:#f92672">++</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,a);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>结果为：10,4,10,为什么最后不是11呢？
<a href="#R-image-3b6858de1b8e6a0abe51eacafc824467" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3b6858de1b8e6a0abe51eacafc824467"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-4.png"></a></p>
<p>17.指向地址的指针加一个整数</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p1 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x08000010</span>;<span style="color:#75715e">//指向地址的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x08000010</span>;<span style="color:#75715e">//指向地址的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%#x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,p1<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%#x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,p2<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>结果是0x08000015和0x08000024，</p>
<ul>
<li>对于前一个答案我们很清楚，因为一个unsigned char占一个字符，加5则是加5个字符；</li>
<li>后一个答案则是加5个long，一个long占4个字符，所以加5个long就是加20个字符，那么应该是0x08000030才对，为什么是0x08000024呢？因为使用的是16进制计算，20的十六进制就是14，所以是0x08000024。</li>
</ul>
<p>18.volatile关键字</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">squere</span>(<span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pt){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//正确写法如下：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//int a = *pt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//return a*a;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>pt)<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>pt);<span style="color:#75715e">//这样写可能会出错，因为编译器可能会优化代码，认为*pt的值没有改变，所以直接返回上一次的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,squere(<span style="color:#f92672">&amp;</span>a));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p><a href="#R-image-42478084a6dc267df2d32d2cd16b30c0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-42478084a6dc267df2d32d2cd16b30c0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-5.png"></a></p>
<p>19.假设有两个变量a,b，不借助第三个变量交换两个变量的值。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;b<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">=</span>a<span style="color:#f92672">^</span>b;<span style="color:#75715e">//0010^0011=0001
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b<span style="color:#f92672">=</span>a<span style="color:#f92672">^</span>b;<span style="color:#75715e">//0001^0011=0010
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    a<span style="color:#f92672">=</span>a<span style="color:#f92672">^</span>b;<span style="color:#75715e">//0001^0010=0011
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d,%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,a,b);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>还可以使用减法的思想：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;b<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    a<span style="color:#f92672">=</span>a<span style="color:#f92672">+</span>b;<span style="color:#75715e">//a=5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b<span style="color:#f92672">=</span>a<span style="color:#f92672">-</span>b;<span style="color:#75715e">//b=2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    a<span style="color:#f92672">=</span>a<span style="color:#f92672">-</span>b;<span style="color:#75715e">//a=3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d,%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,a,b);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>20.左移右移运算符和条件运算符的优先级</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>using namespace std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>(a<span style="color:#f92672">&gt;</span>b)<span style="color:#f92672">?</span>a:b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>结果输出为0，因为条件运算符的优先级低于左移运算符，所以先执行了左移运算符，结果为0。</p>
<p>21.交换地址的高位和地位</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">convert</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入一个整数：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%x&#34;</span>,<span style="color:#f92672">&amp;</span>a);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">convert</span>(<span style="color:#f92672">&amp;</span>a);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;转换后的整数为：%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,a);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">convert</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> temp;
</span></span><span style="display:flex;"><span>    temp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x0f</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>a <span style="color:#f92672">&amp;=</span> <span style="color:#ae81ff">0xf0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>a <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">|</span> (temp <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">结果：</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">```</span>c
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">请输入一个整数：</span><span style="color:#ae81ff">0x3A</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">转换后的整数为：</span><span style="color:#ae81ff">0xa3</span></span></span></code></pre></div>
<p>22.一级指针和二级指针
<a href="#R-image-cb18b1b0da0d46f7564cfbea5a9b88b3" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-cb18b1b0da0d46f7564cfbea5a9b88b3"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-6.png"></a></p>
<p>23.如果从数组x复制50个字节到数组y,最简单的方法是什么？</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> x[<span style="color:#ae81ff">50</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> y[<span style="color:#ae81ff">50</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(y,x,<span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,y);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>memcpy 是一个用于在内存中复制数据的函数，定义在 C 标准库中的 &lt;string.h&gt; 头文件中。它的原型如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">memcpy</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dest, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>src, <span style="color:#66d9ef">size_t</span> n);</span></span></code></pre></div>
<p>参数说明</p>
<ul>
<li>dest：指向目标内存位置的指针，即数据将被复制到的位置。</li>
<li>src：指向源内存位置的指针，即数据将从哪里复制。</li>
<li>n：<strong>要复制的字节数。</strong></li>
</ul>
<p>返回值</p>
<p>返回指向目标内存位置的指针 dest。</p>
<p>用途</p>
<p>memcpy 函数主要用于在内存中复制数据块，常用于以下场景：</p>
<ul>
<li>字符串复制：复制字符串内容。</li>
<li>结构体复制：复制结构体数据。</li>
<li>数组复制：复制数组元素。</li>
</ul>
<p>使用注意事项</p>
<ul>
<li>目标内存必须足够大：确保目标内存区域足够大，能够容纳从源内存复制过来的数据，否则会导致缓冲区溢出。</li>
<li>源和目标内存不能重叠：如果源和目标内存区域有重叠，memcpy 的行为是未定义的。如果需要处理重叠的情况，可以使用 memmove 函数。</li>
<li>类型安全：memcpy 是一个低级别的内存操作函数，不进行类型检查，因此在使用时需要确保数据类型的一致性。</li>
<li>性能考虑：memcpy 通常比手动循环复制更高效，因为它利用了底层硬件的优化。</li>
</ul>
<p>24.将字符数字转为整形数字</p>
<p>思路：使用指针取出字符串中的每个字符，然后减去字符'0&rsquo;的ASCII码值，即可得到对应的整形数字。
编写一个函数来实现这个操作，函数原型如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ascii_to_integer</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str);</span></span></code></pre></div>
<p>其中，str 是一个指向字符数字字符串的指针，函数返回对应的整形数字。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ascii_to_integer</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> digit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">*</span>str <span style="color:#f92672">&gt;=</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>str <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;9&#39;</span>){
</span></span><span style="display:flex;"><span>        digit <span style="color:#f92672">=</span> digit <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> (<span style="color:#f92672">*</span>str <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>        str<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">*</span>str <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;\0&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> digit;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// int digit = ascii_to_integer(argv[1]);//在Linux中可以尝试这样写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> str[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;请输入一串数字字符：&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">scanf</span>(<span style="color:#e6db74">&#34;%s&#34;</span>,str);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;The digit is: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">ascii_to_integer</span>(str));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>24.百钱买百鸡问题</p>
<p>解题思路如下图：
<a href="#R-image-54da84302e47ddf2dccb5fad4c2b1822" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-54da84302e47ddf2dccb5fad4c2b1822"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-7.png"></a></p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x, y, z;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;t<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">4</span>;t<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> t;
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> <span style="color:#ae81ff">25</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">7</span> <span style="color:#f92672">*</span> t;
</span></span><span style="display:flex;"><span>        z <span style="color:#f92672">=</span> <span style="color:#ae81ff">75</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> t;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;cock:%d,hen:%d,chicken:%d-----sum:%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,x,y,z,x<span style="color:#f92672">+</span>y<span style="color:#f92672">+</span>z);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">结果：</span>
</span></span><span style="display:flex;"><span>cock:<span style="color:#ae81ff">0</span>,hen:<span style="color:#ae81ff">25</span>,chicken:<span style="color:#ae81ff">75</span><span style="color:#f92672">-----</span>sum:<span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>cock:<span style="color:#ae81ff">4</span>,hen:<span style="color:#ae81ff">18</span>,chicken:<span style="color:#ae81ff">78</span><span style="color:#f92672">-----</span>sum:<span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>cock:<span style="color:#ae81ff">8</span>,hen:<span style="color:#ae81ff">11</span>,chicken:<span style="color:#ae81ff">81</span><span style="color:#f92672">-----</span>sum:<span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>cock:<span style="color:#ae81ff">12</span>,hen:<span style="color:#ae81ff">4</span>,chicken:<span style="color:#ae81ff">84</span><span style="color:#f92672">-----</span>sum:<span style="color:#ae81ff">100</span></span></span></code></pre></div>
<p>25.*和++运算符优先级
二者的运算优先级是一样的。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> arr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">*</span>p<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> arr;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">-------------------------------------------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">*++</span>p);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> arr;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">-------------------------------------------</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">++</span>(<span style="color:#f92672">*</span>p));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>26.函数指针类型
<a href="#R-image-3e544152f25189dd7bbe89bc65237010" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3e544152f25189dd7bbe89bc65237010"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-8.png"></a></p>
<p>27.编写函数实现整数四舍五入
思路：对于正数我们可以加0.5，然后取整；
对于负数则减去0.5，然后取整。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">round</span>(<span style="color:#66d9ef">int</span> num){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(num <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.6</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;round(%d) = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,num,<span style="color:#a6e22e">round</span>(num));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>28.下图代码运行结果
<a href="#R-image-5873d1930fd6662f72462808cddc6f4b" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5873d1930fd6662f72462808cddc6f4b"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-9.png"></a></p>
<p>29.函数指针数组
<a href="#R-image-2c735ca66265608510082ce5df1d62e8" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c735ca66265608510082ce5df1d62e8"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/21.c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%90%AB%E9%9D%A2%E8%AF%95/1.%E5%9C%A8%E7%BA%BF%E9%A2%98%E5%BA%93%E7%BB%83%E4%B9%A0/image-10.png"></a></p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年11月18日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/m1-%E9%9D%A2%E8%AF%95/">M1-面试</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;%E9%9D%A2%E8%AF%95/">C&#43;&#43;面试</a></li>
  </ul>
</div>
  </header>

<h1 id="20c面试">20.C&#43;&#43;面试</h1>

<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/class/20.c%E5%8A%A0%E5%8A%A0%E9%9D%A2%E8%AF%95/1.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">1.网络编程</a><p><h2 id="网络编程">网络编程</h2>
<h2 id="网络原理">网络原理</h2>
<h2 id="数据库">数据库</h2>
<h2 id="c基础">C++基础</h2>
<p>1.左值引用和右值引用</p>
<h2 id="数据湖结构与算法">数据湖结构与算法</h2>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div></p></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年11月1日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E8%87%AA%E5%AD%A6%E8%AF%BE%E7%A8%8B/">自学课程</a></li>
  </ul>
</div>
  </footer>
</article>
          <section>
            <h1 class="a11y-only">20.C++面试 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;%E9%9D%A2%E8%AF%95/">C&#43;&#43;面试</a></li>
    <li><a class="term-link" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></li>
  </ul>
</div>
  </header>

<h1 id="1网络编程">1.网络编程</h1>

<h2 id="网络编程">网络编程</h2>
<h2 id="网络原理">网络原理</h2>
<h2 id="数据库">数据库</h2>
<h2 id="c基础">C++基础</h2>
<p>1.左值引用和右值引用</p>
<h2 id="数据湖结构与算法">数据湖结构与算法</h2>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年11月1日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/m1-%E9%9D%A2%E8%AF%95/">M1-面试</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/c&amp;#43;&amp;#43;/">C&#43;&#43;</a></li>
  </ul>
</div>
  </header>

<h1 id="1代码编写规范">1.代码编写规范</h1>

<h2 id="如何写一个标准的h文件">如何写一个标准的.h文件</h2>
<p>以下内容来自<a href="https://www.bilibili.com/video/BV1ELHEewEms/?p=6&spm_id_from=pageDriver&vd_source=5e8e4e9e284af3291f1a3addff3fc2c3" rel="external" target="_blank">B站</a>。</p>
<p>接下来将以复数的库文件为例来回答这个问题，下面是一段参考复数库文件代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">complex</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* data */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> re,im;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> complex<span style="color:#f92672">&amp;</span> __doapl (complex<span style="color:#f92672">*</span>,<span style="color:#66d9ef">const</span> complex<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    complex (<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span>re(r),im(i)                <span style="color:#75715e">//这是一个构造函数，这种写法意思是初始化变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {};
</span></span><span style="display:flex;"><span>    complex<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">+=</span> (complex <span style="color:#66d9ef">operator</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> re;}  <span style="color:#75715e">//这里需要加const 意思就是修饰函数的返回值，不允许改变返回值类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> im;}
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="构造函数的特性">构造函数的特性</h2>
<p>这一点需要关注下面的代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>complex (<span style="color:#66d9ef">double</span> r,<span style="color:#66d9ef">double</span> i)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span>re(r),im(i)                <span style="color:#75715e">//这是一个构造函数，这种写法意思是初始化变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {};</span></span></code></pre></div>
<h2 id="关于const修饰符">关于const修饰符</h2>
<p>如上面说到的，函数返回最好是加const，这样可以应付下面情况的发生。</p>
<div class="tab-panel" data-tab-group="e154b72d970d2ed65b2c27fd259fea7c">
  <div class="tab-nav">
    <div class="tab-nav-title">const的使用</div>
    <button
      data-tab-item="加constfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('e154b72d970d2ed65b2c27fd259fea7c','加constfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 加const</span>
    </button>
    <button
      data-tab-item="不加constfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;"
      onclick="switchTab('e154b72d970d2ed65b2c27fd259fea7c','不加constfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 不加const</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="加constfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> re;}  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> () <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> im;}</span></span></code></pre></div>
<p>此时做如下两种使用都是正确的</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="不加constfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">read</span> ()  {<span style="color:#66d9ef">return</span> re;}  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span> ()  {<span style="color:#66d9ef">return</span> im;}</span></span></code></pre></div>
<p>此时做如下两种使用只有第一种可以被执行，第二种会报错。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>com1.real()<span style="color:#f92672">&lt;&lt;</span>endl;</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="函数传递和返回值的两种方式">函数传递和返回值的两种方式</h2>
<p>pass by values:传值。在传输的事单字节或者字节数较少的情况下使用，比如传一个字符。</p>
<p>pass by reference:传引用。在C++中引用的底层逻辑就是传指针，也就是类似穿了地址，也就是只传输4个字节，
在这种情况下你可以使用const修饰符，迫使函数不能修改值，如果希望函数对值进行处理则可以不加</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">re</span>(<span style="color:#66d9ef">const</span> classname<span style="color:#f92672">&amp;</span> cl){};<span style="color:#75715e">//加了const
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">re</span>(classname cl){};<span style="color:#75715e">//没有加const
</span></span></span></code></pre></div>
<p>对于返回值，我们可以返回值，也可以返回引用，但什么情况下返回的是引用呢？</p>
<p>在设计类中的函数时，可以先考虑返回类型适不适合<code>引用</code>,如果返回的是已经存在的地址，那么可以选择返回类型为引用，否则不使用。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> complex<span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span>        __ap(complex <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span> ,<span style="color:#66d9ef">const</span> complex <span style="color:#f92672">&amp;</span> c){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>re <span style="color:#f92672">+=</span> c.re;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>im <span style="color:#f92672">+=</span> c.im;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        }</span></span></code></pre></div>
<p>向上面的函数就是使用了引用返回。</p>
<h2 id="操作符重载-1成员函数">操作符重载-1：成员函数</h2>
<p><a href="#R-image-1eecdded476b8090f65ef19b276a12cb" class="lightbox-link"><img alt="操作符重载" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1eecdded476b8090f65ef19b276a12cb"><img alt="操作符重载" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image.png"></a></p>
<h2 id="操作符重载-2非成员函数">操作符重载-2：非成员函数</h2>
<p>假设现在要计算复数的加减，如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com1</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    complex <span style="color:#a6e22e">com2</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">9</span>);
</span></span><span style="display:flex;"><span>    complex com3;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> com1 <span style="color:#f92672">+</span> com2;
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> com1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    com3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> com2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span></span></span></code></pre></div>
<p>对于这段代码在库文件中，要对加法做非成员函数重载，以应付 不同的情况。</p>
<p>接下来在考虑一个问题，就是如果我们只是做<code>cout&lt;&lt;com1;</code>那么对于&laquo;函数返回值可以是void类,但是如果我们做的是<code>cout&lt;&lt;com1&lt;&lt;com2&lt;&lt;endl;</code>
这样的操作返回类型为void类型，那么当运行<code>cout&lt;&lt;com1</code>后就无法运行<code>&lt;&lt;com2&lt;&lt;endl</code>的代码.</p>
<p>很显然要让代码继续运行，我们还需要返回iostream类型，而且使用<code>return by reference</code>返回方法，也就是返回引用。如下图：
<a href="#R-image-ba649ee132363df4c9f099904279b500" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ba649ee132363df4c9f099904279b500"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-1.png"></a></p>
<h2 id="小结">小结</h2>
<p>通过以上的简单讲解，我们可以总结一下，再写一个类的时候，我们需要注意以下几点：</p>
<ul>
<li>确定类的数据并写在private中;</li>
<li>对于构造函数要善于使用初始化数据方法；</li>
<li>对于函数要想一想，返回类型是否可以改变，要不要写const；</li>
<li>对于函数类型和返回值，要传值还是传引用，要返回值还是返回引用。</li>
</ul>
<p>是否返回引用最最好的判断标准就是，值在经过函数运算后存储在函数外，或说是一个以存在的存储地址，否则不返回引用</p>
<h2 id="接下来通过学习stringh库进一步了解指针的使用">接下来通过学习string.h库，进一步了解指针的使用</h2>
<p>一般有指针的类需要写三个特殊函数拷贝构造、拷贝析构、拷贝赋值，</p>
<p><a href="#R-image-3e55a39b65386f9c388014bcc173e482" class="lightbox-link"><img alt="String" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3e55a39b65386f9c388014bcc173e482"><img alt="String" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-2.png"></a>
<a href="#R-image-99d064bbac0c2958ae0d2eb84616c5c4" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-99d064bbac0c2958ae0d2eb84616c5c4"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-3.png"></a>
<a href="#R-image-bb8356ddeb443b6449797f2806a474e4" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bb8356ddeb443b6449797f2806a474e4"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-4.png"></a>
<a href="#R-image-c2e0d98e11c19bea602be6fe69203139" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c2e0d98e11c19bea602be6fe69203139"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-5.png"></a></p>
<p>有时候还需要用到new 和 delete。</p>
<h2 id="stack栈和heap堆">stack（栈）和heap（堆）</h2>
<p>如下代码：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        String str1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String();
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>上面的{}内的代码就是存储在stack中，而经过new的变量存在heap中；</p>
<h3 id="stack-object-的生命周期">stack object 的生命周期</h3>
<p>在{}内的代码执行结束后，<strong>自动调用析构函数</strong>将变量清理掉，如下代码，</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="static-local-object-的生命周期">static local object 的生命周期</h3>
<p>添加关键字static的变量成为静态变量，在作用于如下面代码的{}结束后不会被析构函数清理掉，
变量会存储直到程序结束。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="global-objects-生命周期">global objects 生命周期</h3>
<p>全局变量在程序接收后才会被清理掉。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{<span style="color:#960050;background-color:#1e0010">……</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    String <span style="color:#a6e22e">str</span>(<span style="color:#e6db74">&#34;hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h3 id="调用new和delete的过程">调用new和delete的过程</h3>
<p>在使用new的地方需要使用delete清理内存，防止内存泄露。</p>
<p>调用new过程：</p>
<p><a href="#R-image-787968aadb49304d98bb1acbd3bb85bd" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-787968aadb49304d98bb1acbd3bb85bd"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-6.png"></a></p>
<p>调用delete的过程：</p>
<p><a href="#R-image-a3b1a61d4361bb62474bfca029ef4e00" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a3b1a61d4361bb62474bfca029ef4e00"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-7.png"></a>
<a href="#R-image-985848329b62e92a2de752998c4b9a56" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-985848329b62e92a2de752998c4b9a56"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-8.png"></a></p>
<p>代码 分配内存大小左图是调试模式下的内存分配，右图是非调试模式下分配的内存</p>
<p><a href="#R-image-e1c142ebc693f05eec324a093a4c5fc2" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e1c142ebc693f05eec324a093a4c5fc2"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-9.png"></a></p>
<p>new与delete的搭配，在删除数组时需要加上[]否则编译器不知道你要删的是数组：</p>
<p><a href="#R-image-4b591dbde5d871521b378b868acdc222" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4b591dbde5d871521b378b868acdc222"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-10.png"></a></p>
<h2 id="new和delete的补充">new和delete的补充</h2>
<p>对new和delete的重载，用于设计内存管理，如内存池等操作。</p>
<h3 id="重载newdelete">重载::new,::delete</h3>
<p>重载的函数中，new操作会接收一个大小，该大小由编译器传入，而delete传入的是一个指针，如下图；
<a href="#R-image-c0de7fefcc8c26e603ef688356311901" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-16.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c0de7fefcc8c26e603ef688356311901"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-16.png"></a></p>
<p>如果不想使用类中的new和delete，可以在二者之前加上:,如::new,::delete，这样在调用函数时就不会调用类设计中的new和delete重载，而是全局的。</p>
<h3 id="类中重载的new和delete">类中重载的new和delete</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">F</span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> operate <span style="color:#66d9ef">new</span>(size_t);<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> operate <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>,size_t);<span style="color:#75715e">//2,size_t可不写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段1的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> mem <span style="color:#f92672">=</span> operate <span style="color:#66d9ef">new</span>(size_t);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">*&gt;</span>(mem);<span style="color:#75715e">//类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>F<span style="color:#f92672">::</span>F();<span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段2的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">-&gt;~</span>F();
</span></span><span style="display:flex;"><span>operate <span style="color:#a6e22e">delete</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// main函数调用示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    F<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> F();
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> p;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="类中重载的new和delete-1">类中重载的new[]和delete[]</h3>
<p>代码整体流程与上一个情况类似，区别在于new[]是申请数组内存，在销毁的时候如果不使用delete[]释放内存，delete只会执行一次，导致内存没有完全释放，详细代码如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">F</span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> operate <span style="color:#66d9ef">new</span>(size_t);<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> operate <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>,size_t);<span style="color:#75715e">//2,size_t可不写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段1的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> mem <span style="color:#f92672">=</span> operate <span style="color:#66d9ef">new</span>(size_t<span style="color:#f92672">*</span>N <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>);<span style="color:#75715e">//指针占4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">*&gt;</span>(mem);<span style="color:#75715e">//类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>F<span style="color:#f92672">::</span>F();<span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//代码段2的内部操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">-&gt;~</span>F();<span style="color:#75715e">//析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>operate <span style="color:#a6e22e">delete</span>(p);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// main函数调用示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    F<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> F[N];
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span>[] p;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h2 id="newdelete使用示例">new,delete使用示例</h2>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> _id;<span style="color:#75715e">//4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> _data;<span style="color:#75715e">//4个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    string _str;<span style="color:#75715e">//40个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Foo() <span style="color:#f92672">:</span>_id(<span style="color:#ae81ff">0</span>)       { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;default ctor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    Foo(<span style="color:#66d9ef">int</span> i) <span style="color:#f92672">:</span>_id(i)  { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ctor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>Foo()              { cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;dtor.this = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> _id <span style="color:#f92672">&lt;&lt;</span> endl; };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](size_t size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (Foo<span style="color:#f92672">*</span>)malloc(size);
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;new size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;delete size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    free(p);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (Foo<span style="color:#f92672">*</span>)malloc(size);
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;new[] size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Foo<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p, size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;delete[] size = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    free(p);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>运行结果如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>new size <span style="color:#f92672">=</span> <span style="color:#ae81ff">48</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC67A460id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC67A460id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>delete size <span style="color:#f92672">=</span> <span style="color:#ae81ff">48</span>
</span></span><span style="display:flex;"><span>_____________________________________________
</span></span><span style="display:flex;"><span>new[] size <span style="color:#f92672">=</span> <span style="color:#ae81ff">104</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673438id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">default</span> ctor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673468id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673468id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>dtor.this <span style="color:#f92672">=</span> <span style="color:#ae81ff">000001</span><span style="color:#ae81ff">91</span>EC673438id: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>delete[] size <span style="color:#f92672">=</span> <span style="color:#ae81ff">104</span></span></span></code></pre></div>
<h3 id="为什么new操作会多出8个字节呢">为什么new[]操作会多出8个字节呢？</h3>
<p>我看课程视频，老师说new[]分配的内存块会在最前面存储计数量，占用4个字节，表示数组大小，但是我在电脑上运行会多出8个字节，查阅资料可能与系统、对齐方式、编译器等有关。</p>
<p><a href="#R-image-d0c02fc4f69d09ee2e1a887651a01c83" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-17.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d0c02fc4f69d09ee2e1a887651a01c83"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-17.png"></a></p>
<h2 id="对new的分配额外内存">对new的分配额外内存</h2>
<p>假设分配内存的同时需要额外分配一定的内存，可以参考下面的代码：
<a href="#R-image-f334be19217e81e1f2a9aa84aed8d0e1" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-18.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f334be19217e81e1f2a9aa84aed8d0e1"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-18.png"></a></p>
<h2 id="小结-1">小结</h2>
<p>对于包含有指针的类，在必要时写上拷贝构造、拷贝赋值、析构函数，如下代码</p>
<div class="tab-panel" data-tab-group="2b2dc51240d93c52b45c4c40632b7020">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="class-stringfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('2b2dc51240d93c52b45c4c40632b7020','class-stringfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> class String</span>
    </button>
    <button
      data-tab-item="destructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;"
      onclick="switchTab('2b2dc51240d93c52b45c4c40632b7020','destructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Destructor</span>
    </button>
    <button
      data-tab-item="constructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;"
      onclick="switchTab('2b2dc51240d93c52b45c4c40632b7020','constructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Constructor</span>
    </button>
    <button
      data-tab-item="copy-constructorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: origin;"
      onclick="switchTab('2b2dc51240d93c52b45c4c40632b7020','copy-constructorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Copy Constructor</span>
    </button>
    <button
      data-tab-item="copy-assignment-operatorfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;"
      onclick="switchTab('2b2dc51240d93c52b45c4c40632b7020','copy-assignment-operatorfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> Copy Assignment Operator</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="class-stringfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> m_data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        String(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cstr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>);           <span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        String(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str);              <span style="color:#75715e">//拷贝构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        String<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str);  <span style="color:#75715e">//拷贝赋值函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">~</span>String();                              <span style="color:#75715e">//析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">get_c_str</span>() <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> m_data;}
</span></span><span style="display:flex;"><span>    };</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="destructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    String<span style="color:#f92672">::~</span>String()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="constructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: red;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> 
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">::</span>String(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> cstr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (cstr)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(cstr)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            strcpy(m_data, cstr);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            strcpy(m_data,<span style="color:#e6db74">&#39;\0&#39;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="copy-constructorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: origin;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">::</span>String(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> cstr){
</span></span><span style="display:flex;"><span>        m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(cstr.m_data) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy(m_data, cstr);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="copy-assignment-operatorfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> 
</span></span><span style="display:flex;"><span>    String<span style="color:#f92672">&amp;</span> String<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>str)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>        m_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[strlen(str.m_data) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        strcpy(m_data, str);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="补充内容static">补充内容static</h2>
<p><a href="#R-image-5fa6177ce542322ecd17118f0c4bf308" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/053bb0f3f18235ed9a9ba76e717a1673.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5fa6177ce542322ecd17118f0c4bf308"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/053bb0f3f18235ed9a9ba76e717a1673.png"></a></p>
<h3 id="static在private中的使用例子">static在private中的使用例子</h3>
<p><a href="#R-image-8a8b22be3b52d92147d6d01b2bc7ee5a" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-11.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8a8b22be3b52d92147d6d01b2bc7ee5a"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-11.png"></a>
<a href="#R-image-951d06c364cc86d1e17088f25285512f" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-12.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-951d06c364cc86d1e17088f25285512f"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-12.png"></a></p>
<h3 id="class-template">class template</h3>
<p><a href="#R-image-04378b2354b9eaf168eff8fa2767eb33" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-13.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-04378b2354b9eaf168eff8fa2767eb33"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-13.png"></a></p>
<h3 id="function-template">function template</h3>
<h3 id="member-template-成员模板">member template 成员模板</h3>
<p>类模板中，还有类模板，通常是对构造函数的操作，如下图：
<a href="#R-image-ea02c4edabbad9e3b85794548449e6d9" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-14.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ea02c4edabbad9e3b85794548449e6d9"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-14.png"></a></p>
<p>如下图代码
<a href="#R-image-2412d5b553b0dffc0cdbcf75fad61b38" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-15.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2412d5b553b0dffc0cdbcf75fad61b38"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/image-15.png"></a></p>
<p>用意就是当一个指针指向父类时，初始化让他指向子类，那么此时需要实现上图类中的代码。</p>
<h3 id="namespace命令空间">namespace（命令空间）</h3>
<p>使用示例：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">……</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>使用方法：</p>
<div class="tab-panel" data-tab-group="be609ff546afe4e4788911112c798009">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="using-directionfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;" tabindex="-1"
      onclick="switchTab('be609ff546afe4e4788911112c798009','using-directionfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> using direction</span>
    </button>
    <button
      data-tab-item="using-declarationfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;"
      onclick="switchTab('be609ff546afe4e4788911112c798009','using-declarationfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> using declaration</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="using-directionfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: green;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="using-declarationfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>或者</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&lt;&lt;</span><span style="color:#960050;background-color:#1e0010">……</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
      <li><a href="/Class/1.%e4%bb%a3%e7%a0%81%e7%bc%96%e5%86%99%e8%a7%84%e8%8c%83/_index.files/complex.h">complex.h</a> (546 B)</li>
      <li><a href="/Class/1.%e4%bb%a3%e7%a0%81%e7%bc%96%e5%86%99%e8%a7%84%e8%8c%83/_index.files/Foo.hpp">Foo.hpp</a> (1 KB)</li>
      <li><a href="/Class/1.%e4%bb%a3%e7%a0%81%e7%bc%96%e5%86%99%e8%a7%84%e8%8c%83/_index.files/String.h">String.h</a> (1 KB)</li>
  </ul>
</div>
  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年10月15日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/r1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">R1-编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/cortex-a9%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/">Cortex-A9微处理器</a></li>
    <li><a class="term-link" href="/tags/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux操作系统</a></li>
    <li><a class="term-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></li>
  </ul>
</div>
  </header>

<h1 id="嵌入式系统设计知识点">嵌入式系统设计知识点</h1>

<h2 id="基于cortex-a9微处理器的硬件平台">基于Cortex-A9微处理器的硬件平台</h2>
<h3 id="risc和cisc">RISC和CISC</h3>
<p>RISC是精简指令集计算机，CISC是复杂指令集计算机</p>
<p>RISC（精简指令集计算机，Reduced Instruction Set Computer）和CISC（复杂指令集计算机，Complex Instruction Set Computer）是两种不同的计算机架构设计理念，它们在指令集的复杂性、指令执行方式、硬件实现等方面有所区别。以下是RISC和CISC的主要特点及其区别：</p>
<ul>
<li>RISC（精简指令集计算机）
<ul>
<li>指令集简单：RISC架构拥有较少的指令，通常每个指令执行一个简单的操作。</li>
<li>指令执行快速：由于指令简单，大多数RISC指令可以在单个时钟周期内完成。</li>
<li>寄存器丰富：RISC架构通常具有更多的寄存器，以减少对内存的访问次数。</li>
<li>流水线执行：RISC处理器设计易于实现流水线技术，提高指令吞吐率。</li>
<li>编译器优化：RISC架构依赖编译器将复杂操作转换为一系列简单的指令。</li>
</ul>
</li>
<li>CISC（复杂指令集计算机）
<ul>
<li>指令集复杂：CISC架构拥有大量的指令，包括一些执行复杂操作的指令。</li>
<li>指令执行较慢：CISC指令可能需要多个时钟周期来完成。</li>
<li>寄存器较少：CISC架构通常具有较少的寄存器，更多依赖内存访问。</li>
<li>微指令执行：CISC处理器可能使用微指令（microcode）来实现复杂指令。</li>
<li>硬件复杂性：CISC处理器的硬件设计相对复杂，以支持广泛的指令集。</li>
</ul>
</li>
</ul>
<p>区别</p>
<ul>
<li>指令集大小：RISC的指令集较小，CISC的指令集较大。</li>
<li>指令复杂性：RISC指令简单，CISC指令复杂。</li>
<li>执行速度：RISC指令通常执行更快，CISC指令执行可能较慢。</li>
<li>硬件设计：RISC处理器设计相对简单，CISC处理器设计复杂。</li>
<li>内存访问：RISC架构倾向于减少内存访问，CISC架构可能更频繁地访问内存。</li>
<li>依赖编译器：RISC架构更依赖编译器优化，CISC架构则在硬件层面提供复杂操作。</li>
</ul>
<h3 id="arm处理器支持的基本数据类型">ARM处理器支持的基本数据类型</h3>
<p>数据类型：字、半字、字节。</p>
<p>说明：</p>
<ul>
<li>一个字节占8位，半个字节占16位，一个字占32位；</li>
<li>在存储数据时，字要按照4个字节来存储，所以每一次存时地址都加4，地址末位是00，例如0x13FFFFF8,0x13FFFFFC，</li>
<li>在存储数据时，半字要按照2个字节来存，所以每一次存时地址都加2，地址末位是0，例如0x13FFFFF4,0x13FFFFF6，；</li>
</ul>
<h3 id="arm处理器的工作状态">ARM处理器的工作状态</h3>
<p>主要有两种状态，主要区别就是执行的指令集位数不同；</p>
<ul>
<li>Thumb状态，微处理器执行16位的半字对齐的Thumb指令集，Thumb指令集是从ARM微处理的第四个版本开始增加（v4T）；</li>
<li>ARM状态，微处理器执行32位的字对齐的ARM指令集。</li>
</ul>
<h3 id="arm存储格式">ARM存储格式</h3>
<ul>
<li>
<p>大端格式：高字节存储在低地址，低字节存储在低地址；</p>
</li>
<li>
<p>小端格式:高字节存在高地址，低字节存储在低地址；
说明：</p>
</li>
<li>
<p>对高字节和低字节可以这样理解，假设有一个32位的地址为0x13FFFFF1，它的高字节是31，也可以理解成最高那一位的下标，31这一位存了0，低字节是0存了1。把这个理解带入上面的大端格式，小端格式。</p>
</li>
</ul>
<h3 id="arm处理器寄存器">ARM处理器寄存器</h3>
<ul>
<li>共有40个32位的寄存器，其中33个通用寄存器，7个状态寄存器；</li>
<li>通用寄存器
<ul>
<li>未分组寄存器（R0-R7）；</li>
<li>分组寄存器（R8-R14）；</li>
</ul>
</li>
<li>ARM处理器的程序状态寄存器包括：CPSR（当前程序状态寄存器）和SPSR（程序状态备份寄存器）</li>
</ul>
<h3 id="中断">中断</h3>
<h3 id="arm工作模式">ARM工作模式</h3>
<ul>
<li>
<p>用户模式（usr）:应用程序执行状态。</p>
</li>
<li>
<p>快速中断模式（fiq）：用于高速数据传输或通道处理。</p>
</li>
<li>
<p>外部中断模式（irq）：用于通用的外部中断。</p>
</li>
<li>
<p>特权模式（svc）：操作系统使用的保护模式。</p>
</li>
<li>
<p>数据访问中止模式（abt）：当数据或指令预取终止时进入该模式，可以用于虚拟存储及存储保护。</p>
</li>
<li>
<p>未定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</p>
</li>
<li>
<p>系统模式（sys）：运行具有特权的操作系统任务。</p>
</li>
<li>
<p>监控模式（mon）：可在安全模式与非安全模式之间转换。</p>
</li>
<li>
<p>执行程序什么模式？</p>
</li>
<li>
<p>读指令并执行，读取未定义指令什么模式？</p>
</li>
<li>
<p>遇到特权任务什么模式？</p>
</li>
<li>
<p>遇到中断什么模式?</p>
</li>
<li>
<p>指令执行结束什么模式？</p>
</li>
</ul>
<h3 id="3级5级流水线">3级、5级流水线</h3>
<ul>
<li>3级流水线指令可以分解成取指令、编译、执行；</li>
<li>5级流水线指令可以分解成取指令、编译、执行、缓冲、写回。</li>
</ul>
<h3 id="程序状态寄存器">程序状态寄存器</h3>
<ul>
<li>
<p>CPSR中的[31:27]为条件标志位，具体含义如下：</p>
<ul>
<li>N：符号标志位。当用两个补码表示的带符号数进行运算时，N=1表示运算的结果为负数；N=0表示运算的结果为正数或零。</li>
<li>Z：结果是否为0的标志。Z=1，表示运算结果为0；Z=0，表示运算结果为非0。</li>
<li>C：进位或借位标志位。加法运算结果产生了借位时C=1，减法运算产生了借位时C=1，否则为0；包含移位操作的非加/减运算指令，C为移出值的最后一位；其他运算指令，C的值通常不变。</li>
<li>V：溢出标志位。对于加减法运算指令，V=1表示符号位溢出，其它指令的影响V位。</li>
</ul>
</li>
<li>
<p>CPSR中的[7:0]为控制位，具体含义如下：</p>
<ul>
<li>I：IRQ中断使能位；</li>
<li>F：FIQ中断使能位；</li>
<li>T：处理器运行状态控制位；</li>
<li>M[4:0]：运行模式位。</li>
</ul>
</li>
<li>
<p>其它标志位。</p>
</li>
</ul>
<h3 id="arm指令集条件域">ARM指令集条件域</h3>
<ul>
<li>EQ：相等，（CPSR）Z=1；</li>
<li>GT：大于，Z=0&amp;&amp;N=Z;</li>
<li>TF：小于等于，Z=1||N=Z；</li>
</ul>
<h3 id="寻址指令">寻址指令</h3>
<h3 id="数据处理指令">数据处理指令</h3>
<ul>
<li>RSB 逆向减法，例如：</li>
</ul>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  RSB Rd Rn op2 ;op2<span style="color:#f92672">-</span>Rn赋值给Rd</span></span></code></pre></div>
<ul>
<li>
<p>MUL 32位乘法，</p>
</li>
<li>
<p>CMP 比较，例如</p>
</li>
</ul>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  CMP Rn op2 ;Rn<span style="color:#f92672">-</span>op2</span></span></code></pre></div>
<ul>
<li>
<p>MOV指令:它的传送指令只能是把一个寄存器的值(要能用立即数表示)赋给另一个寄存器，或者将一个常量赋给寄存器，将后边的量赋给前边的量</p>
</li>
<li>
<p>ADD指令:ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。</p>
</li>
<li>
<p>SUB指令:SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中</p>
</li>
</ul>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SUB  r0, r1, r2 ; r0 <span style="color:#f92672">=</span> r1 <span style="color:#f92672">-</span> r2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SUB  r0, r1, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">256</span>                
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SUB  r0, r2, r3, LSL<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">1</span>  ; r0 <span style="color:#f92672">=</span> r2 <span style="color:#f92672">-</span> (r3 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>)</span></span></code></pre></div>
<ul>
<li>LDR指令:LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中.</li>
</ul>
<p>用法1：
LDR r0, =0x20000000
用法2：
LDR r0, =0x30000000</p>
<ul>
<li>STR指令:STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。即：将前边的量赋值给后边的量。</li>
</ul>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>STR r0<span style="color:#960050;background-color:#1e0010">，</span>[r1]  ; <span style="color:#960050;background-color:#1e0010">将</span>r0中的字数据写入以r1为地址的存储器中
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>STR r0<span style="color:#960050;background-color:#1e0010">，</span>[r1], <span style="color:#960050;background-color:#1e0010">＃</span><span style="color:#ae81ff">8</span> ; <span style="color:#960050;background-color:#1e0010">将</span>r0中的字数据写入以r1为地址的存储器中<span style="color:#960050;background-color:#1e0010">，并将新地址</span>r1<span style="color:#960050;background-color:#1e0010">＋</span><span style="color:#ae81ff">8</span><span style="color:#960050;background-color:#1e0010">写入</span>r1<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>STR r0<span style="color:#960050;background-color:#1e0010">，</span>[r1, <span style="color:#960050;background-color:#1e0010">＃</span><span style="color:#ae81ff">8</span>] ; <span style="color:#960050;background-color:#1e0010">将</span>r0中的字数据写入以r1<span style="color:#960050;background-color:#1e0010">＋</span><span style="color:#ae81ff">8</span><span style="color:#960050;background-color:#1e0010">为地址的存储器中。</span></span></span></code></pre></div>
<h3 id="跳转指令">跳转指令</h3>
<h3 id="案例1">案例1</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>     CMP  R0<span style="color:#960050;background-color:#1e0010">，</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>                            
</span></span><span style="display:flex;"><span>     MOVEQ  R1<span style="color:#960050;background-color:#1e0010">，</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>    
</span></span><span style="display:flex;"><span>     MOVGT  R1<span style="color:#960050;background-color:#1e0010">，</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">1</span>  
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">解：</span>CMP  R0<span style="color:#960050;background-color:#1e0010">，</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>     ; <span style="color:#960050;background-color:#1e0010">将</span>R0的值减去0<span style="color:#960050;background-color:#1e0010">，并根据结果设置</span>CPSR的标志位                           
</span></span><span style="display:flex;"><span>        MOVEQ  R1<span style="color:#960050;background-color:#1e0010">，</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>   ; <span style="color:#960050;background-color:#1e0010">若</span>R0等于0<span style="color:#960050;background-color:#1e0010">，</span>Z<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">，则将立即数</span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">装入到</span>R1
</span></span><span style="display:flex;"><span>        MOVGT  R1<span style="color:#960050;background-color:#1e0010">，</span> <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">1</span>   ; <span style="color:#960050;background-color:#1e0010">若</span>R0大于0<span style="color:#960050;background-color:#1e0010">，</span>Z<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">，</span>N<span style="color:#f92672">=</span>V<span style="color:#960050;background-color:#1e0010">，则将立即数</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">装入到</span>R1</span></span></code></pre></div>
<p>程序实现的功能是判断R0的值与0的关系，将结果装入R1，若R0=0则R1=0，若R0&gt;0则R1=1.用C语言描述如下。
设R0对应变量a，R1对应变量b，</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                 b<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">else</span>  <span style="color:#a6e22e">if</span>(a<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                 b<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; 
</span></span></code></pre></div>
<h3 id="案例2">案例2</h3>
<p>对程序各条指令进行注释，最后分析整个程序的功能。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>	 AREA	Example1,CODE,READONLY	  ; <span style="color:#960050;background-color:#1e0010">声明代码段</span>Example1  
</span></span><span style="display:flex;"><span>	 ENTRY				     ; <span style="color:#960050;background-color:#1e0010">标识程序入口</span>
</span></span><span style="display:flex;"><span>	 CODE32				  ; <span style="color:#960050;background-color:#1e0010">声明</span><span style="color:#ae81ff">32</span><span style="color:#960050;background-color:#1e0010">位</span>ARM指令
</span></span><span style="display:flex;"><span>START 	                   ; <span style="color:#960050;background-color:#1e0010">标号</span><span style="color:#f92672">/</span><span style="color:#960050;background-color:#1e0010">标签</span>
</span></span><span style="display:flex;"><span>MOV  R0, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>			  ; <span style="color:#960050;background-color:#1e0010">设置参数，</span>R0<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	MOV  R1, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">10</span>           ; <span style="color:#960050;background-color:#1e0010">设置参数，</span>R1<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>LOOP                       ; <span style="color:#960050;background-color:#1e0010">标号</span><span style="color:#f92672">/</span><span style="color:#960050;background-color:#1e0010">标签</span>
</span></span><span style="display:flex;"><span>BL  ADD_SUB	         ; <span style="color:#960050;background-color:#1e0010">调用子程序</span>ADD_SUB
</span></span><span style="display:flex;"><span>	B	LOOP			     ; <span style="color:#960050;background-color:#1e0010">跳转到</span>LOOP
</span></span><span style="display:flex;"><span>ADD_SUB	                ; <span style="color:#960050;background-color:#1e0010">标号</span><span style="color:#f92672">/</span><span style="color:#960050;background-color:#1e0010">标签</span>
</span></span><span style="display:flex;"><span>	ADDS  R0, R0, R1		  ; R0 <span style="color:#f92672">=</span> R0 <span style="color:#f92672">+</span> R1<span style="color:#960050;background-color:#1e0010">，并根据结果设置</span>CPSR的标志位
</span></span><span style="display:flex;"><span>	MOV	  PC, LR	     	  ; <span style="color:#960050;background-color:#1e0010">子程序返回，</span>PC<span style="color:#f92672">=</span>LR
</span></span><span style="display:flex;"><span>	END				         ; <span style="color:#960050;background-color:#1e0010">声明文件结束</span></span></span></code></pre></div>
<p><strong>整个程序的功能</strong>：程序实现了一个死循环，每次循环R0都增加10。</p>
<h2 id="linux编程基础">LInux编程基础</h2>
<h3 id="gcc编译的4个过程的主要功能">GCC编译的4个过程的主要功能</h3>
<ul>
<li>预编译：主要功能是读取源文件，并对头文件预编译语句和一些特殊符号进行分析和处理；</li>
<li>编译：主要包括检查代码语法和将预编译后的文件转换成汇编语言；</li>
<li>汇编：主要的功能是将汇编语言的代码编程目标文件；（机器代码，0和1）</li>
<li>连接：主要功能是连接代码，生成可执行文件。</li>
</ul>
<h3 id="简述make工具和makefile的基本结构">简述Make工具和Makefile的基本结构</h3>
<p>Make又叫工程管理工具，即管理较多的工程文件。</p>
<p>主要的功能:</p>
<ul>
<li>通过Makefile文件来描述源程序之间相互依赖的关系，并自动完成维护编译工作；</li>
<li>能够根据文件的时间戳发现更新的文件，可以减少编译工作；</li>
</ul>
<p>基本结构：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>target <span style="color:#960050;background-color:#1e0010">：</span> dependency
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>tab <span style="color:#960050;background-color:#1e0010">键</span><span style="color:#f92672">&gt;</span> command</span></span></code></pre></div>
<p>target:目标；
dependency：依赖关系
command：命令</p>
<h3 id="makefile变量">Makefile变量</h3>
<ul>
<li>用户自定义变量</li>
<li>预定义变量</li>
<li>自动变量</li>
</ul>
<p>后两个是系统的变量，是Makefile文件常用的变量，其中有部分变量用户可以修改。</p>
<h3 id="预定义变量">预定义变量</h3>
<p>需要记住两个比较重要且常用的预定义变量，即</p>
<ul>
<li>CC：C编译器名称，默认cc</li>
<li>CFLAGS：C编译器的选项，无默认值</li>
</ul>
<h3 id="自动变量又叫系统变量">自动变量（又叫系统变量）</h3>
<ul>
<li>$@ :规则的目标所对应的文件；</li>
<li>$&lt;：规则中的第一个依赖文件；</li>
<li>$^:规则中所有依赖的列表，以空格为间隔符。</li>
</ul>
<h3 id="文件操作编程">文件操作编程</h3>
<p>C语言库中的fopen、fclose、fwrite、fread等函数。</p>
<p>其实是由操作系统的API函数封装而来，如</p>
<ul>
<li>fopen内部其实调用的是open函数，</li>
<li>fwrite内部调用的是write函数。</li>
</ul>
<p>用户也可以直接利用Linux系统的API函数来完成文件操作编程</p>
<h4 id="在linux操作系统下用c语言实现文件操作可以采用哪两种方法">在Linux操作系统下，用C语言实现文件操作可以采用哪两种方法？</h4>
<p>在LInux操作系统中，实现文件操作有两种方法，第一种是调用C语言标准库，第二种是通过Linux系统调用实现。前者独立于操作系统，在任何操作系统下使用C语言标准库函数操作文件，而后者以来于操作系统。</p>
<h3 id="时间编程">时间编程</h3>
<ul>
<li>time函数</li>
</ul>
<p>返回1970.1.1 0时到现在所经历的时间，操作失败返回((time_t)-1)</p>
<ul>
<li>gmtime函数
将日历转化为格林威治标准时间，结果存在结构体tm中。</li>
</ul>
<p>在课堂上老师叫我们使用的并非上面这个函数，而是用localtime(const time_t *timep)这个函数,这个函数可以将日历转为本地时间，具体用法请看<a href="/class/12.%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/#综合案例">综合案例</a></p>
<ul>
<li>gettimeofday函数</li>
</ul>
<p>获取从今日凌晨到现在的时差并存储在tv中，tz存放当地时区差；</p>
<h3 id="综合案例">综合案例</h3>
<p>（4）编写一个程序，将系统时间以“year-month-day hour:minute:second”格式保存在time.txt文件中。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX 40
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> fd,n,ret;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> writebuf[MAX];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> tm <span style="color:#f92672">*</span>t;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">time_t</span> lt;
</span></span><span style="display:flex;"><span>        lt<span style="color:#f92672">=</span><span style="color:#a6e22e">time</span>(NULL);
</span></span><span style="display:flex;"><span>        t<span style="color:#f92672">=</span><span style="color:#a6e22e">localtime</span>(<span style="color:#f92672">&amp;</span>lt);  <span style="color:#75715e">//将日历时间转化为本地时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">sprintf</span>(writebuf,<span style="color:#e6db74">&#34;%d-%d-%d %d:%d:%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,t<span style="color:#f92672">-&gt;</span>tm_year<span style="color:#f92672">+</span><span style="color:#ae81ff">1900</span>,t<span style="color:#f92672">-&gt;</span>tm_mon<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t<span style="color:#f92672">-&gt;</span>tm_mday,t<span style="color:#f92672">-&gt;</span>tm_hour,t<span style="color:#f92672">-&gt;</span>tm_min,t<span style="color:#f92672">-&gt;</span>tm_sec);   <span style="color:#75715e">//按指定格式保存时间        
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/*打开文件，如果文件不存在，则会创建文件*/</span>
</span></span><span style="display:flex;"><span>        fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;time.txt&#34;</span>, O_RDWR <span style="color:#f92672">|</span> O_CREAT);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*向文件写入字符串*/</span> 
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">write</span>(fd, writebuf, <span style="color:#a6e22e">strlen</span>(writebuf));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">perror</span>(<span style="color:#e6db74">&#34;Write Error!&#34;</span>); <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;write %d characters!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ret);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*关闭时，会自动保存文件*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="多线程编程">多线程编程</h3>
<h4 id="基本用法">基本用法</h4>
<p>使用到pthread_createh头文件，以及libpthread.so和libpthread.a库文件；</p>
<ul>
<li>pthread_create函数：创建线程</li>
<li>pthread_exit函数：退出线程</li>
<li>pthread_join函数：阻塞线程</li>
</ul>
<h3 id="互斥锁线程">互斥锁线程</h3>
<p>解决多个线程在一起执行的时候共享数据、资源的问题。在POSIX中有两种线程同步机制，分别为互斥锁和信号量</p>
<ul>
<li>pthread_mutex_init:初始化互斥锁</li>
<li>pthread_mutex_lock：互斥锁上锁</li>
<li>pthread_mutex_unlock：互斥锁释放</li>
</ul>
<h2 id="嵌入式开发交叉编译与系统移植">嵌入式开发交叉编译与系统移植</h2>
<h3 id="嵌入式软件调试方法">嵌入式软件调试方法</h3>
<ul>
<li>实时在线仿真</li>
<li>模拟调试</li>
<li>软件调试</li>
<li>片上调试</li>
</ul>
<h3 id="引导程序移植">引导程序移植</h3>
<p>操作系统运行前的一个程序，也就是启动程序。</p>
<ul>
<li>BoolLoader工作模式
<ul>
<li>启动加载模式</li>
<li>下载模式</li>
</ul>
</li>
<li>BoolLoader启动过程
<ul>
<li>第一阶段
<ul>
<li>主要依赖CPU的体系结构硬件初始化的代码，通常使用汇编语言编写。</li>
<li>这个阶段的功能主要有：
<ul>
<li>基本硬件设备初始化；</li>
<li>为第二阶段准备ARM空间；</li>
<li>复制BootLoader的第二阶段代码到RAM；</li>
<li>设置栈堆；</li>
<li>跳转到第二阶段的入口点；</li>
</ul>
</li>
</ul>
</li>
<li>第二阶段
<ul>
<li>通常使用C语言完成，以便实现更复杂的功能，使程序具有更好的可读性和可移植性。</li>
<li>这一阶段的主要任务是：
<ul>
<li>初始化这一阶段要使用的硬件设备;</li>
<li>检测系统内存映射；</li>
<li>将内核文件和根目录系统映像文件从Flash读到RAM；</li>
<li>为内核设置启动参数，</li>
<li>调用内核。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>常用的启动文件有很多，这里介绍Uboot。</p>
<p>Uboot是一个开源项目，最早是由德国登克斯（DENX）小组的开发，然后发布在网上，许多对这款软件感兴趣的开发人员共同来维护。</p>
<h4 id="bootloader的核心任务是什么">BootLoader的核心任务是什么？</h4>
<p>启动内核，向内核提供启动参数，完成系统软件的部署功能。</p>
<h4 id="系统加电后执行的第一段代码是什么">系统加电后执行的第一段代码是什么？</h4>
<p>BootLoader(引导程序)是系统上电后运行的第一段代码。</p>
<h4 id="u-boot命令和环境变量">U-Boot命令和环境变量</h4>
<p>U-Boot通常支持几十个常用命令，通过这些命令，可以对目标机进行调试，也可以引导Linux内核，还可以擦写Flash完成系统部署等功能。</p>
<ul>
<li>常用命令：
print: 通常用于打印信息或变量的值到控制台或终端。</li>
</ul>
<p>setenv: 设置环境变量。环境变量是在操作系统中存储的配置信息，可以影响程序的行为。</p>
<p>saveenv: 保存环境变量。这个命令通常用于将当前的环境变量设置保存到非易失性存储器，以便在系统重启后保持这些设置。</p>
<p>ping: 网络诊断工具，用于测试主机之间的网络连接是否可达。</p>
<p>tftp: Trivial File Transfer Protocol（简单文件传输协议）的缩写，用于在设备之间传输文件。</p>
<p>boot: 启动系统或加载执行程序。</p>
<ul>
<li>组合命令
<ul>
<li>movi read:用来读取iNand到DDR上</li>
<li>movi write:用来将DDR写到到iNand上</li>
</ul>
</li>
</ul>
<p><strong>注释</strong>：</p>
<ul>
<li>非易失性存储器 iNand</li>
<li>动态数据随机存取存储器 DDR</li>
</ul>
<h3 id="linux内核简介">linux内核简介</h3>
<p>Linux内核主要功能有：</p>
<ul>
<li>进程管理</li>
<li>内存管理</li>
<li>文件管理</li>
<li>设备管理</li>
<li>网络管理</li>
</ul>
<p>Linux内核源代码非常庞大，它使用目录树结构，内核源码的顶层有许多子目录,分别组织存放各种内核子系统或者文件,如下表：
<a href="#R-image-c7cfaf2619854edd469792e2f1611a82" class="lightbox-link"><img alt="1" class="lazy lightbox figure-image" loading="lazy" src="/class/12.%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c7cfaf2619854edd469792e2f1611a82"><img alt="1" class="lazy lightbox lightbox-image" loading="lazy" src="/class/12.%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image.png"></a></p>
<h3 id="linux内核移植">Linux内核移植</h3>
<p>Linux内核支持多种处理器，如果目标机使用的是ARM处理器核，使用的交叉编译工具链是arm-linux-，内核移植时要指定处理器的类型以及使用的交叉编译工具链，简述具体操作方法。</p>
<p>具体操作如下。
打开内核顶层目录下的Makefile文件，在文件中找到如下内容。
ARCH？=$(SUBARCH)
CROSS_COMPILE?=$(CONFIG_CROSS_COMPILE:“%”=%)
将找到的以上代码修改为如下内容。
ARCH？=arm
CROSS_COMPILE?=arm-none-linux-gnueabi-
其中，ARCH是CPU架构变量；CROSS_COMPILE是交叉编译工具链变量。修改完成后，保存文件退出。</p>
<h2 id="驱动程序">驱动程序</h2>
<h3 id="驱动程序的功能">驱动程序的功能</h3>
<ul>
<li>对设备初始化和释放</li>
<li>数据传输:把数据从内核传送到硬件和从硬件读取数据,读取应用程序传送给设备文件的数据和回送应用程序请求的数据.</li>
<li>检测和处理设备出现的错误</li>
</ul>
<h4 id="open入口点">Open入口点</h4>
<p>对象：字符设备文件；
特点：字符设备文件都需要经过open入口点调用
open子程序功能：为I/O口作必要的准备工作
同一时刻只能有一个程序访问此设备（即设备是独占的）,则 open子程序必须设置一些标志以表示设备处于忙碌状态。open子程序的调用格式如下。
int open(char  * filename,int acess)</p>
<h4 id="第一个功能中">第一个功能中</h4>
<p>打开设备是由调用定义在incliude/linux/fs.h中的file_operations结构体中的 open()函数完成的。open()函数主要完成的主要工作：</p>
<p>1.若是首次打开，先初始化
2.增加设备的使用计数
3.检测设备是否异常，及时发现设备相关错误
4.读取设备次设备号。</p>
<h3 id="驱动程序的主要组成部分">驱动程序的主要组成部分</h3>
<ul>
<li>自动配置和初始化子程序：检测驱动的硬件设备是否正常，能否正常工作</li>
<li>服务子程序和中断服务程序:这两者分别是驱动程序的上下两部分。
<ul>
<li>驱动上部分，即设备服务子程序，它是系统调用的结果，并且伴随着用户态向核心态的演变，在此过程中还可以调用与进程运行环境有关的函数，比如 sleep()函数。</li>
<li>驱动程序的下半部分，即中断服务子程序</li>
</ul>
</li>
</ul>
<h3 id="linux设备分类-用c表示设备">Linux设备分类 （用C表示设备）</h3>
<ul>
<li>字符设备</li>
<li>块设备</li>
<li>网络设备</li>
</ul>
<p>应用程序操作设备框图
<a href="#R-image-d12216a54d9cc53a9cf106279ef84b49" class="lightbox-link"><img alt="2" class="lazy lightbox figure-image" loading="lazy" src="/class/12.%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d12216a54d9cc53a9cf106279ef84b49"><img alt="2" class="lazy lightbox lightbox-image" loading="lazy" src="/class/12.%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/image-1.png"></a></p>
<h3 id="简述驱动程序和应用程序的区别">简述驱动程序和应用程序的区别</h3>
<p>第一，应用程序一般有一个main函数，并从头到尾执行一个任务；驱动程序没有main函数，它在加载时，通过调用module_init宏，完成驱动设备的初始化和注册工作之后便停止工作，并等待被应用程序调用。</p>
<p>第二，应用程序可以和GLIBC库连接，因此可以包含标准的头文件；驱动程序不能使用标准的C库，因此不能调用所有的C库函数，比如输出函数不能使用printf，只能用内核的printk，包含的头文件只能是内核的头文件，比如Linux/module.h。</p>
<p>第三，驱动程序运行在内核空间（又称内核态）比应用程序执行的优先级要高很多。应用程序则运行在最低级别的用户空间（又称用户态），在这一级别禁止对硬件的直接访问和对内存的未授权访问。</p>
<p>应用程序一般有一个main函数,并从头到尾执行一个任务；
应用程序可以和 GLIBC 库连接,因此可以包含标准的头文件；
驱动程序运行在内核空间(又称内核态),比应用程序执行的优先级要高很多。</p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
      <li><a href="/Class/12.%e5%b5%8c%e5%85%a5%e5%bc%8f%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1/index.files/%e5%b5%8c%e5%85%a5%e5%bc%8f%e5%a4%8d%e4%b9%a0PPT.pptx">嵌入式复习PPT.pptx</a> (659 KB)</li>
      <li><a href="/Class/12.%e5%b5%8c%e5%85%a5%e5%bc%8f%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1/index.files/%e5%b5%8c%e5%85%a5%e5%bc%8f%e4%bd%9c%e4%b8%9a.docx">嵌入式作业.docx</a> (52 KB)</li>
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年5月28日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/">核心课程</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/arkts%E8%AF%AD%E8%A8%80/">ArkTS语言</a></li>
    <li><a class="term-link" href="/tags/harmonyos/">HarmonyOS</a></li>
    <li><a class="term-link" href="/tags/openharmony/">OpenHarmony</a></li>
  </ul>
</div>
  </header>

<h1 id="arkts">ArkTS</h1>

<h2 id="数据类型">数据类型</h2>
<p><a href="#R-image-5fe257de90939ac8dbd6f54819471fd8" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5fe257de90939ac8dbd6f54819471fd8"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image.png"></a></p>
<p><a href="https://www.typescriptlang.org/play" rel="external" target="_blank">练习网址：</a></p>
<h2 id="条件语句">条件语句</h2>
<p><a href="#R-image-b75bc9b7499ee94a5ee93f34b0fae73c" class="lightbox-link"><img alt="alt text1" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b75bc9b7499ee94a5ee93f34b0fae73c"><img alt="alt text1" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-1.png"></a></p>
<p>拓展：for in与for of的使用</p>
<ul>
<li>for in ：遍历得到数组的角标，</li>
<li>for of ：直接得到元素。
<a href="#R-image-24dd5286c3563239d9f56a81b2d88ea0" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-24dd5286c3563239d9f56a81b2d88ea0"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-2.png"></a></li>
</ul>
<h2 id="函数">函数</h2>
<p>使用function关键字声明函数，</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-TS" data-lang="TS"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">outname</span>(<span style="color:#a6e22e">name</span>:<span style="color:#66d9ef">string</span>)<span style="color:#f92672">:</span><span style="color:#66d9ef">void</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;你好&#39;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">name</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//第二种写法：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">outname</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">name</span>:<span style="color:#66d9ef">string</span>)<span style="color:#f92672">=&gt;</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;你好&#39;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">name</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">outname</span>(<span style="color:#e6db74">&#39;lucy&#39;</span>)</span></span></code></pre></div>
<p>ts还提供了一种可传参数和不传参数也执行的函数的操作，写法如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-TS" data-lang="TS"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">outname</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">name</span>:<span style="color:#66d9ef">string</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#39;张三&#39;</span>)<span style="color:#f92672">=&gt;</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;你好&#39;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">name</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">outname</span>()</span></span></code></pre></div>
<h2 id="面向对象">面向对象</h2>
<h2 id="模块的导入导出">模块的导入导出</h2>
<p>提高代码的重复使用
<a href="#R-image-6425c92db04a82a197761399fc90c453" class="lightbox-link"><img alt="alt text3" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6425c92db04a82a197761399fc90c453"><img alt="alt text3" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-3.png"></a></p>
<h2 id="组件的使用">组件的使用</h2>
<h3 id="image组件">image组件</h3>
<h3 id="textinput组件">textinput组件</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ts" data-lang="ts"><span style="display:flex;"><span><span style="color:#a6e22e">TextInput</span>({<span style="color:#a6e22e">text</span>:<span style="color:#66d9ef">this.imagewidth.toFixed</span>(<span style="color:#ae81ff">0</span>)})
</span></span><span style="display:flex;"><span>          .<span style="color:#a6e22e">width</span>(<span style="color:#ae81ff">150</span>)
</span></span><span style="display:flex;"><span>          .<span style="color:#a6e22e">backgroundColor</span>(<span style="color:#e6db74">&#39;#36D00A&#39;</span>)
</span></span><span style="display:flex;"><span>          .<span style="color:#66d9ef">type</span>(<span style="color:#a6e22e">InputType</span>.Number)
</span></span><span style="display:flex;"><span>          .<span style="color:#a6e22e">onChange</span>( <span style="color:#a6e22e">values</span> <span style="color:#f92672">=&gt;</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">imagewidth</span> <span style="color:#f92672">=</span> parseInt(<span style="color:#a6e22e">values</span>)
</span></span><span style="display:flex;"><span>          })
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">TextInput</span>({<span style="color:#a6e22e">placeholder</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#39;nihao&#39;</span>})
</span></span><span style="display:flex;"><span>          .<span style="color:#a6e22e">width</span>(<span style="color:#ae81ff">150</span>)
</span></span><span style="display:flex;"><span>          .<span style="color:#a6e22e">backgroundColor</span>(<span style="color:#e6db74">&#39;#4399&#39;</span>)</span></span></code></pre></div>
<p>效果如下图：
<a href="#R-image-7925589f7fb2d51695c125d25826d496" class="lightbox-link"><img alt="效果1" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7925589f7fb2d51695c125d25826d496"><img alt="效果1" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-4.png"></a>
<a href="#R-image-d17eba05c4d4cc76660e14fe242fa093" class="lightbox-link"><img alt="效果2" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d17eba05c4d4cc76660e14fe242fa093"><img alt="效果2" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-5.png"></a></p>
<p>文本框内输入的值是什么类型的数据呢？</p>
<p>从上面的代码可知是字符型的，此处我们用<code>parseInt</code>将一个变量转换成number类型，又用方法<code>.toFixed()</code>将一个number类型的变量转换成字符串型。</p>
<h3 id="按键组件">按键组件</h3>
<p><a href="#R-image-dab9e3a9976b26e4a0ee983ed2c8f15b" class="lightbox-link"><img alt="按键组件" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dab9e3a9976b26e4a0ee983ed2c8f15b"><img alt="按键组件" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-6.png"></a></p>
<h3 id="滑动条组件slider">滑动条组件（slider）</h3>
<p><a href="#R-image-46bd3d0c9ea9cb6edeeedb097669bd04" class="lightbox-link"><img alt="Slider" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-46bd3d0c9ea9cb6edeeedb097669bd04"><img alt="Slider" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-7.png"></a></p>
<h2 id="页面布局">页面布局</h2>
<h3 id="线性布局">线性布局</h3>
<p><a href="#R-image-ad0e03c025d47fd4dfd2202c5743c678" class="lightbox-link"><img alt="垂直布局" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ad0e03c025d47fd4dfd2202c5743c678"><img alt="垂直布局" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-8.png"></a></p>
<p>Row布局与Column布局类似，只是主轴方向不同
<a href="#R-image-bf1d09685568d3c9911fd7e16dcbd05f" class="lightbox-link"><img alt="水平分布" class="lazy lightbox figure-image" loading="lazy" src="/class/1.arkts/image-9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf1d09685568d3c9911fd7e16dcbd05f"><img alt="水平分布" class="lazy lightbox lightbox-image" loading="lazy" src="/class/1.arkts/image-9.png"></a></p>
<h3 id="循环控制foreach">循环控制ForEach</h3>
<h2 id="使用router进行页面跳转时用replaceurl与pushurl的区别">使用router进行页面跳转时用replaceUrl与pushUrl的区别</h2>
<p>后者会保留前一页信息，就是跳转后会返回上一页面，而后面的不会跳回上一页</p>
<p>11&ndash;t</p>
<p>f&ndash;!=11,运行时</p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年2月23日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/">电子电路</a></li>
  </ul>
</div>
  </header>

<h1 id="电子电路">电子电路</h1>

<p>模拟电子技术知识。
<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">模拟电子技术基础笔记</a><p><h2 id="常用半导体器件">常用半导体器件</h2>
<h3 id="本征半导体">本征半导体</h3>
<ol>
<li>
<p>半导体：介于导体与绝缘体之间的</p>
</li>
<li>
<p>本征半导体：
<a href="#R-image-ce4752cd61b3916641b98d4ba97dacb7" class="lightbox-link"><img alt="图" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ce4752cd61b3916641b98d4ba97dacb7"><img alt="图" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image.png"></a></p>
</li>
<li>
<p>载流子
3.1 本征激发
<a href="#R-image-30516f7a367f1c02e6324e84cdbc155e" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-30516f7a367f1c02e6324e84cdbc155e"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-1.png"></a>
3.2 自由电子，带负电
3.3 空穴，带正电
自由电子和空穴都能到点。
3.4 复合：与本真激发相反的过程</p></p></li>
</ul></p>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年2月18日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/">核心课程</a></li>
  </ul>
</div>
  </footer>
</article>
          <section>
            <h1 class="a11y-only">电子电路 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E6%A8%A1%E7%94%B5/">模电</a></li>
  </ul>
</div>
  </header>

<h1 id="模拟电子技术基础笔记">模拟电子技术基础笔记</h1>

<h2 id="常用半导体器件">常用半导体器件</h2>
<h3 id="本征半导体">本征半导体</h3>
<ol>
<li>
<p>半导体：介于导体与绝缘体之间的</p>
</li>
<li>
<p>本征半导体：
<a href="#R-image-ce4752cd61b3916641b98d4ba97dacb7" class="lightbox-link"><img alt="图" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ce4752cd61b3916641b98d4ba97dacb7"><img alt="图" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image.png"></a></p>
</li>
<li>
<p>载流子
3.1 本征激发
<a href="#R-image-30516f7a367f1c02e6324e84cdbc155e" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-30516f7a367f1c02e6324e84cdbc155e"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-1.png"></a>
3.2 自由电子，带负电
3.3 空穴，带正电
自由电子和空穴都能到点。
3.4 复合：与本真激发相反的过程</p>
</li>
<li>
<p>本征半导体的导电能力与载流子的浓度有关：此时处于动态平衡，本证激发与复合的速度一样。</p>
<p>从工程的角度看，只加热温度让导电能力增加不实际，还好它具有掺杂别的东西让导电能力增加。</p>
</li>
</ol>
<h3 id="杂质半导体">杂质半导体</h3>
<h4 id="概念">概念</h4>
<p>掺杂<strong>少量</strong> 的杂志元素。</p>
<h4 id="n型半导体">N型半导体</h4>
<p>掺杂P元素（5价元素），本征半导体的导电能力增加，自由电子是多子，空穴是少子；</p>
<p>温度对多子影响小，因为多子本身就多，但对少子浓度的影响大，因为少子的量少；</p>
<p><a href="#R-image-7661a9a684fe003a64e92849d6caff4b" class="lightbox-link"><img alt="N型半导体" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7661a9a684fe003a64e92849d6caff4b"><img alt="N型半导体" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-2.png"></a></p>
<h4 id="p型半导体">P型半导体</h4>
<p>掺杂硼元素（3价元素），本征半导体的导电能力增加，自由电子是少子，空穴是多子；</p>
<h3 id="pn结半导体">PN结半导体</h3>
<p><a href="#R-image-46868b6d3ed96ea2d1b986ef1e5059c3" class="lightbox-link"><img alt="PN结半导体" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-46868b6d3ed96ea2d1b986ef1e5059c3"><img alt="PN结半导体" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-3.png"></a></p>
<p>1.扩散运动：在浓度梯度的作用下，浓度高的地方向浓度低的地方扩散；</p>
<p>2.空间电荷区（耗尽层、PN结），这里举个例子，就右边空间电荷区的正电荷而言，从电场线出发，两边平衡我们可以理为正电荷发出的电场阻止了左边的空穴移动，而对于负电荷他也有这样的特性，所以两边达到平衡的状态。</p>
<p>虽然中间有空间电荷区形成势垒（由电压形成）组织了两遍的多子运动，但是这样的势垒能百分之百阻止多子向两边运动吗？</p>
<p>答案是不完全，还是有一小部分的多子冲破避雷向两边运动。下面是一张简单的图。</p>
<p>3.漂移运动：两边少子的运动称之为漂移运动</p>
<p>4.对称结与不对称结：由上面的图可以看出两边宽度一样，原因是掺杂的浓度一样，如果不一样？那么两边就不对称了，这时候称之为不对称结。</p>
<h4 id="加外电压的pn结半导体">加外电压的PN结半导体</h4>
<p>加正电压（P流向N，空间电荷区被削弱）
<a href="#R-image-007b9f322e9d6911b573dde426ba8f69" class="lightbox-link"><img alt="PN结加外电压" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-007b9f322e9d6911b573dde426ba8f69"><img alt="PN结加外电压" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-4.png"></a></p>
<p>加反向电压（，空间电荷区增加）
<a href="#R-image-0866d4eef2a1aac9a84f543e7213ebe3" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0866d4eef2a1aac9a84f543e7213ebe3"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-5.png"></a></p>
<p>这个时候的漂移运动是增加的，但漂移运动是由少子形成的所以他的影响是很小的，值得注意的是漂移运动对 <strong>温度</strong> 是很敏感的。</p>
<h3 id="pn结的电流方程">PN结的电流方程</h3>
<p><a href="#R-image-3b786a902c0a3fc8bf4087ac54fc2237" class="lightbox-link"><img alt="伏安特性" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3b786a902c0a3fc8bf4087ac54fc2237"><img alt="伏安特性" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-6.png"></a></p>
<p><a href="#R-image-8f9bc890063ab25ad08b1070c69a4213" class="lightbox-link"><img alt="方程" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8f9bc890063ab25ad08b1070c69a4213"><img alt="方程" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-7.png"></a>
<span class="math align-center">$i=I_s(e^{U/U{_T}}-1),其中V_T=26V$</span></p>
<p>锗：0.2-0.3V
硅：0.6-0.7V</p>
<h4 id="特性">特性</h4>
<ol>
<li>正向特性</li>
<li>反向特性
2.1雪崩击穿（掺杂浓度低，温度越高，击穿电压越高，因为粒子需要加速）
2.2齐纳击穿（掺杂浓度高，温度越高，击穿电压越低，因为）</li>
</ol>
<h4 id="pn结的电容效应">PN结的电容效应</h4>
<p>当正负极两边的电压变化时，中间的电量发生改变；</p>
<p>1.势垒电容
<a href="#R-image-bf56b81297f42f1876e179c8636e8303" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bf56b81297f42f1876e179c8636e8303"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-9.png"></a></p>
<p>2.扩散电容：非平衡少子形成
<a href="#R-image-24c4526b9813bacca3800d607ad03f19" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-24c4526b9813bacca3800d607ad03f19"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-8.png"></a></p>
<p>电压增高为2线，浓度增高，电压减小为3，浓度降低；</p>
<h3 id="半导体二极管">半导体二极管</h3>
<p><a href="#R-image-dd3bc489c78d8151069db23616575cf3" class="lightbox-link"><img alt="二极管" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dd3bc489c78d8151069db23616575cf3"><img alt="二极管" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-10.png"></a></p>
<h4 id="常见结构">常见结构</h4>
<p><a href="#R-image-3c5f8efddcc8afce879260f6ecd68e61" class="lightbox-link"><img alt="结构" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-11.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3c5f8efddcc8afce879260f6ecd68e61"><img alt="结构" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-11.png"></a></p>
<h4 id="伏安特性">伏安特性</h4>
<p><a href="#R-image-a9afc54470deb487d745ba89d3d57152" class="lightbox-link"><img alt="二极管伏安特性" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-12.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a9afc54470deb487d745ba89d3d57152"><img alt="二极管伏安特性" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-12.png"></a></p>
<ul>
<li>体电阻的存在，电流的PN结小；</li>
<li>反向电流大一些；</li>
</ul>
<h4 id="温度的影响">温度的影响</h4>
<p>正向电流：温度升高，本证激发，粒子热运动增加，所以电压固定的时候，温度高的电流可定大，所以曲线往上走；</p>
<p>反向电流：温度升高，对少子影响大，饱和电流增加，所以曲线往下走；</p>
<h3 id="二极管作用">二极管作用</h3>
<ul>
<li>单向导电性，规定电流流向，做整流器件；也可以稳压，但一般用反向的稳压</li>
<li>反向的饱和电流，简单的温度传感器；</li>
<li>反向截止电流，稳压二极管；</li>
</ul>
<p><strong>问：为什么稳压电路不用正向的电压稳压</strong>？</p>
<h3 id="二极管的主要参数">二极管的主要参数</h3>
<ul>
<li>IF：工作的时候电流的最大流过电流，</li>
<li>UR：最高反向电压，</li>
<li>IR：反向电流（未击穿时），</li>
<li>FM：最高频率（选高频电路的时候需要参考），</li>
</ul>
<h3 id="二极管的等效电路">二极管的等效电路</h3>
<p><a href="#R-image-69ce80e81733fe15099cc6effdc38788" class="lightbox-link"><img alt="伏安特性等效化" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-13.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-69ce80e81733fe15099cc6effdc38788"><img alt="伏安特性等效化" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-13.png"></a>
1.上图a为理想的等效电路</p>
<p>2.b图为常用的等效模型</p>
<p>上面三张图的<a href="#R-image-e1d831abf6760828396f0d07b0f025cf" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-15.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e1d831abf6760828396f0d07b0f025cf"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-15.png"></a>中间没有一杠，这是与普通二极管的区别。</p>
<p>下面我们看二级管的几个应用：</p>
<ol>
<li><strong>整流</strong>电路
<a href="#R-image-baa760b862fd24beb56d974593494fa1" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-16.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-baa760b862fd24beb56d974593494fa1"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-16.png"></a></li>
</ol>
<p>在上面的这个电路中我们假设交流电10mV，要想在<span class="math align-center">$u_R$</span>中测量出变化的电流那么需要加一个直流电压，将交流电抬高，曲线图如下：</p>
<p><a href="#R-image-629d14a89df9f8665f2af0449f0f566a" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-18.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-629d14a89df9f8665f2af0449f0f566a"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-18.png"></a></p>
<p>上图B点的电压10mV升到A点，它们的关系是：<span class="math align-center">$U_A=U_B+V$</span>,那么此时就可以测量出<span class="math align-center">$u_R$</span>两端的变化的电流了。具体电路图如下：</p>
<p><a href="#R-image-39a06e723b15228b58d809a7171210ac" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-14.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-39a06e723b15228b58d809a7171210ac"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-14.png"></a></p>
<p>最后得到的波形图是去掉Y轴的负半轴的正弦三角函数图像，也就是整流电路。</p>
<ol start="2">
<li><strong>限幅</strong>电路</li>
</ol>
<p><a href="#R-image-8cf5b4f61052615405939cbfc5ed47bd" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-19.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8cf5b4f61052615405939cbfc5ed47bd"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-19.png"></a></p>
<p>在分析这个电路时，要先判断正向导通和反向截止。</p>
<ul>
<li>当<span class="math align-center">$U_S-U_1<=Uon$</span>的时候截止</li>
<li>当<span class="math align-center">$U_S-U_1>=Uon$</span>的时候导通</li>
</ul>
<p>这时候的三角函数上半边会被割掉如下图：</p>
<p><a href="#R-image-b4ac5ded5b77fb77f5a93d468d5b2e9b" class="lightbox-link"><img alt="结果" class="lazy lightbox figure-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-20.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b4ac5ded5b77fb77f5a93d468d5b2e9b"><img alt="结果" class="lazy lightbox lightbox-image" loading="lazy" src="/class/14.%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/image-20.png"></a></p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年2月18日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/b1-%E6%8B%93%E5%B1%95%E7%AC%94%E8%AE%B0/">B1-拓展笔记</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li>
  </ul>
</div>
  </header>

<h1 id="操作系统">操作系统</h1>

<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">Linux期末复习</a><p><h2 id="认识linux">认识Linux</h2>
<h3 id="安装linux">安装Linux</h3>
<h3 id="图形界面与命令行">图形界面与命令行</h3>
<h2 id="文件管理与常用命令">文件管理与常用命令</h2>
<h3 id="文件目录的打包和压缩">文件/目录的打包和压缩</h3>
<h4 id="gzip压缩文件和gunzipzcat压缩文件命令">gzip压缩文件和gunzip、zcat压缩文件命令</h4>
<p>一般压缩解压文件：
<div class="tab-panel" data-tab-group="c9e6f2baef74e34184c5d92ef668f22a">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('c9e6f2baef74e34184c5d92ef668f22a','命令fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 命令</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux"> gzip [文件名]
 gunzip [解压文件名]</code></pre></div>
      </div>
    </div>
  </div>
</div>
例子：</p></p></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年1月14日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/">核心课程</a></li>
  </ul>
</div>
  </footer>
</article>
          <section>
            <h1 class="a11y-only">操作系统 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E8%BD%AF%E7%A1%AC%E4%BB%B6/">软硬件</a></li>
  </ul>
</div>
  </header>

<h1 id="linux期末复习">Linux期末复习</h1>

<h2 id="认识linux">认识Linux</h2>
<h3 id="安装linux">安装Linux</h3>
<h3 id="图形界面与命令行">图形界面与命令行</h3>
<h2 id="文件管理与常用命令">文件管理与常用命令</h2>
<h3 id="文件目录的打包和压缩">文件/目录的打包和压缩</h3>
<h4 id="gzip压缩文件和gunzipzcat压缩文件命令">gzip压缩文件和gunzip、zcat压缩文件命令</h4>
<p>一般压缩解压文件：
<div class="tab-panel" data-tab-group="c9e6f2baef74e34184c5d92ef668f22a">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('c9e6f2baef74e34184c5d92ef668f22a','命令fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 命令</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux"> gzip [文件名]
 gunzip [解压文件名]</code></pre></div>
      </div>
    </div>
  </div>
</div>
例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    [root@localhost stdio]# ls
    1.c  2.c  3.c  hello.txt
    [root@localhost stdio]# gzip hello.txt
    [root@localhost stdio]# ls
    1.c  2.c  3.c  hello.txt.gz
    [root@localhost stdio]# gunzip hello.txt.gz 
    [root@localhost stdio]# ls
    1.c  2.c  3.c  hello.txt
    [root@localhost stdio]# </code></pre></div>
<p>如果不想删除源文件要怎么做呢？使用如下命令：
<div class="tab-panel" data-tab-group="e6f586ed89ae0f586519c25fcc568e53">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: red ;" tabindex="-1"
      onclick="switchTab('e6f586ed89ae0f586519c25fcc568e53','命令fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 命令</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: red ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux"> gzip -c [文件名] &gt; [压缩文件名.gz]
 zcat [解压文件名.gz] &gt;[压缩文件名.gz]</code></pre></div>
      </div>
    </div>
  </div>
</div>
例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    [root@localhost stdio]# ls
    1.c  2.c  3.c  hello.txt
    [root@localhost stdio]# gzip -c hello.txt &gt;hello.txt.gz
    [root@localhost stdio]# ls
    1.c  2.c  3.c  hello.txt  hello.txt.gz
    [root@localhost stdio]# zcat  hello.txt.gz &gt;he.txt
    [root@localhost stdio]# ls
    1.c  2.c  3.c  hello.txt  hello.txt.gz  he.txt
[root@localhost stdio]# </code></pre></div>
<p>在上面的命令中，<strong>zcat [解压文件名.gz] &gt;[压缩文件名.gz]</strong> 与 <strong>gunzip -c [解压文件名.gz] &gt;[压缩文件名.gz]</strong> 作用一样，另外，zcat [文件名]会将文件压缩信息输出在窗口上，即输出在 <strong>std</strong>。</p>
<h4 id="bzip2压缩文件和bunzip2压缩文件命令">bzip2压缩文件和bunzip2压缩文件命令</h4>
<p>一般压缩解压文件：
<div class="tab-panel" data-tab-group="c55a6c7d30c507ad2df414cfaecfee04">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('c55a6c7d30c507ad2df414cfaecfee04','命令fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 命令</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    bzip2 [文件名]
    bunzip2 [解压文件名]
    //压缩解压后不会删除原文件
    bzip2 -k [文件名]
    bunzip2 -k [解压文件名]</code></pre></div>
      </div>
    </div>
  </div>
</div></p>
<p>例子：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">[root@localhost stdio]# ls
1.c  2.c  3.c  hello.txt
[root@localhost stdio]# bzip2 hello.txt 
[root@localhost stdio]# ls
1.c  2.c  3.c  hello.txt.bz2
[root@localhost stdio]# bunzip2 hello.txt.bz2 
[root@localhost stdio]# ls
1.c  2.c  3.c  hello.txt

[root@localhost stdio]# bzip2 -k  hello.txt 
[root@localhost stdio]# ls
1.c  2.c  3.c  hello.txt  hello.txt.bz2
[root@localhost stdio]# rm hello.txt
rm：是否删除普通文件 &#34;hello.txt&#34;？y
[root@localhost stdio]# ls
1.c  2.c  3.c  hello.txt.bz2
[root@localhost stdio]# bunzip2 -k hello.txt.bz2
[root@localhost stdio]# ls
1.c  2.c  3.c  hello.txt  hello.txt.bz2
[root@localhost stdio]# </code></pre></div>
<h4 id="tar归档文件命令">tar归档文件命令</h4>
<div class="tab-panel" data-tab-group="0b03f16a8c3783588a288222615cb097">
  <div class="tab-nav">
    <div class="tab-nav-title">&#8203;</div>
    <button
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('0b03f16a8c3783588a288222615cb097','命令fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 命令</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="命令fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<p>在Linux系统中，tar 是一个非常重要的归档工具，用于将一组文件和目录打包到一个单一的.tar文件中。它创建的这种归档文件并不进行压缩，仅仅是将多个文件集合在一起，并保持原始文件的权限、所有权和其他元数据信息。</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    tar -cvf [文件名]
    tar -xvf [解压文件名]</code></pre></div>
<p>然而，为了减少存储空间占用以及在网络上传输时加快速度，通常会结合使用 tar 和压缩工具（如gzip或bzip2）对归档文件进行压缩。这里 -z 或 -j 参数的作用就是启用压缩功能</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    tar -czvf [文件名]
    tar -xzvf [解压文件名]

    tar -cjvf [文件名]
    tar -xjvf [解压文件名]</code></pre></div>
<p>如果要选择性的归档或压缩、解压某个文件或目录，那么需要加 <strong>w</strong>，如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-l" data-lang="l">    tar -cwzvf [文件名]
    tar -xwzvf [解压文件名]

    tar -cwjvf [文件名]
    tar -xwjvf [解压文件名]</code></pre></div>
      </div>
    </div>
  </div>
</div>
<p>在命令中;</p>
<ul>
<li>c（create）：表示创建新备份</li>
<li>z（gzip或gunzip）:表示使用gzip指令处理文件</li>
<li>v（verbose）：显示指令执行过程</li>
<li>f（file）:指定备份文件</li>
<li>w(interactive):对每一步都进行确认</li>
<li>j:表示使用bzip2、bunzip2指令进行压缩解压</li>
</ul>
<p>如果加选项 <strong>-C</strong> （directory），则说明转到指定的目录，命令如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    [root@localhost ~]# tar -cjvf stdio.tar stdio/
    stdio/
    stdio/1.c
    [root@localhost ~]# tar -xjvf stdio.tar -C  st/
    stdio/
    stdio/1.c
    [root@localhost ~]# cd st/
    [root@localhost st]# ls
    stdio
    [root@localhost st]# ls stdio/
    1.c
    [root@localhost st]# </code></pre></div>
<h2 id="用户与用户组管理">用户与用户组管理</h2>
<h3 id="用户与组文件">用户与组文件</h3>
<h4 id="用户文件-passwd">用户文件-passwd</h4>
<p>存放用户登录用户信息的文件位置：/etc/passwd
文件中域的的格式：</p>
<hr>
<p>username:passwd:uid:gid:userinfo:home:shell:</p>
<hr>
<p>例子：</p>
<hr>
<p>[root@localhost st]# tail -1 /etc/passwd
daliu:x:1008:1006::/home/daliu:/bin/bash</p>
<hr>
<p><strong>/etc/passwdw</strong> 文件中域的含义</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">域</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">username</td>
          <td style="text-align: center">用户名</td>
      </tr>
      <tr>
          <td style="text-align: center">password</td>
          <td style="text-align: center">登录密码（一般显示的是密码转换后的乱码）</td>
      </tr>
      <tr>
          <td style="text-align: center">uid</td>
          <td style="text-align: center">用户ID（0-99一般为系统保留）</td>
      </tr>
      <tr>
          <td style="text-align: center">gid</td>
          <td style="text-align: center">用户组ID</td>
      </tr>
      <tr>
          <td style="text-align: center">userinfo</td>
          <td style="text-align: center">用户信息</td>
      </tr>
      <tr>
          <td style="text-align: center">home</td>
          <td style="text-align: center">分配该用户的主目录（但位置是人为决定的，自己可以修改）</td>
      </tr>
      <tr>
          <td style="text-align: center">shell</td>
          <td style="text-align: center">登录后启动的shell</td>
      </tr>
  </tbody>
</table>
<p>一般root用户的UID为0，UID一般是唯一的为的是区分不同的用户，但UID为0的除外，UID为0则说明为超级用户；</p>
<p>创建用户时，系统会分配一个主目录给用户一般在 <strong>home</strong> 目录下，例如用户user主目录为 <strong>/home/user</strong>。</p>
<h4 id="用户文件-shadow">用户文件-shadow</h4>
<p>Linux系统中的<code>/etc/shadow</code>文件是存放用户密码信息的重要安全文件，也称为“影子口令文件”。它的主要作用是存储用户的加密密码以及与密码相关的属性，以增强系统的安全性。</p>
<p>在早期的Unix/Linux系统中，密码是以明文或简单加密的形式存储在<code>/etc/passwd</code>文件中。为了提高系统的安全性，从1970年代末期开始引入了影子口令的概念，将密码字段从<code>/etc/passwd</code>移出，并存放在只有超级用户（root）可以读取的<code>/etc/shadow</code>文件中，而原来的 <strong>/etc/passwd</strong> 中的密码字段显示 <strong>x</strong> ,这就是上面的例子中显示x的原因。</p>
<p>通过这种方式，即使攻击者获取了<code>/etc/shadow</code>文件，由于密码已经被高度加密，直接破解难度大大增加，从而有效提高了系统的密码安全级别。同时，通过对密码策略的设定，还可以实现对用户密码复杂度和有效期的管理。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">域</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">username</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">password</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">min</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">max</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">warm</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">inactive</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">expire</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">flag</td>
          <td style="text-align: center"></td>
      </tr>
  </tbody>
</table>
<p>下面就举个例子：</p>
<hr>
<p>[root@localhost st]# tail -1 /etc/passwd
daliu:x:1008:1006::/home/daliu:/bin/bash</p>
<p>[root@localhost st]# tail -1 /etc/shadow
daliu:$6$f703Izgm$gIA74I6Vyqdjstz3BazhvEUVWfSyelNuv7UKTUtB3cScauSctebqrBIr/KShHnBcWWQideao3aucMrXsO.I6Z/:19694:0:99999:7:::</p>
<hr>
<h4 id="用户组文件-group">用户组文件-group</h4>
<p>用户组一方面是为了查找用户时更方便，比如查找user用户，你不需要去passwd文件一行一行的查找，你只需要去group文件找到对应的用户组即可。</p>
<p>同样的，用户组也有类似passwd、shadow之和这样的文件，分别为group、gshadow.</p>
<p><strong>/etc/group</strong> 文件中域的含义如下：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">域</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">group_name</td>
          <td style="text-align: center">组用户名</td>
      </tr>
      <tr>
          <td style="text-align: center">group_password</td>
          <td style="text-align: center">加密后的用户组口令</td>
      </tr>
      <tr>
          <td style="text-align: center">group_id</td>
          <td style="text-align: center">用户组ID</td>
      </tr>
      <tr>
          <td style="text-align: center">group_members</td>
          <td style="text-align: center">以逗号隔开的用户清单</td>
      </tr>
  </tbody>
</table>
<p><strong>/etc/gshadow</strong> 文件中域的含义如下：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">域</th>
          <th style="text-align: center">含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">group_name</td>
          <td style="text-align: center">组用户名</td>
      </tr>
      <tr>
          <td style="text-align: center">group_password</td>
          <td style="text-align: center">加密后的用户组口令</td>
      </tr>
      <tr>
          <td style="text-align: center">group_members</td>
          <td style="text-align: center">以逗号隔开的用户清单</td>
      </tr>
  </tbody>
</table>
<h4 id="检验用户与用户组文件之间是否正确">检验用户与用户组文件之间是否正确</h4>
<ul>
<li>检验 <strong>/etc/passwd</strong> 与 <strong>/etc/shadow</strong> 文件之间的正确性，使用命令 <strong>pwck</strong>,当发生错误，两个文件之间信息不对应时，系统会提示对相应项进行修改；</li>
<li>检验 <strong>/etc/group</strong> 与 <strong>/etc/gshadow</strong> 文件之间的正确性，使用命令 <strong>grpck</strong>,当发生错误，两个文件之间信息不对应时，系统会提示对相应项进行修改。</li>
</ul>
<h3 id="相关的命令操作">相关的命令操作</h3>
<p>1.添加用户与用户组———— <strong>useradd</strong> &amp; <strong>groupadd</strong></p>
<p>用法：</p>
<ul>
<li>useradd [选项] 登录</li>
<li>useradd -D</li>
<li>useradd -D [选项]</li>
</ul>
<p>值得注意的是，对于选项的-d、-md，加了m表示在/home目录创建用户目录，如果不加，表示该目录已存在不需要再使用m,详细请结合下面的展开内容来开。

<details class=" box cstyle notices transparent expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    展开
  </summary>
  <div class="box-content">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">选项：
  -b, --base-dir BASE_DIR	新账户的主目录的基目录
  -c, --comment COMMENT         新账户的 GECOS 字段
  -d, --home-dir HOME_DIR       新账户的主目录
  -D, --defaults		显示或更改默认的 useradd 配置
 -e, --expiredate EXPIRE_DATE  新账户的过期日期
  -f, --inactive INACTIVE       新账户的密码不活动期
  -g, --gid GROUP		新账户主组的名称或 ID
  -G, --groups GROUPS	新账户的附加组列表
  -h, --help                    显示此帮助信息并推出
  -k, --skel SKEL_DIR	使用此目录作为骨架目录
  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
  -l, --no-log-init	不要将此用户添加到最近登录和登录失败数据库
  -m, --create-home	创建用户的主目录
  -M, --no-create-home		不创建用户的主目录
  -N, --no-user-group	不创建同名的组
  -o, --non-unique		允许使用重复的 UID 创建用户
  -p, --password PASSWORD		加密后的新账户密码
  -r, --system                  创建一个系统账户
  -R, --root CHROOT_DIR         chroot 到的目录
  -s, --shell SHELL		新账户的登录 shell
  -u, --uid UID			新账户的用户 ID
  -U, --user-group		创建与用户同名的组
  -Z, --selinux-user SEUSER		为 SELinux 用户映射使用指定 SEUSER
  </code></pre></div>
  </div>
</details></p>
<p>用法： <strong>groupadd [选项] [组名]</strong> ，一般会用到的选项有</p>
<ul>
<li>-g: 用户设置组ID；</li>
<li>-o: 与-g配合使用，设置不唯一的组ID;</li>
<li>-n: 修改组的名字，如：gpasswd -n [新组名] [旧组名]</li>
</ul>
<p>2.删除用户与用户组———— <strong>userdel</strong> &amp; <strong>groupdel</strong></p>
<ul>
<li>userdel:一般用法就是在后面加要删除的用户，如果加选项-r则会删除主目录文件；</li>
<li>groupdel：在后面加要删除的用户组</li>
</ul>
<p>3.修改用户与用户组———— <strong>usermod</strong> 、<strong>passwd</strong> &amp; <strong>gpasswd</strong></p>
<ul>
<li>usermod： 一般就是对问文件中的域进行修改，会加加上选项-u、-g、-s等，最后还得指定用户，用法： <strong>usermod [选项] [用户名]</strong>。另外，<strong>-L（-U）</strong> 的作用是对用户的锁定（解锁）；</li>
<li>passwd：一般就是用来修改用户的密码，在登录的是root用户情况下passwd是要指定修改密码的用户的，而如果登录的是用户本身，使用passwd时就不用指定在；</li>
<li>gpasswd： 用法： <strong>gpasswd [选项] [组名]</strong> ，一般会用到的选项有
<ul>
<li>-a(添加组的用户)，</li>
<li>-d(删除组里的用户)，gpasswd -d [用户名] [组名]</li>
<li>-A(添加组的管理员).</li>
<li>-g(修改组GID),例如：gpasswd -g [新ID] [组名]</li>
</ul>
</li>
</ul>
<p>对于usermod的进一步说明，除了上面提到的选项，还有如下选项：</p>

<details class=" box cstyle notices transparent expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    展开
  </summary>
  <div class="box-content">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    选项：
  -c, --comment 注释            GECOS 字段的新值
  -d, --home HOME_DIR           用户的新主目录
  -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE
  -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态
  -g, --gid GROUP               强制使用 GROUP 为新主组
  -G, --groups GROUPS           新的附加组列表 GROUPS
  -a, --append GROUP            将用户追加至上边 -G 中提到的附加组中，
                                并不从其它组中删除此用户
  -h, --help                    显示此帮助信息并推出
  -l, --login LOGIN             新的登录名称
  -L, --lock                    锁定用户帐号
  -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)
  -o, --non-unique              允许使用重复的(非唯一的) UID
  -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码
  -R, --root CHROOT_DIR         chroot 到的目录
  -s, --shell SHELL             该用户帐号的新登录 shell
  -u, --uid UID                 用户帐号的新 UID
  -U, --unlock                  解锁用户帐号
  -Z, --selinux-user  SEUSER       用户账户的新 SELinux 用户映射</code></pre></div>
  </div>
</details>
<p>3.登录用户与用户组———— <strong>su</strong> <strong>newgrp</strong></p>
<p>root用户与普通用户之间的切换使用su,如果要切换根目录则需要在su 后加-，即： <strong>su - [用户]</strong>。</p>
<p>在Linux中，组的登录使用 newgrp ，即 <strong>newgrp [组名]</strong>。</p>
<p>下面通过一个例子加以理解：</p>
<p>添加一个用户名为15user，且该用户在用户组15group中，设置用户组和用户密码为123，创建一个用户15user2让该用户为用户组管理员,修改user的UID为2024，最后删除所用所建信息。</p>

<details class=" box cstyle notices transparent expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    展开
  </summary>
  <div class="box-content">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">[root@localhost ~]# groupadd 15group
[root@localhost ~]# useradd -g 15group 15user
[root@localhost ~]# tail -1 /etc/passwd
15user:x:1001:1007::/home/15user:/bin/bash
[root@localhost ~]# tail -1 /etc/group
15group:x:1007:

[root@localhost ~]# gpasswd 15group
正在修改 15group 组的密码
新密码：
请重新输入新密码：
[root@localhost ~]# passwd 15user
更改用户 15user 的密码 。
新的 密码：
无效的密码： 密码少于 8 个字符
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
[root@localhost ~]# useradd 15user2

[root@localhost ~]# gpasswd -A 15user2 15group
[root@localhost ~]# tail -2 /etc/group
15group:x:1007:
15user2:x:1002:
[root@localhost ~]# tail -2 /etc/gshadow
15group:$6$d4pzl/CPrp$3NYvX8gzE3DBm35BLqAE8aGzfUhrUZTSMGQfeRve2iUhrH1tZGR8I8t91gWzFD2GWFEDaaocO7XO85RjKDY.q1:15user2:
15user2:!::

[root@localhost ~]# usermod -u  2024 15user
[root@localhost ~]# tail -2 /etc/passwd
15user:x:2024:1007::/home/15user:/bin/bash
15user2:x:1002:1002::/home/15user2:/bin/bash

[root@localhost ~]# userdel 15user
[root@localhost ~]# groupdel 15group
[root@localhost ~]# userdel 15user2</code></pre></div>
  </div>
</details>
<p>在上面的例子中，我们使用gpasswd -A来设置用户组管理员。</p>
<h2 id="文件目录和目录权限管理">文件目录和目录权限管理</h2>
<h3 id="文件访问权限与用户分类">文件访问权限与用户分类</h3>
<h4 id="文件的访问权限">文件的访问权限</h4>
<ul>
<li>读(r)：允许读文件的内容</li>
<li>写(w)：允许向文件中写入数据</li>
<li>执行(x)：允许将文件作为程序执行</li>
</ul>
<h4 id="目录的访问权限">目录的访问权限</h4>
<ul>
<li>读(r)：允许查看目录中有哪些文件和目录；</li>
<li>写(w)：允许该在目录下创建（或删除）文件、目录，修改文件名字或者目录名字</li>
<li>执行(x)：允许访问目录(用 cd 命令进入该目录，并查看目录中可读文件的内容)</li>
</ul>
<h4 id="用户分类">用户分类</h4>
<ul>
<li>文件所有者（owner）：建立文件、目录的用户。</li>
<li>同组用户(group)：属于同一组群的用户对属于该组群的文件有相同的访问权限。</li>
<li>其他用户(other)：除了文件所有者、同组用户的其他用户。</li>
</ul>
<p>我们先用ls -l 查看文件的权限信息：</p>
<p><a href="#R-image-89b9e0d9b5bc3a07d5704684f8fd7986" class="lightbox-link"><img alt="tu2" class="lazy lightbox figure-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/tu2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-89b9e0d9b5bc3a07d5704684f8fd7986"><img alt="tu2" class="lazy lightbox lightbox-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/tu2.png"></a></p>
<p>在上面的开头有三段他们分别表示为文件所有者、同组用户、其他用户：</p>
<p><a href="#R-image-71bc2d2f9cc7a396ef774a5e9fda3c63" class="lightbox-link"><img alt="tu1" class="lazy lightbox figure-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/tu1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-71bc2d2f9cc7a396ef774a5e9fda3c63"><img alt="tu1" class="lazy lightbox lightbox-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/tu1.png"></a></p>
<p>其中的d表示目录。</p>
<h3 id="权限修改">权限修改</h3>
<h4 id="访问权限的表示">访问权限的表示</h4>
<ul>
<li>（1）字母表示法（如：rwxr-xr-x）</li>
<li>（2）数字表示法 （如：755）
<a href="#R-image-308fc71799185879d7232b19d6136ace" class="lightbox-link"><img alt="tu3" class="lazy lightbox figure-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/tu3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-308fc71799185879d7232b19d6136ace"><img alt="tu3" class="lazy lightbox lightbox-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/tu3.png"></a></li>
</ul>
<p>使用数字进行文件权限的划分，其中r=4、w=2、x=1、-=0，这样rwx这组权限就是4+2+1=7，r-x这组权限就是5。</p>
<h4 id="修改权限的命令chmod">修改权限的命令：chmod</h4>
<ol>
<li>命令格式1：
chmod <span class="math align-center">$n{_1}n{_2}n{_3}$</span> &lt;文件|目录&gt;</li>
</ol>
<ul>
<li>功能：为指定文件或目录修改给定的数值访问权限。</li>
<li>选项：<span class="math align-center">$n{_1}n{_2}n{_3}$</span>三位数字表示的文件访问权限。</li>
</ul>
<ol>
<li>命令格式2：
chmod [用户标识] [设定方法] [权限字符] &lt;文件名或目录名〉</li>
</ol>
<ul>
<li>功能：修改文件或目录的访问权限。</li>
<li>选项：
<ul>
<li>（1）用户标识：所有者（u）、同组（g）、其他人（o）、所有的人员（a）</li>
<li>（2）设定方法：+ 增加权限、- 删除权限、= 分配权限，同时删除旧的权限</li>
<li>（3）权限字符：r（读）、w（写）、x（执行）、u（和所有者的权限相同）、g（和所同组用户的权限相同）、o（和其他用户的权限相同）</li>
</ul>
</li>
</ul>
<h4 id="修改文件所有者的命令chown">修改文件所有者的命令：chown</h4>
<ul>
<li>格式：chown [-R] &lt;用户[：组]&gt; &lt;文件或目录&gt;</li>
<li>功能：更改属主和组。</li>
<li>选项：
-R：对目录及其子目录进行递归设置。</li>
</ul>
<p>例如：chown sjh：sjh result.txt</p>
<h4 id="修改文件所属组群的命令chgrp">修改文件所属组群的命令：chgrp</h4>
<p>格式：chgrp group file</p>
<p>其中group：组名或组代号</p>
<p>功能： 改变文件或目录组群</p>
<p>例如：chgrp user result.txt</p>
<p>关于chown与chgrp的命令的例子：</p>

<details class=" box cstyle notices transparent expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    展开
  </summary>
  <div class="box-content">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    [root@localhost ~]# chown user2:user2 /tmp/test/user1_2.txt
    [root@localhost ~]# ls -l /tmp/test/
    总用量 0
    -rw-rw-r--. 1 user2 user2 0 1月  15 19:40 user1_2.txt
    [root@localhost ~]# chgrp root /tmp/test/user1_2.txt
    [root@localhost ~]# ls -l /tmp/test/
    总用量 0
    -rw-rw-r--. 1 user2 root 0 1月  15 19:40 user1_2.txt
    [root@localhost ~]# </code></pre></div>
  </div>
</details>
<h4 id="修改默认权限的命令umask">修改默认权限的命令：umask</h4>
<p>格式：umask [mask]</p>
<p>功能：设置文件或目录的默认权限</p>
<p>注意：系统默认屏蔽的权限为022（umask的默认值为0022），因此新
创建的目录权限就为777-022=755，用字符表示就是rwxr-xr-x，新创
建的普通文件权限为666-022=644，即rw&ndash;r&ndash;r&ndash;。</p>
<h4 id="文件隐藏属性">文件隐藏属性</h4>
<ul>
<li>
<p>1）查看文件隐藏属性：lsattr</p>
</li>
<li>
<p>2）修改文件隐藏属性：chattr</p>
</li>
<li>
<p>chattr [+-=] [ ai] 文件或目录名称</p>
<ul>
<li>a: 当设置a之后，这个文件将只能增加数据，而不能删除也不能修改数据，
必须要为root才能设置这个属性。</li>
<li>i：不能删除，不能修改，不能改名。必须要为root才能设置这个属性。</li>
</ul>
</li>
</ul>
<h3 id="文件特殊权限">文件特殊权限</h3>
<p>文件特殊权限有以下三种：</p>
<p>1）SUID：Set UID（只对二进制程序有效，对shell script无效）</p>
<p>例如：ll /usr/bin/passwd</p>
<p>注意：当用户执行passwd命令的时候，需要修改/etc/shadow文件，而该文件普通用户并没有任何权限。</p>
<p>2）SGID：Set GID</p>
<p>例如：ll /usr/bin/locate
注意：当用户执行locate命令的时候，需要读取/var/lib/mlocate/mlocate.db文件。</p>
<p>3）SBIT：Sticky Bit （只对目录有效）</p>
<p>设置方法：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">    chmod -o+t [指定目录名]
    或者
    chmod 1777 [指定目录名]</code></pre></div>
<p>对一个目录进行如上设置以后，假设有用户A和B，用户A在该目录下创建的文件只有他自己的root用户可以删，像B这样的其他用户删不了。</p>
<p><a href="https://blog.csdn.net/weiling_shen/article/details/7577571" rel="external" target="_blank">特殊文件说明文章链接</a></p>
<h2 id="软件包管理">软件包管理</h2>
<p>接下里介绍两个软件安装的工具，分别是RPM：Red Hat Package Manager（Red Hat软件包管，以及YUM:Yellow dog Dpdater,Modified.</p>
<p>RPM工具不需要网络，需要提前准备好安装包，但是他也有缺点安装的时候如果缺少依赖包你还需要再安装依赖包；</p>
<p>而YUM工具需要再有网的状态下才可以下载，它免去了依赖包提醒，自动将依赖包下载好，较为方便，我跟推荐使用YUM。</p>
<h3 id="rpm工具的使用">RPM工具的使用</h3>
<p>1．安装软件包（install）</p>
<p><strong>rpm -ivh rpm软件包全名</strong>：</p>
<ul>
<li>i：安装一个新的软件包</li>
<li>v：显示详细信息</li>
<li>h：显示安装进度条理工具</li>
</ul>
<p>2．查询已安装的软件包（query）</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">rpm –qa //查询出本机所有已经安装的软件
rpm –q httpd //查询httpd软件包是否已经安装
rpm -q【i l c d R】 vsftpd
rpm -qf /etc/inittab
查询未安装的软件包：
rpm -qp 【i l c d R】 gconf-editor-2.28.0-3.el6.i686.rpm</code></pre></div>
<p>3．升级与更新（upgrade/freshen）</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux">rpm -Uvh 软件包名称
//原来没有安装过的，直接安装；如果已安装过，则更新至新版
rpm -Fvh 软件包名称
//原来没有安装过的，不安装；如果已安装过，则更新至新版</code></pre></div>
<p>4．卸载RPM包（erase）</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0"><code class="language-linux" data-lang="linux"> rpm -e vsftpd
 注意：卸载时只需要给出软件包名称vsftpd，而不需要给出软件包的全部名称信息vsftpd-2.2.2-6.el6.i686.rpm。</code></pre></div>
<h3 id="yum工具的使用">YUM工具的使用</h3>
<p><strong>yum在线升级机制：</strong></p>
<ul>
<li>安装软件 yum install gcc</li>
<li>删除软件 yum remove gcc</li>
<li>查询软件 yum search gcc</li>
</ul>
<p><strong>软件包管理：</strong></p>
<ul>
<li>举例一：搜寻与磁盘阵列(raid)相关的软件有哪些？
[root@www ~]# yum search raid</li>
<li>举例二：找出mdadm这个软件的功能为何？
[root@www ~]# yum info mdadm</li>
<li>举例三：列出yum 服务器上面提供的所有软件名称。
[root@www ~]# yum list</li>
<li>举例四：列出目前服务器上可供本机进行升级的软件有哪些？
[root@www ~]# yum list updates</li>
<li>举例五：列出提供passwd这个文件的软件有哪些？
[root@www ~]# yum provides passwd</li>
</ul>
<p><strong>yum的软件组功能：</strong></p>
<ul>
<li>查询软件组：yum grouplist（查阅目前容器与本机上面的可用与安装过
的软件群组有哪些？）</li>
</ul>
<p>yum groupinfo Eclipse（查询Eclipse软件组的相关信息）</p>
<ul>
<li>安装软件组： yum groupinstall Eclipse</li>
<li>删除软件组： yum groupremove Eclipse</li>
</ul>
<h2 id="硬盘分区及格式化">硬盘分区及格式化</h2>
<h3 id="硬盘分区介绍">硬盘分区介绍</h3>
<ul>
<li>硬盘的分区分为主磁盘分区和扩展磁盘分区。</li>
<li>一个硬盘最多可以划分为 <strong>4</strong> 个主磁盘分区，这时不能再创建扩展分区。</li>
<li>一个硬盘中最多只能创建 <strong>1个扩展分区</strong> ，扩展分区不能直接使用，必须在扩展分区中再划分出逻辑分区才可以使用。</li>
<li>逻辑分区是从5开始的，每多1个分区，数字加1就可以。</li>
</ul>
<h4 id="硬盘标识">硬盘标识</h4>
<p>（1）IDE硬盘：hd[a-d]*</p>
<p>hd表示硬盘类型为IDE，中括号中的字母为a、b、c、d中的一个，a是基本盘，b是从盘，是辅助主盘，d是辅助从盘，*指分区，即主分区和扩展分区。</p>
<p>例如：hda1代表第一块IDE硬盘上的第一个分区。hdb5代表第二块IDE硬盘的第一个逻辑分区。</p>
<p>（2）SCSI/SATA硬盘：sd[a-p]*</p>
<p>sd表示SCSI/SATA硬盘。SCSI/SATA的引导盘使用设备文件/dev/sda1、/dev/sda2、/dev/sda3、/dev/sda4作为主分区或者扩展分区，而以/dev/sda5，/dev/sda6等作为逻辑分区。</p>
<h3 id="创建硬盘分区">创建硬盘分区</h3>
<p>先使用ls -l /dev |grep &lsquo;sd&rsquo;查看文件里是否有可用的磁盘，如果没有需要创建一个磁盘，创建步骤：</p>
<p>1．通过虚拟机设置增加一块SCSI硬盘，大小为5G，重启系统。

<details class=" box cstyle notices transparent expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    展开
  </summary>
  <div class="box-content">
<p><a href="#R-image-534750ef8eb37d6d6f9455cd4d7ee082" class="lightbox-link"><img alt="tu4" class="lazy lightbox figure-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%874.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-534750ef8eb37d6d6f9455cd4d7ee082"><img alt="tu4" class="lazy lightbox lightbox-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%874.png"></a></p>
<p>按照下图点击下一步</p>
<p><a href="#R-image-f5ac03d975f96aa74468ef8587c500de" class="lightbox-link"><img alt="tu4" class="lazy lightbox figure-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%875.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f5ac03d975f96aa74468ef8587c500de"><img alt="tu4" class="lazy lightbox lightbox-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%875.png"></a></p>
<p><a href="#R-image-b5b7cdf193e71db16bb7ec9f11787c08" class="lightbox-link"><img alt="tu4" class="lazy lightbox figure-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%876.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b5b7cdf193e71db16bb7ec9f11787c08"><img alt="tu4" class="lazy lightbox lightbox-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%876.png"></a></p>
<p>根据实际情况输入所需硬盘大小，这里输入5GB</p>
<p><a href="#R-image-4e8345d2cbb58afe2f094bc1432d3236" class="lightbox-link"><img alt="tu4" class="lazy lightbox figure-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%877.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4e8345d2cbb58afe2f094bc1432d3236"><img alt="tu4" class="lazy lightbox lightbox-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%877.png"></a></p>
<p>然后点击完成</p>
<p><a href="#R-image-076c480dd85e6fa79d34ad54f4277ac8" class="lightbox-link"><img alt="tu4" class="lazy lightbox figure-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%878.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-076c480dd85e6fa79d34ad54f4277ac8"><img alt="tu4" class="lazy lightbox lightbox-image" loading="lazy" src="/class/9.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%89%878.png"></a></p>
<p>最后在命令窗口输入reboot重启。</p>
  </div>
</details></p>
<p>2．将该硬盘分为2个主分区（每个主分区的大小为1G），1个扩展分区（大小为3G），将第2个主分区制作成swap分区。</p>
<p>命令：

<details class=" box cstyle notices transparent expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    展开
  </summary>
  <div class="box-content">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>    <span style="color:#f92672">//</span>先用命令查看sd,sd表示SCSI<span style="color:#f92672">/</span>SATA硬盘<span style="color:#960050;background-color:#1e0010">，</span>
</span></span><span style="display:flex;"><span>    ls <span style="color:#f92672">/</span>dev<span style="color:#f92672">/</span>sd <span style="color:#f92672">|</span>grep sd
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">//</span>硬盘分区
</span></span><span style="display:flex;"><span>    fdisk  <span style="color:#f92672">/</span>dev<span style="color:#f92672">/</span>sdb
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">//</span>使用m查看帮助命令<span style="color:#960050;background-color:#1e0010">，</span>n为新建命令<span style="color:#960050;background-color:#1e0010">，</span>d为删除命令<span style="color:#960050;background-color:#1e0010">，</span>w为写入命令<span style="color:#960050;background-color:#1e0010">，</span>每次配完都要写入才有效<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>    n
</span></span><span style="display:flex;"><span>    p  <span style="color:#f92672">//</span>这是新建主分区的意思
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">//</span>接着指定分区起始位置<span style="color:#960050;background-color:#1e0010">，</span>一般我们默认<span style="color:#960050;background-color:#1e0010">，</span>所以回车就可以
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">//</span>然后就是指定分区的大小<span style="color:#960050;background-color:#1e0010">，</span>这里我设置1G<span style="color:#960050;background-color:#1e0010">、</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>G
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">//</span>可以用p命令查看设置的情况
</span></span><span style="display:flex;"><span>    P
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">//</span>按照上面的流程进行其他的设置<span style="color:#960050;background-color:#1e0010">，</span>一下给出步骤命令
</span></span><span style="display:flex;"><span>    n
</span></span><span style="display:flex;"><span>    p
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>G
</span></span><span style="display:flex;"><span>    n
</span></span><span style="display:flex;"><span>    e
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>G</span></span></code></pre></div>
  </div>
</details>
3．将扩展分区划出2个逻辑分区（大小分别为1G、2G）。</p>
<p>命令：

<details class=" box cstyle notices transparent expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    展开
  </summary>
  <div class="box-content">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">//</span>到这步后我们可以给扩展分区分配逻辑分区<span style="color:#960050;background-color:#1e0010">，</span>分配时逻辑分区用l命令<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>    n
</span></span><span style="display:flex;"><span>    l
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>G
</span></span><span style="display:flex;"><span>    n
</span></span><span style="display:flex;"><span>    l
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>G</span></span></code></pre></div>
  </div>
</details></p>
<h3 id="查看磁盘情况与磁盘格式化">查看磁盘情况与磁盘格式化</h3>
<ul>
<li>（1）查看系统中的新硬盘：<strong><code>ls /dev/sd*</code></strong></li>
<li>（2）查看分区：<code>fdisk –l /dev/sda</code></li>
<li>（3）创建主分区：<strong><code>fdisk /dev/sdc</code></strong></li>
<li>（4）创建扩展分区：输入n,再输入e</li>
<li>（5）创建逻辑分区: 输入n,再输入l</li>
<li>（6）修改分区类型</li>
<li>（7）格式化分区：
<ul>
<li><strong><code>mkfs –t ext4 /dev/sdc1</code></strong> 还可以写成**<code>mkfs.ext4 /dev/sdc1</code>**</li>
<li>格式化交换分区略有不同，使用命令 <strong>mkswap</strong> ,例如： <code>mkswap dev/sdb2</code></li>
</ul>
</li>
<li>（8）磁盘检查命令：<code>fsck –t ext4 /dev/sdc1</code>
<ul>
<li><code>badblocks /dev/sdb5</code></li>
</ul>
</li>
<li>（9）查看磁盘使用情况 <code>df</code>,或使用<code>df -h</code>输出更易于查看。</li>
</ul>
<p>上面的-t意思是参数TYPE的意思，后面接ext4()、vfat(FAT32)、ntfs()等，</p>
<h3 id="挂载文件系统mount">挂载文件系统：mount</h3>
<ul>
<li>1、 <strong>挂载硬盘分区：</strong>
<ul>
<li>步骤1：mkdir /usr/music</li>
<li>步骤2：mount /dev/sdc5 /usr/music</li>
</ul>
</li>
<li>2、 <strong>挂载光驱：</strong>
<ul>
<li>步骤1：mkdir /mnt/cdrom</li>
<li>步骤2：mount /dev/cdrom /mnt/cdrom</li>
</ul>
</li>
<li>3、 <strong>挂载U盘：</strong>
<ul>
<li>步骤1：mkdir /mnt/usb</li>
<li>步骤2：mount /dev/sdd1 /mnt/usb</li>
</ul>
</li>
<li>4、 <strong>挂载Windows下的C盘</strong> （FAT32格式）：
<ul>
<li>步骤1：mkdir /mnt/dosc</li>
<li>步骤2：mount -t vfat /dev/sda1 /mnt/dos</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong> C盘必须已经被格式化为FAT32格式。</p>
<h3 id="显示系统内所有已经挂载的文件系统">显示系统内所有已经挂载的文件系统</h3>
<p><strong>mount</strong>
不带任何参数执行mount命令，则会显示当前系统中已经挂载的所有的文件系统列表。</p>
<h3 id="卸载设备umount">卸载设备：umount</h3>
<p>格式： umount &lt;设备名或挂载点&gt;</p>
<p>说明：卸载指定的设备，既可以使用设备名也可以使用挂载点。</p>
<p>举例： # umount /dev/cdrom</p>
<h3 id="自动挂载文件系统etcfstab">自动挂载文件系统：/etc/fstab</h3>
<p>每条记录由6个字段组成。</p>
<p>1.设备名称
2.设备挂载点
3.文件系统类型
4.挂载选项
5.是否备份
6.自检顺序</p>
<p>如果想要系统自动挂载/dev/sdc5分区，可在<code>/etc/fstab</code>文件添加下面这行：</p>
<p><code>/dev/sdc5 /usr/music ext4 defaults 0 0</code></p>
<p><strong>注意</strong>:由于fstab文件非常重要，如果这个文件有错误，就可能会造成系统不能正常启动。因此向fstab文件中添加数据时应非常小心。修改完该文件后务必使用<code>mount -a</code>命令测试有没有错误。</p>
<h3 id="磁盘配额">磁盘配额</h3>
<p>以sdb1为例</p>
<p>第一步：先配置sdb磁盘，然后挂载sdb1磁盘</p>
<p>第二步：使用quotaon /sdb1/生成aquota.group和aquota.user文件</p>
<p>第三步：对用户或用户组进行磁盘限制,例如：edquota -u user1，然后会进入一个文件，文件里的0表示禁用，在里面可以设置创建文件个数或文件大小的软限制、硬限制；</p>
<p>第四步：我们登录user1，在/sdb/目录下创建文件，使用 <code>db if=/dev/zero of=/sdb1/test/ bs=1k count=10</code>这条命令进行测试，这是一个写文件大小的命令，这样可以快速测试文件大小的软限制和硬限制；</p>
<p>第五步：子里面建文件，检验创建文件个数的软限制和硬限制；</p>
<p>第六步: 可以使用repquota -u查看目录的情况；</p>
<p>第七步：关闭磁盘匹配额，quotatoff /sdb1/</p>
<h2 id="linux编程">Linux编程</h2>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年1月14日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/f1-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">F1-复习资料</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/androidstudio/">AndroidStudio</a></li>
  </ul>
</div>
  </header>

<h1 id="androidstudio">AndroidStudio</h1>

<div class="children children-h2 children-sort-">
  <h2 class="children-title" id="androidstudio"><a href="/class/2.androidstudio/androidstudio%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">AndroidStudio</a></h2><p><p>接下来将将介绍AndroidStudio的复习资料，包括AndroidStudio简介、AndroidStudio中 <strong>Make Project</strong> 、<strong>Clean Project</strong> 、<strong>Rebuild Project</strong> 的作用、Run窗口、manifests文件夹（清单文件夹）、java文件夹、res文件夹、Android系统体系结构四层等。</p></p>
  <h2 class="children-title" id="androidstudio笔记"><a href="/class/2.androidstudio/%E7%AC%94%E8%AE%B0/">AndroidStudio笔记</a></h2><p><p>这篇文章主要介绍AndroidStudio的使用，以及一些Android开发的基础知识。以及一些开发中遇到的问题和解决方法，除此之外，还会介绍一些开发中常用的工具和技巧。</p></p>
  <h2 class="children-title" id="2-1toolbar工具栏"><a href="/class/2.androidstudio/toolbar/">2-1.Toolbar工具栏</a></h2><p>本篇文章主要介绍**Toolbar**工具栏的使用，以及**menu**文件的使用</p>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年1月11日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/">核心课程</a></li>
  </ul>
</div>
  </footer>
</article>
          <section>
            <h1 class="a11y-only">AndroidStudio 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E5%AE%89%E5%8D%93/">安卓</a></li>
  </ul>
</div>
  </header>

<h1 id="androidstudio">AndroidStudio</h1>

<p>接下来将将介绍AndroidStudio的复习资料，包括AndroidStudio简介、AndroidStudio中 <strong>Make Project</strong> 、<strong>Clean Project</strong> 、<strong>Rebuild Project</strong> 的作用、Run窗口、manifests文件夹（清单文件夹）、java文件夹、res文件夹、Android系统体系结构四层等。</p>
<h2 id="androidstudio简介">AndroidStudio简介</h2>
<span class="badge cstyle default"><span class="badge-content">Important</span></span>
<p>1.配置Android开发环境：</p>
<ul>
<li>安装JDK：
（1）下载JDK
（2）配置环境变量；</li>
<li>安装Android Studio；</li>
<li>安装SDK。</li>
</ul>
<p>2.自动构建工具Gradle：</p>
<p>Gradle 是以 Groovy 语言为基础，面向Java应用为主，基于DSL（领域特定语言）语法的自动化构建工具。它可以自动化地进行软件构建、测试、发布、部署、软件打包，同时也可以完成项目相关功能，如生成静态网站、生成文档等。另外其集合了Ant的灵活性和强大功能，以及Maven的依赖管理和约定，从而创造了一个更有效的构建方式。凭借Groovy的DSL和创新打包方式，Gradle提供了一个可声明的方式，并在合理默认值的基础上描述所有类型的构建。Gradle目前已被选作许多开源项目的构建系统。</p>
<p>3.Logcat日志输出工具：使用 Logcat 查看日志</p>
<p>Android Studio 中的 Logcat 窗口会实时显示设备日志来帮助您调试应用，例如，使用 Log 类添加到应用的消息、在 Android 上运行的服务发出的消息或系统消息（例如在发生垃圾回收时）。如果应用抛出异常，Logcat 会显示一条消息，后跟相关联的堆栈轨迹，其中包含指向代码行的链接。</p>
<p>4.Android Studio中 <strong>Make Project</strong> 、<strong>Clean Project</strong> 、<strong>Rebuild Project</strong> 的作用</p>
<ul>
<li>Make Project：编译Project下所有Module（组件或模块），一般是自上次编译后Project下有更新的文件，增量编译，不生成Apk。</li>
<li>Clean Project：删除之前编译后的编译文件。部分版本的AS会自动重新编译整个Project，不生成Apk。</li>
<li>Rebuild Project：先执行Clean操作，删除之前编译的编译文件和可执行文件，然后重新编译新的编译文件，不生成Apk</li>
</ul>
<p>5.Run窗口：可以输出程序运行过程中出现的错误。
6.manifests文件夹（清单文件夹）：Android系统配置文件夹，包含一个AndroidManifest.xml文件（清单文件），可在此文件注册声明</p>
<ul>
<li><code>&lt;activity&gt;</code>页面、</li>
<li><code>&lt;service&gt;</code>服务、</li>
<li><code>&lt;receiver&gt;</code>接收器、</li>
<li><code>&lt;provider&gt;</code>提供者或提供程序、</li>
<li><code>&lt;uses-permission&gt;</code>使用权限等；</li>
</ul>
<p>7.java文件夹：存放Java代码的文件夹，新建项目时默认生成了三个文件夹，com.first.project文件夹用来存放Java文件，这里包含一个名为MainActivity的Java文件，是新建项目时默认生成的。
第二个和第三个文件为测试代码文件夹，不是十分常用。</p>
<ul>
<li>res文件夹：存放Android项目的资源文件，包含四个文件夹：</li>
<li>drawable（图片资源文件夹）、</li>
<li>layout（布局资源文件夹）、</li>
<li>mipmap（图片资源文件夹，存放项目图标）、</li>
<li>values（存放数值资源文件），</li>
<li>此外有menu文件（菜单资源文件）。</li>
</ul>
<p>8.Android系统体系结构四层，从上到下分别是</p>
<ul>
<li>应用程序层</li>
<li>应用程序框架层</li>
<li>系统运行库层</li>
<li>Linux内核层
每一层都是用其下面各层所提供的服务。</li>
</ul>
<p>应用程序层</p>
<p>Android平台包含了许多核心的应用程序，诸如Email客户端、SMS短消息程序、日历、地图、浏览器、联系人等应用程序。这些应用程序都是用Java语言编写的。开发人员可以灵活地根据需求替换这些自带的应用程序或者开发新的应用程序。</p>
<p>应用程序框架</p>
<p>开发者可以完全访问核心应用程序所使用的API框架。该层简化了组件的复用，使得开发人员可以直接使用系统提供的组件来进行快速地开发，也可以通过继承灵活地加以拓展。这些东西包括：</p>
<p>活动管理器（Activity Manager，管理各个应用程序的生命周期以及通常的导航回退功能）
视图系统（View System，构建应用程序的基本组件）
内容提供器（ContentProvider，使得不同的应用程序之间可以存取或者分享数据）
资源管理器（Resource Manager，提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件等）
通知管理器（Notification Manager，使应用程序可以在状态栏中显示自定义的提示信息）等。</p>
<p>系统运行库层</p>
<p>包括系统库和Android Runtime，系统库是应用程序框架的支撑，是连接应用程序框架层与Linux内核层的重要纽带。程序在Android Runtime中执行，其运行时分为核心库和Dalvik虚拟机两部分。</p>
<p>Linux内核层</p>
<p>Android基于Linux2.6的内核，其核心系统服务如安全性、内存管理、进程管理、网络协议以及驱动模型都依赖于Linux内核，同时内核层也扮演了介于硬件层和软件栈之间的抽象层的角色。
Linux内核层和系统运行库层之间，从Linux操作系统的角度来看，是内核空间与用户空间的分界线，Linux层运行于内核空间，以上各层运行于用户空间。系统运行库层和应用框架层之间是本地代码层和Java代码层的接口。应用框架层和应用程序层是Android的系统API的接口，对于Android应用程序的开发，应用程序框架层以下的内容是不可见的，仅考虑系统API即可。</p>
<p>9.四大核心组件有：activity（活动或页面）、service（服务）、broadcast receiver（广播接收器）、content provider（内容提供者）</p>
<p>10.Activity介绍Android系统是通过任务栈来管理Activity的。当一个Activity启动时，会把Activity压入到堆栈中，当用户按返回键或者结束掉该Activity时，它会从堆栈中弹出。</p>
<p>11.Android为我们定义了四种加载方式</p>
<p>Standard 加载模式  ——标准模式/默认加载模式</p>
<p>标准模式：系统默认的Activity启动模式，当Intent欲打开Activity时，在该Activity不存在，存在于栈顶和存在于栈底三种情况下都会正常创建Activity，并压入任务栈栈顶；</p>
<p>SingleTop 加载模式  ——栈顶单例模式</p>
<p>栈顶单例模式：当启动一个Activity时，只有当该activity存在任务栈中且为栈顶，Intent才会通过onNewIntent()方法传递给在栈顶Activity实例；其他情况则正常创建Activity并压入任务栈；</p>
<p>SingleTask 加载模式  ——栈内单例模式</p>
<p>站内单例模式：当启动一个Activity时，系统会先检查任务栈内是否有该Activity，如果该Activity不存在则正常创建Activity实例，如果存在且在栈底则会将它上面的Activity弹出并销毁，使该Activity置于栈顶再调用onNewIntent()方法；</p>
<p>SingleInstence 加载模式  ——全局单例模式</p>
<p>与SingleTask模式基本一样，只是在这个模式下Activity所处的任务栈中只能有Activity这一个实例，不能有其他的实例。</p>
<p>12.Activity生命周期是指Activity从创建到销毁的过程，在这一过程中，Activity一般处于4种状态，即：Active/Running、Paused、Stop、Killed</p>
<p>（1）Active/Running   此时Activity一定处于屏幕的最前端，用户完全可以看得到，并且可以与用户进行交互。对于Activity栈来说，它处于栈顶；
（2）Paused  此时Activity在屏幕上仍然可见，但是它已经失去了焦点，用户不能与之进行交互。暂停状态的Activity是存活的，它仍然维持着其内部状态和信息，但是系统可能会在手机内存极低的情况下杀掉该Activity；
（3）Stop   此时Activity在屏幕上完全不能被用户看见，也就是说这个Activity已经完全被其他Activity所遮住。处于停止状态的Activity，系统仍然保留有其内部状态和成员信息，但是它经常会由于手机系统内存被征用而被系统杀死回收；
（4）Killed   Activity被系统杀死回收或者未启动。</p>
<p>13.为了能够让Android程序了解自身状态的变化，Android系统中具有很多事件回调函数，我们可以重载这些方法来实现自己的操作。Android生命周期的事件回调函数如下：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onCreate</span>(Bundle savedInstanceState) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onStart</span>() 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onRestart</span>() 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onResume</span>() 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onPause</span>() 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onStop</span>() 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onDestroy</span>()</span></span></code></pre></div>
<p>14.Activity生命周期</p>
<p>15.Fragment必须是依存于Activity而存在，因此Activity的生命周期会直接影响到Fragment的生命周期。图在课本第50页。</p>
<p>由图可以看到Fragment比Activity多了几个额外的生命周期回调函数：</p>
<p>onAttach(Activity)：当Fragment与Activity发生关联时调用。从该方法开始，就可以通过Fragment.getActivity方法获取与Fragment关联的窗口对象了，但在该方法中仍然无法操作Fragment中的控件。
onCreateView(LayoutInflater, ViewGroup, Bundle)：创建该Fragment的视图。onActivityCreated(Bundle)：当Activity的onCreate方法返回时调用。</p>
<p>onDestoryView():与onCreateView相对应，当该Fragment的视图被移除时调用。onDetach()：与onAttach相对应，当Fragment与Activity关联被取消时调用。</p>
<p>16.在使用Intent进行Activity之间的跳转时，我们通常有三种Intent跳转方式，即：不带参数的跳转、带参数的跳转以及带返回值的跳转，代码实现可参考实验报告或书本。</p>
<p>17.TextView常用的属性</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>    android:id=&#34;@+id/textView1&#34;表示该控件的id，在布局文件中或者代码中被引用
</span></span><span style="display:flex;"><span>    android:textStyle=&#34;bold&#34;表示TextView里面的字加粗显示
</span></span><span style="display:flex;"><span>    android:layout_height=&#34;wrap_content&#34;表示该控件的高度为其包含内容的高度
</span></span><span style="display:flex;"><span>    android:layout_width=&#34;wrap_content&#34;表示该控件的宽度为其包含内容的宽度
</span></span><span style="display:flex;"><span>    android:text=&#34;@string/signin&#34; 显示的内容，这里表示存放在string.xml文件中name=signin的文本
</span></span><span style="display:flex;"><span>    android:layout_height=&#34;40dip&#34;设置具体的高度
</span></span><span style="display:flex;"><span>    android:textColor=&#34;#7089c0&#34;设置文本的颜色
</span></span><span style="display:flex;"><span>    android:textSize=&#34;18sp&#34;设置文本的大小
</span></span><span style="display:flex;"><span>    android:gravity=&#34;center_vertical&#34;设置文本垂直居中
</span></span><span style="display:flex;"><span>    android:paddingLeft=&#34;5dip&#34;设置内边距
</span></span><span style="display:flex;"><span>    android:layout_marginTop=&#34;5dip&#34;设置外边距</span></span></code></pre></div>
<p>18.LinearLayout线性布局、</p>
<ul>
<li>RelativeLayout相对布局、</li>
<li>FrameLayout帧布局、</li>
<li>TableLayout表格布局、</li>
<li>AbsoluteLayout绝对布局</li>
</ul>
<p>线性布局，是指该容器（LinearLayout）内子控件的摆放方式有两种：
第一种：垂直放置（VERTICAL），相对水平放置来讲，垂直放置就相当于一列，放置的控件或者容器只能在该列中的某个位置，两个控件之间只存在上下方向的关系，不存在其他方向上的关系。当这一列放满后，再添加的控件就至于屏幕之外存在，无法看见。
第二种：水平放置（HORIZONTAL），指的是该容器里面存放的控件或者容器只能以一行的形式出现，放置的控件只能是该行中的某个位置，两个控件或者容器之间只有左右关系没有其他方向上的关系，当放置水平方向满屏时不会自动换行，再放置的控件将在屏幕之外存在，无法看见。
在线性布局中重要的属性值对应表示</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>    android:orientation	            //设置控件或者容器存放的方式
</span></span><span style="display:flex;"><span>    android:id	                    //设置控件id，方便在使用时找到其引用
</span></span><span style="display:flex;"><span>    android:layout_width	        //容器的宽度，该值必须设置
</span></span><span style="display:flex;"><span>    android:layout_height	        //容器的高度，该值必须设置
</span></span><span style="display:flex;"><span>    android:layout_weight	        //该属性针对其内的子控件，存放在LinearLayout中的控件都有这个属性，用来设置该控件或者容器占父控件或者容器的比例。</span></span></code></pre></div>
<p>相对布局，是指利用控件之间的相对位置关系来对布局进行放置。换句话说，在该容器中的控件与其他任何一个控件或者容器（包括父控件）有相对关系。</p>
<p>帧布局，是指该容器内放置的控件或者容器没有上下左右的关系，只有层叠前后的关系。放置在容器内的控件按放置的前后顺序逐一层叠摆放，自然地后面摆放的控件就将前面摆放的控件覆盖了，叠在它的上面了。对于放置前后的关系，在没有设置其他属性之前，Android系统采用的是叠放的原则，即后加入节点的层叠在上面。设置属性android：bringToFront=“true|false”将前面放置的控件提到最前面可见。</p>
<p>表格布局，指该容器是一个表格，放置控件时，控件的位置坐落在表格的某个位置上。其中TableRow是配合TableLayout使用的，目的是为了让TableLayout生成多个列，否则TableLayout中就只能存在一列元素，但可以有多行。</p>
<p>TableLayout的直接父类是LinearLayout，所以其具有LinearLayout的属性，TableLayout中的每一行用TableRow表示，每一列就是TableRow中的个数指定的。TableRow的直接父类是LinearLayout，但是其放置的方式只能水平放置。</p>
<p>绝对布局，是指以屏幕左上角为坐标原点（0,0），控件在容器中的位置以坐标的形式存在，可以随意指定控件的坐标位置，非常灵活。在开发过程中很少使用，原因是屏幕兼容性不好，不便控制两个控件之间的位置。其中控件或者容器放置的位置通过android:layout_x和android:layout_y这两个属性进行设置。</p>
<p>ConstraintLayout约束布局</p>
<p>优点：</p>
<p>ConstraintLayout之所以成为目前Android开发中主流的布局，除了官方建议使用ConstraintLayout外还有以下几个方面的优势
1.功能强大，ConstraintLayout几乎能实现其他布局所有的功能
2.能减少布局层次的嵌套，有性能的优势
3.可视化操作的增强，大部分界面用ConstraintLayout都能通过可视化编辑区域完成</p>
<p>19.对话框（Dialog）是Android系统在Activity或者其他组件运行过程中提供的一种资源消耗很小的提示机制，它可以帮助应用完成一些必要的提示功能，同时还提供一些用户交互的功能，包括简单的提示、等待、选择、展示等功能。操作简单，资源消耗较少。代码实现可参考实验报告或书本</p>
<p>1提示对话框</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.example.alertdialog;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.content.DialogInterface;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.os.Bundle;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.view.View;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.widget.Button;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.widget.TextView;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.widget.Toast;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.annotation.Nullable;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.appcompat.app.AlertDialog;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.appcompat.app.AppCompatActivity;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MultipleChoiceDialogBox</span> <span style="color:#66d9ef">extends</span> AppCompatActivity {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Button button;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onCreate</span>(<span style="color:#a6e22e">@Nullable</span> Bundle savedInstanceState) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onCreate</span>(savedInstanceState);
</span></span><span style="display:flex;"><span>        setContentView(R.<span style="color:#a6e22e">layout</span>.<span style="color:#a6e22e">test</span>);
</span></span><span style="display:flex;"><span>        button <span style="color:#f92672">=</span> findViewById(R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">dialog_box_up</span>);
</span></span><span style="display:flex;"><span>        button.<span style="color:#a6e22e">setOnClickListener</span>(<span style="color:#66d9ef">new</span> View.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(View view) {
</span></span><span style="display:flex;"><span>                AlertDialog.<span style="color:#a6e22e">Builder</span> builder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AlertDialog.<span style="color:#a6e22e">Builder</span>(MultipleChoiceDialogBox.<span style="color:#a6e22e">this</span>);
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setTitle</span>(<span style="color:#e6db74">&#34;这是一个简单的弹窗&#34;</span>);
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setIcon</span>(R.<span style="color:#a6e22e">mipmap</span>.<span style="color:#a6e22e">ic_launcher</span>);
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setMessage</span>(<span style="color:#e6db74">&#34;你学会了吗？&#34;</span>);
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setPositiveButton</span>(<span style="color:#e6db74">&#34;学会了&#34;</span>, <span style="color:#66d9ef">new</span> DialogInterface.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(DialogInterface dialogInterface, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setNegativeButton</span>(<span style="color:#e6db74">&#34;不会&#34;</span>, <span style="color:#66d9ef">new</span> DialogInterface.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(DialogInterface dialogInterface, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">show</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>2单选对话框</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.example.alertdialog;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.content.DialogInterface;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.os.Bundle;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.view.View;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.widget.Button;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.widget.TextView;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.widget.Toast;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.annotation.Nullable;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.appcompat.app.AlertDialog;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.appcompat.app.AppCompatActivity;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MultipleChoiceDialogBox</span> <span style="color:#66d9ef">extends</span> AppCompatActivity {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Button button;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> TextView textView;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String sexx<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span>{<span style="color:#e6db74">&#34;男&#34;</span>,<span style="color:#e6db74">&#34;女&#34;</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> choiceWitch <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onCreate</span>(<span style="color:#a6e22e">@Nullable</span> Bundle savedInstanceState) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onCreate</span>(savedInstanceState);
</span></span><span style="display:flex;"><span>        setContentView(R.<span style="color:#a6e22e">layout</span>.<span style="color:#a6e22e">test</span>);
</span></span><span style="display:flex;"><span>        button <span style="color:#f92672">=</span> findViewById(R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">dialog_box_up</span>);
</span></span><span style="display:flex;"><span>        textView<span style="color:#f92672">=</span>findViewById(R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">show_dialog_box_text</span>);
</span></span><span style="display:flex;"><span>        button.<span style="color:#a6e22e">setOnClickListener</span>(<span style="color:#66d9ef">new</span> View.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(View view) {
</span></span><span style="display:flex;"><span>                AlertDialog.<span style="color:#a6e22e">Builder</span> builder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AlertDialog.<span style="color:#a6e22e">Builder</span>(MultipleChoiceDialogBox.<span style="color:#a6e22e">this</span>);
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setCancelable</span>(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setSingleChoiceItems</span>(sexx, <span style="color:#f92672">-</span>1, <span style="color:#66d9ef">new</span> DialogInterface.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(DialogInterface dialog, <span style="color:#66d9ef">int</span> which) {
</span></span><span style="display:flex;"><span>                        choiceWitch<span style="color:#f92672">=</span>which;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setPositiveButton</span>(<span style="color:#e6db74">&#34;确定&#34;</span>, <span style="color:#66d9ef">new</span> DialogInterface.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(DialogInterface dialogInterface, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>                        textView.<span style="color:#a6e22e">setText</span>(sexx<span style="color:#f92672">[</span>choiceWitch<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setNegativeButton</span>(<span style="color:#e6db74">&#34;取消&#34;</span>, <span style="color:#66d9ef">new</span> DialogInterface.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(DialogInterface dialogInterface, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">show</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>3多选对话框</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.example.gpc.wzxapplicationwu1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.content.DialogInterface;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.os.Bundle;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.support.annotation.Nullable;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.support.v7.app.AlertDialog;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.support.v7.app.AppCompatActivity;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.view.View;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.widget.Button;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.widget.TextView;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AlertDialogActivity</span> <span style="color:#66d9ef">extends</span> AppCompatActivity{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Button button;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> TextView textView;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String sexx<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span>{<span style="color:#e6db74">&#34;a&#34;</span>,<span style="color:#e6db74">&#34;b&#34;</span>,<span style="color:#e6db74">&#34;c&#34;</span>,<span style="color:#e6db74">&#34;d&#34;</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> stu<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> {<span style="color:#66d9ef">false</span>,<span style="color:#66d9ef">false</span>,<span style="color:#66d9ef">false</span>,<span style="color:#66d9ef">false</span>};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> choiceWitch <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> HashMap<span style="color:#f92672">&lt;</span>Integer,Integer<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onCreate</span>(<span style="color:#a6e22e">@Nullable</span> <span style="color:#66d9ef">final</span> Bundle savedInstanceState) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onCreate</span>(savedInstanceState);
</span></span><span style="display:flex;"><span>        setContentView(R.<span style="color:#a6e22e">layout</span>.<span style="color:#a6e22e">alert_dialog</span>);
</span></span><span style="display:flex;"><span>        textView <span style="color:#f92672">=</span> findViewById(R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">alert_dialog_textview</span>);
</span></span><span style="display:flex;"><span>        button <span style="color:#f92672">=</span> findViewById(R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">alert_dialog_button</span>);
</span></span><span style="display:flex;"><span>        button.<span style="color:#a6e22e">setOnClickListener</span>(<span style="color:#66d9ef">new</span> View.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(View view) {
</span></span><span style="display:flex;"><span>                AlertDialog.<span style="color:#a6e22e">Builder</span> builder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AlertDialog.<span style="color:#a6e22e">Builder</span>(AlertDialogActivity.<span style="color:#a6e22e">this</span>);
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setMultiChoiceItems</span>(sexx, stu, <span style="color:#66d9ef">new</span> DialogInterface.<span style="color:#a6e22e">OnMultiChoiceClickListener</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(DialogInterface dialogInterface, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">boolean</span> b) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span>(b <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span>){
</span></span><span style="display:flex;"><span>                            map.<span style="color:#a6e22e">put</span>(i,i);
</span></span><span style="display:flex;"><span>                        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                            map.<span style="color:#a6e22e">remove</span>(i);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setPositiveButton</span>(<span style="color:#e6db74">&#34;确定&#34;</span>, <span style="color:#66d9ef">new</span> DialogInterface.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(DialogInterface dialogInterface, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">for</span> (Integer j : map.<span style="color:#a6e22e">keySet</span>()){
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> map.<span style="color:#a6e22e">get</span>(j);
</span></span><span style="display:flex;"><span>                            str <span style="color:#f92672">=</span> str <span style="color:#f92672">+</span> sexx<span style="color:#f92672">[</span>z<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        textView.<span style="color:#a6e22e">setText</span>(str);
</span></span><span style="display:flex;"><span>                        str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">setNegativeButton</span>(<span style="color:#e6db74">&#34;取消&#34;</span>, <span style="color:#66d9ef">new</span> DialogInterface.<span style="color:#a6e22e">OnClickListener</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onClick</span>(DialogInterface dialogInterface, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                builder.<span style="color:#a6e22e">show</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>19.Android系统中的ContextMenu(上下文菜单)类似于PC中的右键弹出菜单，当一个视图注册了上下文菜单时，长按该视图对象将出现一个提供相关功能的浮动菜单。上下文菜单可以被注册到任何视图对象中，最常见的是用于列表视图中，但上下文菜单不支持图标和快捷键。</p>
<p>选项菜单
当Activity在前台运行时，如果用户按下微信消息列表页面右上角加号键，此时就会在屏幕右上角弹出相应的选项菜单。但这个功能需要开发人员编程来实现，如果在开发应用程序时没有实现该功能，那么程序运行时按下手机的meun键是不会起作用的。</p>
<p>下拉菜单
严格来讲Spinner不算是一个菜单，但是其操作和表现形式具有菜单的行为。Spinner的有效使用可以提高用户的体验。当用户需要选择的时候，可以提供一个下拉列表将所有可选的项列出来，供用户选择。</p>
<p>21.Toast（提示）的使用，代码实现可参考实验报告或书本。</p>
<p>Toast.makeText(MultipleChoiceDialogBox.this,&ldquo;nihao&rdquo;,Toast.LENGTH_LONG).show();</p>
<p>22.Notification表示通知，是可以显示在Android系统通知栏上的一种数据的封装形，运用Notification可以提高应用的交互性，带来良好的用户感受。
关于Notification，主要涉及到Notification类与NotificationManager类的使用。
Notification类的实例表示在通知栏显示的一个通知，该通知内容包括该通知的ID、时间、内容、标题、图标等。
NotificationManager实例用来将该通知发送到系统的通知栏上。</p>
<p>23.本地服务（Local Service）用于应用程序内部，可以实现应用程序自己的一些耗时任务，比如查询升级信息、网络传输，或者在一些场合需要在后台执行，比如播放音乐，并不占用应用程序比如Activity所属的线程，而是单开线程后台执行，这样用户体验比较好。</p>
<p>Service的两种启动方式
(1)通过bindService绑定：
绑定时，bindService -&gt; onCreate() –&gt; onBind()；
解绑定：unbindService –&gt;onUnbind() –&gt; onDestory()；
此时如果调用者（如Activity）直接退出，Service 由于与调用者绑定在一起，则Service随着调用者一同停止。</p>
<p>（2）通过startService绑定：
启动时，startService –&gt; onCreate() –&gt; onStart()；
停止时，stopService –&gt; onDestroy()；
此时，服务与调用者（如Activity）没有绝对关联，当调用者关闭后服务还会一直在后台运行。
服务的生命周期</p>
<p>23.在Android里面有各式各样的广播，比如：电池的状态变化、信号的强弱状态、电话的接听和短信的接收等等，本节将会介绍系统发送、监听这些广播的机制。</p>
<p>两种广播注册方法的区别
第一种不是常驻型广播，也就是说广播跟随程序的生命周期
第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播过来，程序广播接收器也会被系统调用自动运行</p>
<p>25.作为一个完整的应用程序，数据的存储与操作是必不可少的。Android系统为我们提供了四种数据存储方式，分别是：Shared Preference、SQLite、File和ContentProvider。
SharedPreference：一种常用的数据存储方式，其本质就是基于xml文件存储键值对（key-value）数据，通常用来存储一些简单的配置信息。</p>
<p>SQLite：一个轻量级的数据库，支持基本SQL语法，是Android系统中常被采用的一种数据存储方式。Android为此数据库提供了一个名为SQLiteDatabase的类，封装了一些操作数据库的API。
文件储存：即常说的文件（I/O）存储方法，常用于存储数量比较大的数据，但缺点是更新数据将是一件困难的事情。
ContentProvider：它是Android系统中能实现应用程序之间数据共享的一种存储方式。由于Android系统中，数据基本都是私有的，存放于“data/data/程序包名（package name）”目录下，所以要实现数据共享，正确方式是使用ContentProvider。由于数据通常在各应用间是私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。如果应用程序有数据需要共享时，就需要使用ContentProvider为这些数据定义一个URI（包装成Uri对象），然后其他的应用程序就通过ContentResolver传入这个URI来对数据进行操作。</p>
<p>26.SharedPreferences对象的常用方法有以下几种：</p>
<p>27.Sqlite数据库的使用涉及到两个类：SQLiteDataBase和SQLiteOpenHelper</p>
<p>SQLiteDatabase具体方法：</p>
<p>SQLiteOpenHelper 具体方法</p>
<p>例：要得到一个可写数据库，首先创建一个类继承 SQLiteOpenHelper，重写 onCreate()方法并在该方法中创建表，然后使用创建出的 SQLiteOpenHelper 的子类对象的 getWritableDatabase()方法获得一个可读写的数据库对象。</p>
<p>28.网络状态</p>
<p>29.JSON数据解析
是一种轻量级的数据交换格式，它基于纯文本，采用完全独立于语言的文本格式来存储和传输数据。在编程环境中解析JSON数据意味着将JSON字符串转换为程序可以理解并操作的数据结构
JSON Object：JSON中对象(Object)以“{”开始, 以“}”结束。对象中的每一个item都是一个键值对，表现为“key:value”的形式, 键值对之间使用逗号分隔。如下代码所示：
{
&ldquo;name&rdquo;：&ldquo;coolxing&rdquo;，
&ldquo;age&rdquo;：24，
&ldquo;male&rdquo;：true，
&ldquo;address&rdquo;：{
&ldquo;street&rdquo;:&ldquo;huiLongGuan&rdquo;，
&ldquo;city&rdquo;:&ldquo;beijing&rdquo;，
&ldquo;country&rdquo;:&ldquo;china&rdquo;
}
}</p>
<p>JSONArray: JSON数组(Array)以&quot;[&ldquo;开始, 以&rdquo;]&ldquo;结束, 数组中的每一个元素可以是String,Number, Boolean, null, Object对象甚至是Array数组, 数组间的元素使用逗号分隔,如下代码所示：
[
&ldquo;coolxing&rdquo;, 24，
{
&ldquo;street&rdquo;:&ldquo;huiLongGuan&rdquo;，
&ldquo;city&rdquo;:&ldquo;beijing&rdquo;，
&ldquo;country&rdquo;:&ldquo;china&rdquo;
}
]</p>
<p>30.Webview
WebView 加载页面主要调用三个方法：LoadUrl、LoadData、LoadDataWithBaseURL.
LoadUrl  直接加载网页、图片并显示。
LoadData 显示文字与图片内容。(模拟器1.5、1.6)。
LoadDataWithBase 显示文字与图片内容 (支持多个模拟器版本)。
使用webview的websetting来设置，WebSetting websetting = webView.getSettings().
Websetting常用方法：</p>
<p>31.进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元。
通俗地讲一个进程代表一个应用程序，该应用程序运行在自己的进程当中，使用系统为其分配的堆内存，不受其他应用程序或者是其他进程的影响，是独立运行的。当然一个进程中可以同时运行多个应用程序，这时堆内存是共享的。</p>
<p>Android系统为每个应用程序分配了一个进程，应用程序中组件（Activity，Service，BroadCast）的状态决定的一个进程的“重要性层次”，层次最低的属于旧进程。这个“重要性层次”有五个等级，也就是进程的生命周期，按最高层次到最低层次排列如下：
（1）前台进程
（2）可视进程
（3）服务进程
（4）背景进程
（5）空进程</p>
<p>一个Android应用只能存在一个进程，但是可以存在多个线程，也就是说，当应用启动后，系统分配了内存，这个进程的内存不被其他进程使用，但被进程中一个或多个线程共享。宏观地讲所有的进程是并发执行的，而进程中的多个线程同时执行但并不是并发的，系统的CPU会根据应用的线程数触发每个线程执行的时刻，当CPU时间轮到分配某个线程执行时刻时该线程开始执行，执行到下一个线程执行的时，依此轮询，直到线程执行结束。
在理解启动模式前，理解几个概念</p>
<ol>
<li>任务
用户尝试在您的应用中执行操作时与之互动的一系列 activity。这些 activity 按照每个 activity 的打开顺序排列在称为“返回堆栈”的堆栈中，也称为任务栈。</li>
<li>Activity：简单理解就是页面，下面介绍启动模式的时候我们都把它理解为“页面”；</li>
<li>Intent：教材一般叫意图，简单理解它就是带操作的信息，像指令一样，接收到Intent就类似接收到指令一样。</li>
<li>一个应用可以有多个任务栈，在考虑一个应用一个任务栈的情况下，两个页面如果在不同应用程序，那么在启动这两个页面的时候，他们会被压入各自的任务栈，所以两个不同应用程序的各自页面一般不会出现在同一个任务栈中；</li>
<li>onNewIntent() 方法的作用主要是允许已存在的 Activity 更新其状态以响应新的 Intent 数据。例如，在接收动态广播（如地理位置更新、消息通知等）或重新加载内容时，无需重启 Activity 就可以处理新的数据。开发者需要重写这个方法并在其中处理接收到的新 Intent 数据。</li>
</ol>
<p>四种启动模式：</p>
<p><strong>标准模式（standard）</strong></p>
<p>默认启动模式，如果任务栈中没有Activity则会实例化一个新的Activity，并将其压入当前任务栈的顶部。
如果同一个Activity已经存在栈顶，那么新的实例仍然会被创建并压入栈中，因此栈中可能包含多个该Activity实例。</p>
<p><strong>单例模式（singleTop）</strong></p>
<p>当一个新的Intent要启动已位于栈顶的Activity（与请求的Intent匹配的Activity）时，系统不会创建新的Activity实例，而是将intent通过onNewIntent()方法传递给现有的Activity实例；</p>
<ul>
<li>如果目标Activity不在栈顶，则会正常创建新的实例；</li>
<li>如果目标Activity不在栈顶而在栈顶的下一层呢？
比如现在有A-B-C-D,D在栈顶，如果传来的Intent是要打开页面C，在单例模式下也是正常创建；</li>
</ul>
<p>总结：</p>
<p>在单例模式下，</p>
<ul>
<li>如果页面不存在，也就是要打开的Activity没有在任务栈中实例化，那么正常创建Activity实例，并压入栈中；</li>
<li>如果Activity已经存在于任务栈中，且为栈顶，那么系统不创建新的Activity实例，而是将intent通过onNewIntent()方法传递给现有的Activity实例，</li>
<li>如果不是栈顶，正常创建Activity实例。</li>
</ul>
<p><strong>栈内复用模式（singleTask）</strong></p>
<p>当打开一个页面，也就是启动一个Activity时，系统首先会在整个任务栈中查找这个Activity是否已经在栈中，</p>
<ul>
<li>情况一：如果存在并且处于栈底，则直接把该Activity之上的所有Activity弹出栈，使这个Activity置于栈顶并调用其onNewIntent()。</li>
<li>情况二：如果在栈顶，则将intent通过onNewIntent()方法传递给现有的Activity实例</li>
</ul>
<p>如果不存在已有的Activity实例，才会创建新的实例并放入栈顶。这种模式下的Activity始终只有一个实例存在于任务栈中。</p>
<p><strong>单实例模式（singleInstance）</strong></p>
<p>当启动Activity时，系统会为它创建一个新的任务栈，然后在这个新的栈顶放上这个Activity的实例。
如果再次启动这个Activity，即使是在另一个任务栈中，系统也不会创建新实例，而是将意图传递给已经存在的Activity实例。</p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年1月11日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/f1-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">F1-复习资料</a></li>
    <li><a class="term-link" href="/categories/z-%E4%B8%93%E4%B8%9A%E8%AF%BE/">Z-专业课</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E5%AE%89%E5%8D%93/">安卓</a></li>
  </ul>
</div>
  </header>

<h1 id="androidstudio笔记">AndroidStudio笔记</h1>

<p>这篇文章主要介绍AndroidStudio的使用，以及一些Android开发的基础知识。以及一些开发中遇到的问题和解决方法，除此之外，还会介绍一些开发中常用的工具和技巧。</p>
<h2 id="第一章">第一章</h2>
<h3 id="配置开发环境">配置开发环境</h3>
<ul>
<li>1.<strong>安装JDK</strong>
<a href="https://www.bilibili.com/video/BV1tE411V7xA/" rel="external" target="_blank">&ldquo;安装连接&rdquo;</a></li>
<li>2.<strong>安装AndroidStudio</strong>
<a href="https://www.bilibili.com/video/BV11z4y1x7Dh/" rel="external" target="_blank">&ldquo;安装连接&rdquo;</a></li>
<li>3.<strong>安装SDK</strong></li>
<li>4.<strong>AndroidStudio汉化</strong></li>
<li><a href="https://www.bilibili.com/video/BV1Hz4y1K7Tc/" rel="external" target="_blank">https://www.bilibili.com/video/BV1Hz4y1K7Tc/</a></li>
</ul>
<h2 id="第二章">第二章</h2>
<p>Gradle():自动构建
日志输出工具：查看报错
Run（运行）</p>
<p>工程结构：
（清单文件）：对Activity，service，re广播等进行注册的文件
Java目录：
后缀为 <strong>.class</strong>
drawable目录：资源文件，放图片、图标、背景资源的文件
Layout目录：放页面布局文件
放图片和.xml文件，适配不同分辨率的文件夹
values目录：颜色、数组、字符串、样式</p>
<h2 id="android基本原理">Android基本原理</h2>
<h3 id="android体系结构">Android体系结构</h3>
<h3 id="android-用用程序核心组件">Android 用用程序核心组件</h3>
<h4 id="activity">Activity</h4>
<h2 id="第四章-activityfragment以及intent通信机制">第四章 Activity、Fragment以及Intent通信机制</h2>
<h3 id="activity生命周期">Activity生命周期</h3>
<p>四种状态的转换</p>
<p>布局的特点：</p>
<h2 id="第八章-数据存储和提供器">第八章 数据存储和提供器</h2>
<h3 id="sharedpreference">SharedPreference</h3>
<p>使用键值对关系来获取文件</p>
<h3 id="sqlite">SQLite</h3>
<p>轻量级占用内存小，支持基本的MySQL语言。
创建过程：</p>
<h3 id="contentpreference应用存储">ContentPreference（应用存储）</h3>
<p>通过暴露URL让软件之间可以共享文件
好比一般使用文件时，软件会要求需要访问你手机文件权限。</p>
<h3 id="文件存储">文件存储</h3>
<h2 id="网络通信编程">网络通信编程</h2>
<h3 id="网络访问方式">网络访问方式</h3>
<p>网络状态码，例如404表示什么？</p>
<h3 id="数据解析">数据解析</h3>
<p>1.JSON格式解析：
以类对象的方式进行相应，以数组的方式进行相应，也可以二者混合。</p>
<h3 id="网络状态">网络状态</h3>
<h3 id="javascript与java交互">JavaScript与Java交互</h3>
<p>webView的使用</p>
<p>在简单的使用webview过程中可能无法进入指定的网页，而且AndroidStudio模拟机上还会弹出如下错误：</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>    <span style="font-weight:bold">**Webpage not available**</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    The webpage at http://www.baidu.comi could not beloaded because:
</span></span><span style="display:flex;"><span>    net::ERR_CLEARTEXT_NOT_PERMITTED</span></span></code></pre></div>
<p>解决的办法：
请在<strong>AndroidManifest.xml</strong>文件下添加代码：
<div class="tab-panel" data-tab-group="cb426595f61afe9b628b368a3219ca17">
  <div class="tab-nav">
    <div class="tab-nav-title">.xml文件</div>
    <button
      data-tab-item="添加代码fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('cb426595f61afe9b628b368a3219ca17','添加代码fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 添加代码</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="添加代码fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>    <span style="color:#f92672">&lt;uses-permission</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;android.permission.INTERNET&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;uses-permission</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;android.permission.ACCESS_NETWORK_STATE&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;uses-permission</span> <span style="color:#a6e22e">android:name=</span><span style="color:#e6db74">&#34;android.permission.ACCESS_WIFI_STATE&#34;</span> <span style="color:#f92672">/&gt;</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div></p>
<p>如果添加上面的还不可以，请在<strong>manifest</strong>中添加如下代码：</p>
<div class="tab-panel" data-tab-group="dcff4ab32a57c03b13cdc59a466d9a10">
  <div class="tab-nav">
    <div class="tab-nav-title">.xml文件</div>
    <button
      data-tab-item="添加代码fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('dcff4ab32a57c03b13cdc59a466d9a10','添加代码fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 添加代码</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="添加代码fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;manifest</span> <span style="color:#960050;background-color:#1e0010">...</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;application</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">...</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:usesCleartextTraffic=</span><span style="color:#e6db74">&#34;true&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;/application&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/manifest&gt;</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<p><a href="https://blog.csdn.net/zgd826237710/article/details/95520785/" rel="external" target="_blank">&ldquo;原文章链接&rdquo;</a></p>
<p>getwebSetting</p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2023年12月20日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/b2-%E7%AC%94%E8%AE%B0/">B2-笔记</a></li>
    <li><a class="term-link" href="/categories/z-%E4%B8%93%E4%B8%9A%E8%AF%BE/">Z-专业课</a></li>
  </ul>
</div>
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/ui%E8%AE%BE%E8%AE%A1/">UI设计</a></li>
    <li><a class="term-link" href="/tags/%E5%AE%89%E5%8D%93/">安卓</a></li>
  </ul>
</div>
  </header>

<h1 id="2-1toolbar工具栏">2-1.Toolbar工具栏</h1>

<h2 id="menu文件的创建">menu文件的创建</h2>
<p>在创建<strong>menu</strong>这个目录前，请看查看<strong>res/<strong>目录下是否包含该目录，如果没有则创建。
接着在该目录下创建</strong>xml</strong>文件，此处文件名为<strong>content_menu</strong>。在该<strong>content_menu</strong>使用<code>&lt;item</code>,如下为部分代码：
<div class="tab-panel" data-tab-group="5bd2b2a78205cd14074ae1b2127f7ec1">
  <div class="tab-nav">
    <div class="tab-nav-title">.xml文件</div>
    <button
      data-tab-item="简码fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('5bd2b2a78205cd14074ae1b2127f7ec1','简码fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 简码</span>
    </button>
    <button
      data-tab-item="全码"
      class="tab-nav-button tab-panel-style cstyle default" style="--VARIABLE-BOX-color: green ;"
      onclick="switchTab('5bd2b2a78205cd14074ae1b2127f7ec1','全码')"
    >
      <span class="tab-nav-text">全码</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="简码fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>    <span style="color:#f92672">&lt;item</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/content_menu_group_chat&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:title=</span><span style="color:#e6db74">&#34;发起群聊&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:orderInCategory=</span><span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/&gt;</span></span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="全码"
      class="tab-content tab-panel-style cstyle default" style="--VARIABLE-BOX-color: green ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;menu</span> <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;item</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/content_menu_group_chat&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:title=</span><span style="color:#e6db74">&#34;发起群聊&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:orderInCategory=</span><span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;item</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/content_menu_add_friend&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:title=</span><span style="color:#e6db74">&#34;添加朋友&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:orderInCategory=</span><span style="color:#e6db74">&#34;2&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;item</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/content_menu_add_RichScan&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:title=</span><span style="color:#e6db74">&#34;扫一扫&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:orderInCategory=</span><span style="color:#e6db74">&#34;3&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;item</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/content_menu_add_QRcode&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:title=</span><span style="color:#e6db74">&#34;扫码&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:orderInCategory=</span><span style="color:#e6db74">&#34;4&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/menu&gt;</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
在代码中<strong>orderInCategory</strong>属性是用来控制该<strong>item</strong>权重的，权重越小等级越高，该标题就会靠前显示，

<details open class=" box cstyle notices secondary">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-eye"></i> 
    结果
  </summary>
  <div class="box-content">
<p><a href="#R-image-7f21c0c28e805e888798f9c49d5fc670" class="lightbox-link"><img alt="8899" class="border lazy lightbox shadow figure-image" loading="lazy" src="/class/2.androidstudio/toolbar/img1_item.jpg?classes=shadow,border&height=250px&width=15vw" style=" height: 250px; width: 15vw;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-7f21c0c28e805e888798f9c49d5fc670"><img alt="8899" class="border lazy lightbox shadow lightbox-image" loading="lazy" src="/class/2.androidstudio/toolbar/img1_item.jpg?classes=shadow,border&height=250px&width=15vw"></a></p>
  </div>
</details></p>
<h2 id="创建布局页面">创建布局页面</h2>
<p>详细代码如下：
<div class="tab-panel" data-tab-group="859b23ce93a8eda89af4df2c8123d0ff">
  <div class="tab-nav">
    <div class="tab-nav-title">.xml文件</div>
    <button
      data-tab-item="简码fa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('859b23ce93a8eda89af4df2c8123d0ff','简码fa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> 简码</span>
    </button>
    <button
      data-tab-item="全码"
      class="tab-nav-button tab-panel-style cstyle default" style="--VARIABLE-BOX-color: green ;"
      onclick="switchTab('859b23ce93a8eda89af4df2c8123d0ff','全码')"
    >
      <span class="tab-nav-text">全码</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="简码fa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;androidx.appcompat.widget.Toolbar</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/options_menu_toolbar&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;409dp&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;?attr/colorPrimary&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:minHeight=</span><span style="color:#e6db74">&#34;?attr/actionBarSize&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">android:theme=</span><span style="color:#e6db74">&#34;?attr/actionBarTheme&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">app:layout_constraintLeft_toLeftOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">app:layout_constraintRight_toRightOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;parent&#34;</span> <span style="color:#f92672">/&gt;</span></span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="全码"
      class="tab-content tab-panel-style cstyle default" style="--VARIABLE-BOX-color: green ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;androidx.constraintlayout.widget.ConstraintLayout</span> <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:app=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res-auto&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xmlns:tools=</span><span style="color:#e6db74">&#34;http://schemas.android.com/tools&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;androidx.appcompat.widget.Toolbar</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/options_menu_toolbar&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;409dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;wrap_content&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:background=</span><span style="color:#e6db74">&#34;?attr/colorPrimary&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:minHeight=</span><span style="color:#e6db74">&#34;?attr/actionBarSize&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:theme=</span><span style="color:#e6db74">&#34;?attr/actionBarTheme&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintLeft_toLeftOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintRight_toRightOf=</span><span style="color:#e6db74">&#34;parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:layout_constraintTop_toTopOf=</span><span style="color:#e6db74">&#34;parent&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span></span></span></code></pre></div>
      </div>
    </div>
  </div>
</div></p>
<h2 id="activityjava文件中">Activity.java<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>文件中</h2>
<p>此处创建类的步骤，继承<code>AppCompatActivity</code>方法就不再赘述。</p>
<ol>
<li>在<code>onCreate</code>获取<strong>Toolbar</strong>的id，这个过程也叫实例化；</li>
<li>接着使用方法<code>setSupportActionBar</code>;</li>
<li>在onCreate外重写<code>onCreateOptionsMenu</code>和<code>onOptionsItemSelected</code>方法。</li>
</ol>
<div class="tab-panel" data-tab-group="a5426f7b01515862151eb03c5fec235b">
  <div class="tab-nav">
    <div class="tab-nav-title">.java文件</div>
    <button
      data-tab-item="oncreatefa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;" tabindex="-1"
      onclick="switchTab('a5426f7b01515862151eb03c5fec235b','oncreatefa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> onCreate</span>
    </button>
    <button
      data-tab-item="oncreateoptionsmenufa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue ;"
      onclick="switchTab('a5426f7b01515862151eb03c5fec235b','oncreateoptionsmenufa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> onCreateOptionsMenu</span>
    </button>
    <button
      data-tab-item="onoptionsitemselectedfa-fw-fas-fa-info-circle"
      class="tab-nav-button tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue ;"
      onclick="switchTab('a5426f7b01515862151eb03c5fec235b','onoptionsitemselectedfa-fw-fas-fa-info-circle')"
    >
      <span class="tab-nav-text"><i class="fa-fw fas fa-info-circle"></i> onOptionsItemSelected</span>
    </button>
    <button
      data-tab-item="全码"
      class="tab-nav-button tab-panel-style cstyle default" style="--VARIABLE-BOX-color: green ;"
      onclick="switchTab('a5426f7b01515862151eb03c5fec235b','全码')"
    >
      <span class="tab-nav-text">全码</span>
    </button>
  </div>
  <div class="tab-content-container">
    <div
      data-tab-item="oncreatefa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info active" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@SuppressLint</span>(<span style="color:#e6db74">&#34;MissingInflatedId&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onCreate</span>(<span style="color:#a6e22e">@Nullable</span> Bundle savedInstanceState) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onCreate</span>(savedInstanceState);
</span></span><span style="display:flex;"><span>        setContentView(R.<span style="color:#a6e22e">layout</span>.<span style="color:#a6e22e">opetions_menu</span>);
</span></span><span style="display:flex;"><span>        toolbar <span style="color:#f92672">=</span> findViewById(R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">options_menu_toolbar</span>);
</span></span><span style="display:flex;"><span>        setSupportActionBar(toolbar);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="oncreateoptionsmenufa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onCreateOptionsMenu</span>(Menu menu) {
</span></span><span style="display:flex;"><span>        getMenuInflater().<span style="color:#a6e22e">inflate</span>(R.<span style="color:#a6e22e">menu</span>.<span style="color:#a6e22e">content_menu</span>,menu);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onCreateOptionsMenu</span>(menu);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="onoptionsitemselectedfa-fw-fas-fa-info-circle"
      class="tab-content tab-panel-style cstyle info" style="--VARIABLE-BOX-color: blue ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onOptionsItemSelected</span>(<span style="color:#a6e22e">@NonNull</span> MenuItem item) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//获取menu目录中content_menu.xml文件里item的id</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> item.<span style="color:#a6e22e">getItemId</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//判断id是否被点击，被点击就执行相应的动作，比如页面跳转</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(id <span style="color:#f92672">==</span> R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">content_menu_add_friend</span>){
</span></span><span style="display:flex;"><span>            Intent intent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Intent(OpetionsMenu.<span style="color:#a6e22e">this</span>,ListDialogActivity.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>            startActivity(intent);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(id <span style="color:#f92672">==</span> R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">content_menu_group_chat</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>  <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onContextItemSelected</span>(item);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
      </div>
    </div>
    <div
      data-tab-item="全码"
      class="tab-content tab-panel-style cstyle default" style="--VARIABLE-BOX-color: green ;">
      <div class="tab-content-text">
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">package</span> com.example.practiceapplication;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.annotation.SuppressLint;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.content.Intent;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.os.Bundle;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.view.Menu;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> android.view.MenuItem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.annotation.NonNull;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.annotation.Nullable;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.appcompat.app.AppCompatActivity;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> androidx.appcompat.widget.Toolbar;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OpetionsMenu</span> <span style="color:#66d9ef">extends</span> AppCompatActivity {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Toolbar toolbar;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@SuppressLint</span>(<span style="color:#e6db74">&#34;MissingInflatedId&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onCreate</span>(<span style="color:#a6e22e">@Nullable</span> Bundle savedInstanceState) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onCreate</span>(savedInstanceState);
</span></span><span style="display:flex;"><span>        setContentView(R.<span style="color:#a6e22e">layout</span>.<span style="color:#a6e22e">opetions_menu</span>);
</span></span><span style="display:flex;"><span>        toolbar <span style="color:#f92672">=</span> findViewById(R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">options_menu_toolbar</span>);
</span></span><span style="display:flex;"><span>        setSupportActionBar(toolbar);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onCreateOptionsMenu</span>(Menu menu) {
</span></span><span style="display:flex;"><span>        getMenuInflater().<span style="color:#a6e22e">inflate</span>(R.<span style="color:#a6e22e">menu</span>.<span style="color:#a6e22e">content_menu</span>,menu);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onCreateOptionsMenu</span>(menu);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onOptionsItemSelected</span>(<span style="color:#a6e22e">@NonNull</span> MenuItem item) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> item.<span style="color:#a6e22e">getItemId</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(id <span style="color:#f92672">==</span> R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">content_menu_add_friend</span>){
</span></span><span style="display:flex;"><span>            Intent intent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Intent(OpetionsMenu.<span style="color:#a6e22e">this</span>,ListDialogActivity.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>            startActivity(intent);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(id <span style="color:#f92672">==</span> R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">content_menu_group_chat</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>  <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">onContextItemSelected</span>(item);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
      </div>
    </div>
  </div>
</div>
<h2 id="最终结果">最终结果</h2>

<details open class=" box cstyle notices secondary">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-eye"></i> 
    结果
  </summary>
  <div class="box-content">
<p><a href="#R-image-87a5340d9ada50e70afa53451a7ff31c" class="lightbox-link"><img alt="8899" class="border lazy lightbox shadow figure-image" loading="lazy" src="/class/2.androidstudio/toolbar/abc.jpg?classes=shadow,border&height=250px&width=15vw" style=" height: 250px; width: 15vw;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-87a5340d9ada50e70afa53451a7ff31c"><img alt="8899" class="border lazy lightbox shadow lightbox-image" loading="lazy" src="/class/2.androidstudio/toolbar/abc.jpg?classes=shadow,border&height=250px&width=15vw"></a></p>
  </div>
</details>

<details class=" box cstyle notices transparent expand">
  <summary class="box-label">
    <i class="expander-icon fa-fw fas fa-chevron-right"></i> 
    展开
  </summary>
  <div class="box-content">
<p>
详细知识等我更新……
  </div>
</details>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Activity.java这个文件的一般就是我们所说的主程序，类似与C语言中的包含main入口的文件。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-user'></i> <a href="mailto:1642424079@example.com">Maloudown</a>
              <i class='fa-fw fas fa-calendar'></i> 2023年11月29日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/b3-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">B3-课堂笔记</a></li>
    <li><a class="term-link" href="/categories/z-%E4%B8%93%E4%B8%9A%E8%AF%BE/">Z-专业课</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Linux操作系统</a></li>
    <li><a class="term-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li>
    <li><a class="term-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></li>
  </ul>
</div>
  </header>

<h1 id="计算机组成原理">计算机组成原理</h1>

<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%87%E5%B9%B4/">过年</a><p><ul class="children children-li children-sort-">
</ul></p></li>
  <li class="children-title"><a href="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/">计算机组成原理-复习</a><p><h2 id="1-计算机系统概论">1 计算机系统概论</h2>
<h3 id="计算机的分类">计算机的分类</h3>
<p>计算机总体上分为：电子模拟计算机<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>和电子数字计算机。二者区别如下表</p>
<table>
  <thead>
      <tr>
          <th>比较内容</th>
          <th>电子数字计算机</th>
          <th>电子模拟计算机</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>数据表示方法</td>
          <td>0或1</td>
          <td>电压</td>
      </tr>
      <tr>
          <td>计算方式</td>
          <td>数字计算</td>
          <td>电压组合和测量值</td>
      </tr>
      <tr>
          <td>控制方式</td>
          <td>程序控制</td>
          <td>盘上连线</td>
      </tr>
      <tr>
          <td>精度</td>
          <td>高</td>
          <td>低</td>
      </tr>
      <tr>
          <td>数据存储量</td>
          <td>大</td>
          <td>小</td>
      </tr>
      <tr>
          <td>逻辑计算能力</td>
          <td>强</td>
          <td>无</td>
      </tr>
  </tbody>
</table>
<h3 id="计算机的五代变化">计算机的五代变化</h3>
<ul>
<li>第一代1946~1957年， <strong>数据处理</strong> 得到应用；</li>
<li>第二代1958~1964年， <strong>工业控制</strong> 开始得到应用；</li>
<li>第三代1965~1971年， <strong>小型计算机</strong>开始出现；</li>
<li>第四代1972~1990年， <strong>微型计算机</strong> 开始出现；</li>
<li>第五代1991年开始， <strong>单片机</strong> 开始出现</li>
</ul>
<h3 id="计算机的性能指标">计算机的性能指标</h3>
<p><strong>处理机字长</strong> 指处理机运算其中一次能工处理的二进制数运算的位数，例如32位，64位。
<strong>存储器带宽</strong> 单位时间内从存储器独处的二进制数信息量，一般用 <strong>字节数/秒</strong>表示。</p></p></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年1月10日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/">核心课程</a></li>
  </ul>
</div>
  </footer>
</article>
          <section>
            <h1 class="a11y-only">计算机组成原理 的子部分</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="过年">过年</h1>

<ul class="children children-li children-sort-">
</ul>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/r-%E8%BD%AF%E7%A1%AC%E4%BB%B6/">R-软硬件</a></li>
  </ul>
</div>
  </header>

<h1 id="计算机组成原理-复习">计算机组成原理-复习</h1>

<h2 id="1-计算机系统概论">1 计算机系统概论</h2>
<h3 id="计算机的分类">计算机的分类</h3>
<p>计算机总体上分为：电子模拟计算机<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>和电子数字计算机。二者区别如下表</p>
<table>
  <thead>
      <tr>
          <th>比较内容</th>
          <th>电子数字计算机</th>
          <th>电子模拟计算机</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>数据表示方法</td>
          <td>0或1</td>
          <td>电压</td>
      </tr>
      <tr>
          <td>计算方式</td>
          <td>数字计算</td>
          <td>电压组合和测量值</td>
      </tr>
      <tr>
          <td>控制方式</td>
          <td>程序控制</td>
          <td>盘上连线</td>
      </tr>
      <tr>
          <td>精度</td>
          <td>高</td>
          <td>低</td>
      </tr>
      <tr>
          <td>数据存储量</td>
          <td>大</td>
          <td>小</td>
      </tr>
      <tr>
          <td>逻辑计算能力</td>
          <td>强</td>
          <td>无</td>
      </tr>
  </tbody>
</table>
<h3 id="计算机的五代变化">计算机的五代变化</h3>
<ul>
<li>第一代1946~1957年， <strong>数据处理</strong> 得到应用；</li>
<li>第二代1958~1964年， <strong>工业控制</strong> 开始得到应用；</li>
<li>第三代1965~1971年， <strong>小型计算机</strong>开始出现；</li>
<li>第四代1972~1990年， <strong>微型计算机</strong> 开始出现；</li>
<li>第五代1991年开始， <strong>单片机</strong> 开始出现</li>
</ul>
<h3 id="计算机的性能指标">计算机的性能指标</h3>
<p><strong>处理机字长</strong> 指处理机运算其中一次能工处理的二进制数运算的位数，例如32位，64位。
<strong>存储器带宽</strong> 单位时间内从存储器独处的二进制数信息量，一般用 <strong>字节数/秒</strong>表示。</p>
<h2 id="2-运算方法和运算器">2 运算方法和运算器</h2>
<p><strong>注：</strong></p>
<ol>
<li>掌握各进制之间的转换；</li>
<li>掌握小数点之间的二进制与十进制之间的转换；</li>
</ol>
<h3 id="二进制纯小数或纯整数表示方法">二进制纯小数或纯整数表示方法</h3>
<ul>
<li>二进制纯小数： <strong>0.10101</strong> 或 <strong>1.10101</strong>，0或1表示正负号，在正负号后面，在实际中计算机并不存储小数点；</li>
<li>二进制纯整数： <strong>10101.</strong>，同样纯整数也用0或1区分正负号。
用Xn-1表示二进制数的个数，Xn表示符号位，如下：
<table>
  <thead>
      <tr>
          <th style="text-align: center">Xn</th>
          <th style="text-align: center">Xn-1……X0</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">符号</td>
          <td style="text-align: center">量值（尾数）</td>
      </tr>
  </tbody>
</table>
</li>
</ul>
<p>纯小数表示范围： <strong><span class="math align-center">$0<=|x|<=1-2^{-n} $</span></strong>
纯整数表示范围： <strong><span class="math align-center">$0<=|x|<=2^{-n} - 1$</span></strong></p>
<h3 id="浮点数表示方法">浮点数表示方法</h3>
<p>电子质量(克)： 9×10^28 = 0.9×10^27
太阳质量(克)： 2×10^33 = 0.2×10^34</p>
<p>任意十进制数 <strong>N</strong> 可以表示为：</p>
<span class="math align-center">$$N=10^E \cdot M$$</span>
<p>同样在二进制中也有这样类似的表达：</p>
<span class="math align-center">$$  N=2^e \cdot M$$ </span>
<p>在二进制浮点数表达中：</p>
<ul>
<li>尾数：M，是一个纯小数；</li>
<li>比例因子：e，表示指数，常用整数表示，也称为 <strong>阶码</strong> ；</li>
<li>基数：式子中的2</li>
</ul>
<p>二进制浮点数格式：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><span class="math align-center">$E_s$</span></th>
          <th style="text-align: center"><span class="math align-center">$E_m-1…E_1 E_0$</span></th>
          <th style="text-align: center"><span class="math align-center">$M_s$</span></th>
          <th style="text-align: center"><span class="math align-center">$M_m-1…M_1 M_0$</span></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">阶符</td>
          <td style="text-align: center">阶码</td>
          <td style="text-align: center">数符</td>
          <td style="text-align: center">尾数</td>
      </tr>
  </tbody>
</table>
<p><strong>IEEE754标准</strong>格式表示浮点数</p>
<p><strong>知识储备：</strong> <span class="math align-center">$\frac{1}{2^0}=1$</span>,<span class="math align-center">$\frac{1}{2^1}=0.5$</span>,<span class="math align-center">$\frac{1}{2^2}=0.25$</span>,<span class="math align-center">$\frac{1}{2^3}=0.125$</span>,<span class="math align-center">$\frac{1}{2^4}=0.0625$</span>,<span class="math align-center">$\frac{1}{2^5}=0.03125$</span></p>
<p>浮点数表示：</p>
<span class="math align-center">$$  N=2^e \cdot M$$ </span>
<p>浮点数所占位数：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><span class="math align-center">$S$</span></th>
          <th style="text-align: center"><span class="math align-center">$E$</span></th>
          <th style="text-align: center"><span class="math align-center">$M$</span></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><span class="math align-center">$31$</span></td>
          <td style="text-align: center"><span class="math align-center">$30 \gets 23$</span></td>
          <td style="text-align: center"><span class="math align-center">$22 \gets 0$</span></td>
      </tr>
  </tbody>
</table>
<ul>
<li>基数R=2，基数固定，采用隐含方式来表示它。</li>
<li>32位的浮点数：
<ul>
<li>S数的符号位，1位，在最高位，“0”表示正数，“1”表示负
数。</li>
<li>M是尾数， 23位，在低位部分，采用纯小数表示,不对小数点进行存储；</li>
<li>E是阶码，8位，也就是说阶码最大不超过255，但阶码采用移码表示<span class="math align-center">$E=2^{7}+e=127+e$</span>，原因是移码比较大小方便。</li>
<li>规格化： 若不对浮点数的表示作出明确规定，同一个浮点数的表示就不是惟一的，所以一般都会规定这个浮点数的位数
<ul>
<li>尾数域最左位(最高有效位)总是1， 故这一位经常不予存储，而认为隐藏在小数点的左边。</li>
<li>采用这种方式时，将浮点数的指数真值e变成阶码E时，应将指数e加上一个固定的偏移值127(01111111)，即E=e+127。如果是二进制转真值就E=e-127</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面举两个例子进行说明：</p>
<p><strong>例1：二进制转十进制</strong>若浮点数x的754标准存储格式为(41360000)16，求其浮点数的十进制数值。</p>
<p>解：将16进制数展开后，可得二制数格式为</p>
<p>0 100 00010 011 0110 0000 0000 0000 0000</p>
<p>符号S=0</p>
<p>阶码E=100 00010</p>
<p>尾数M=011 0110 0000 0000 0000 0000</p>
<p>指数e=E-127=10000010-01111111=00000011=<span class="math align-center">$(3)_10$</span>，故有</p>
<p>1.M=1.011 0110 0000 0000 0000 0000=1.011011</p>
<p>于是有</p>
<span class="math align-center">$x=(-1)S \times 1.M \times 2^e=+(1.011011)  \times 2^3=+1011.011=(11.375)_10$</span>
<p><strong>问：</strong> 0.011怎么转成0.375？</p>
<p>根据上面的知识储备有<span class="math align-center">$ \frac{1}{2^0}\times 0 + \frac{1}{2^1}\times 1 +\frac{1}{2^2}\times 1=0+0.25+0.125=0.375 $</span></p>
<p><strong>例2：十进制转二进制</strong>若浮点数为<span class="math align-center">$(28.8125)_10$</span>，求其浮点数的IEEE754标准存储格式的二进制数值。</p>
<p>解：<span class="math align-center">$(28.8125)_10$</span>=<span class="math align-center">$(11100.1101)_2$</span></p>
<p>格式化表示为：<span class="math align-center">$(11100.1101)_2=1.11001101 \times 2^4$</span></p>
<p>于是有</p>
<p>e=4</p>
<p>E=e+127=4+127=131=<span class="math align-center">$(1000 0011)_2$</span></p>
<p>M=1100 1101 0000 0000 0000 000（去掉小数点和小数点前的1，而且有23位，不够补0）</p>
<p>S=0</p>
<p>IEEE754标准的32为存储数据位：0 1000 0011 1100 1101 0000 0000 0000 000</p>
<h3 id="数的机器码表示">数的机器码表示</h3>
<p>计算机进行运算时，会把符号位和数字一起编码表示为相应的数，这些数可以用不同的方法表示，例如：原码、补码、移码、反码；</p>
<p>为了区别一般写的数（比如-12，+3等）和机器中的编码（比如 <em><strong>0</strong></em> 1100,<strong>1</strong> 0011），通常前者称之为 <strong>真值</strong>，后者称为 <strong>机器数</strong> 或 <strong>机器码</strong> 。</p>
<p><span class="math align-center">$[x]_原$</span>表示机器数，x表示真值。</p>
<p>例如：</p>
<p><span class="math align-center">$x=+0011$</span>，<span class="math align-center">$[x]{_原}=\textbf{0}0011$</span></p>
<p><span class="math align-center">$x=-0011$</span>，<span class="math align-center">$[x]{_原}=\textbf{1}0011$</span>，</p>
<p>原码机器中有“+0”“-0”之分，固有两种形式：例如：<span class="math align-center">$[x]{_原}$</span>与<span class="math align-center">$\textbf{1}0011$</span>表达的意思一样。</p>
<p>数学上把类似于<span class="math align-center">$-3=+9 (mod12)$</span>的式成为 <strong>同余式</strong>。</p>
<h4 id="原码反码补码移码">原码、反码、补码、移码</h4>
<p>对原码、反码、补码、移码的简单说明，已知计算机为4位，x=-3.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">例子</th>
          <th style="text-align: center">表示方法</th>
          <th style="text-align: center">二进制</th>
          <th style="text-align: center">说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">-3</td>
          <td style="text-align: center">原码</td>
          <td style="text-align: center"><span class="math align-center">$[-3]{_原}$</span>=<strong>0</strong>0011</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">-3</td>
          <td style="text-align: center">反码</td>
          <td style="text-align: center"><span class="math align-center">$[-3]{_反}$</span>=<strong>0</strong>1100</td>
          <td style="text-align: center">按位取反</td>
      </tr>
      <tr>
          <td style="text-align: center">-3</td>
          <td style="text-align: center">补码</td>
          <td style="text-align: center"><span class="math align-center">$[-3]{_补}$</span>=<strong>0</strong>1101</td>
          <td style="text-align: center">反码最低位加1，注意这个时候符号还是1</td>
      </tr>
      <tr>
          <td style="text-align: center">-3</td>
          <td style="text-align: center">移码</td>
          <td style="text-align: center"><span class="math align-center">$[-3]{_移}$</span>=<strong>1</strong>,1101</td>
          <td style="text-align: center"><span class="math align-center">$[e]{_移}=2^{k}+e=2^4-0011=0,1101$</span></td>
      </tr>
  </tbody>
</table>
<p>对于正数来说，前三个都一样，重点说明移码：</p>
<p>定点整数定义 <span class="math align-center">$[e]{_移}=2^{k}+e,  2^k >e≥-2^k$</span></p>
<p>上面的表达式中，<span class="math align-center">$[e]{_移}$</span>表示机器码，e为真值，<span class="math align-center">$2^k$</span>表示固定偏移常量。</p>
<p>已知e=+0011,k=4，<span class="math align-center">$[e]{_移}=2^{k}+e=2^{4}+0011=1,0011$</span></p>
<p>已知e=-0011,k=4，<span class="math align-center">$[e]{_移}=2^{k}+e=2^{4}-0011=0,1101$</span></p>
<p>移码中的逗号不是小数点，而是表示左边一位是符号位，显然移码中符号位与前三者的表示相反（<strong>详见P21</strong>）。</p>
<p>下面请看例题：</p>
<p>已知计算机是8位的，请分别写出纯整数125，-110，纯小数+0.125，-0.375；二进制数x=11011,y=-01010的原码、反码、补码、移码。（注意格式，要对齐）</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">表示方法</th>
          <th style="text-align: center"></th>
          <th style="text-align: center">表示方法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">+125=<strong>0</strong>0101 1111</td>
          <td style="text-align: center"></td>
          <td style="text-align: center">-110=<strong>1</strong>0011 1011</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_原}$</span>=<strong>0</strong>0101 1111</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_原}$</span>=<strong>1</strong>0011 1011</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_反}$</span>=<strong>0</strong>0101 1111</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_反}$</span>=<strong>1</strong>1100 0100</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_补}$</span>=<strong>0</strong>0101 1111</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_补}$</span>=<strong>1</strong>1100 0101</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_移}$</span>=<strong>1</strong>,0101 1111</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_移}$</span>=<strong>0</strong>,1100 0100</td>
      </tr>
      <tr>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">+0.125=<strong>0</strong>.0010 0000</td>
          <td style="text-align: center"></td>
          <td style="text-align: center">-0.357=<strong>1</strong>.0110 0000</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_原}$</span>=<strong>0</strong>.0010 0000</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_原}$</span>=<strong>1</strong>.0110 0000</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_反}$</span>=<strong>0</strong>.0010 0000</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_反}$</span>=<strong>1</strong>.1001 1111</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_补}$</span>=<strong>0</strong>.0010 0000</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_补}$</span>=<strong>1</strong>.1010 0000</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_移}$</span>=<strong>1</strong>,0010 0000</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_移}$</span>=<strong>0</strong>,1010 0000</td>
      </tr>
      <tr>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">x=11011</td>
          <td style="text-align: center"></td>
          <td style="text-align: center">-110=-01010</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_原}$</span>=<strong>0</strong>0001 1011</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_原}$</span>=<strong>1</strong>0000 1010</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_反}$</span>=<strong>0</strong>0001 1011</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_反}$</span>=<strong>1</strong>1111 0101</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_补}$</span>=<strong>0</strong>0001 1011</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_补}$</span>=<strong>1</strong>1111 0111</td>
      </tr>
      <tr>
          <td style="text-align: center"><span class="math align-center">$[125]{_移}$</span>=<strong>1</strong>,0001 1011</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"><span class="math align-center">$[-110]{_移}$</span>=<strong>0</strong>,1111 0111</td>
      </tr>
  </tbody>
</table>
<h3 id="定点加法减法运算">定点加法、减法运算</h3>
<p><strong>公式</strong>
补码加法：任意两数补码之和等于两数之和的补码，<span class="math align-center">$[x]{_补}+[y]{_补}=[x+y]{_补}$</span></p>
<p>补码减法：<span class="math align-center">$[x-y]{_补}=[x]{_补}-[y]{_补}=[x]{_补}+[-y]{_补}$</span></p>
<p>从<span class="math align-center">$[y]{_补}$</span>求<span class="math align-center">$[-y]{_补}$</span>的法则是对<span class="math align-center">$[y]{_补}$</span>包括符号位在内求反，最低位加1得到表达式为：</p>
<span class="math align-center">$[-y]{_补}=\rightharpoondown [y]{_补}+2^{-n}$</span>
<p>其中，符号<span class="math align-center">$\rightharpoondown$</span>表示对<span class="math align-center">$[y]{_补}$</span>作求反操作，包括正负号在内，<span class="math align-center">$2^{-n}$</span>表示末位（最低位）加1.</p>
<p>下面举例加以理解运算过程：</p>
<p>（ <strong>详见P29</strong> ）</p>
<h3 id="溢出概念与检验方法">溢出概念与检验方法</h3>
<p>在定点整数机器中，运算过程中出现大于字长绝对值的现象称为 <strong>溢出</strong>，溢出分正、负溢出两种，用两位符号位表示， <strong>00</strong>、<strong>11</strong>分别表示整数和负数，<strong>01</strong>表示正溢出，<strong>10</strong> 表示负溢出。</p>
<p><strong>详细说明原理：</strong> 假设x表示二进制数，用<span class="math align-center">$2^{-n}<x<2^{+n}$</span>表示二进制数的范围，当n=4时，说明二进制最多4为，两个4位二进制运算结果如果为5位则说明溢出，要判断是什么溢出参照上面的方法。</p>
<h3 id="定点乘法运算">定点乘法运算</h3>
<p>乘法运算拆分来看主要有算术运算加法，逻辑运算异或，还有移位操作。</p>
<p>四位二进制数x,y，两数进行乘法运算，符号位不参与数值位分开运算，一开始y的最低位与x的每一位进行异或并输出结果，下一次y的次高位与x的每一位进行异或运算，结果输出并左移次高位的位数，假设次高位是2，那么左移两位输出结果。</p>
<p>举个例子，如下：</p>
<p><a href="#R-image-a79147f705c91679781ef11659704096" class="lightbox-link"><img alt="图1.png" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a79147f705c91679781ef11659704096"><img alt="图1.png" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE1.png"></a></p>
<h3 id="定点数除法运算">定点数除法运算</h3>
<p>定点数除法运算这里提供两种方法：</p>
<ol>
<li>恢复余数法</li>
</ol>
<p>这种方法是手工计算，而非机器计算，如下图：
定点原码一位除法实现方案（手工）０．１００１０／０．１０１１
<a href="#R-image-2c50e2610acf80bd942dd678ef1eba54" class="lightbox-link"><img alt="tu" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2c50e2610acf80bd942dd678ef1eba54"><img alt="tu" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE2.png"></a>
2. 加减交替法（不恢复余数法）</p>
<p>在这之前我们先简单了解并行除法器，如下图：</p>
<p><a href="#R-image-58f2fe1e918f341e8b8c0ebb7bd8b709" class="lightbox-link"><img alt="tu" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-58f2fe1e918f341e8b8c0ebb7bd8b709"><img alt="tu" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE3.png"></a></p>
<p>被除数 <span class="math align-center">$0.x{_6}x{_5}x{_4}x{_3}x{_2}x{_1}$</span></p>
<p>(双倍长)</p>
<p>除数 <span class="math align-center">$0.y{_3}y{_2}y{_1}$</span></p>
<p>商数 <span class="math align-center">$0.q{_3}q{_2}q{_1}$</span></p>
<p>余数 <span class="math align-center">$0.r{_6}r{_5}r{_4}r{_3}r{_2}r{_1}$</span></p>
<p>除数右移</p>
<p>例题：ｘ＝0.101001, ｙ＝0.111, 求<span class="math align-center">${x}\div{y}$</span></p>
<p><a href="#R-image-96305c45e964e0d71901eceeef4bd9a2" class="lightbox-link"><img alt="tu" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-96305c45e964e0d71901eceeef4bd9a2"><img alt="tu" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE4.png"></a></p>
<h3 id="浮点运算方法浮点运算器">浮点运算方法，浮点运算器</h3>
<p>再次我们在此复习浮点数的表示方法</p>
<span class="math align-center">$$  N=2^e \cdot M$$ </span>
<p>以及32位IEEE754标准格式</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><span class="math align-center">$S$</span></th>
          <th style="text-align: center"><span class="math align-center">$E$</span></th>
          <th style="text-align: center"><span class="math align-center">$M$</span></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><span class="math align-center">$31$</span></td>
          <td style="text-align: center"><span class="math align-center">$30 \gets 23$</span></td>
          <td style="text-align: center"><span class="math align-center">$22 \gets 0$</span></td>
      </tr>
  </tbody>
</table>
<h4 id="浮点运算步骤">浮点运算步骤</h4>
<ul>
<li>0操作数检查。一般就是检查运算数是否为0，不卸载步骤中</li>
<li>比较阶码（E）并完成对阶（小阶向大阶对齐）</li>
<li>尾数（M）求和运算</li>
<li>结果规格化，把运算结果写成1.M的格式</li>
<li>检查上溢出或下溢出（-127&lt;=x&lt;=127,x在这个范围就表示没有溢出,如果溢出需要通过 <strong>变形补码</strong> 来判断是正溢出（01），还是负溢出（10））</li>
<li>舍入处理。写出要求需要的有效位，并用十进制检验是否正确
<a href="#R-image-204bf41e24ac2479b30a50dd80ebf555" class="lightbox-link"><img alt="tu" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE5.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-204bf41e24ac2479b30a50dd80ebf555"><img alt="tu" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%9B%BE5.png"></a></li>
</ul>
<p>例题：设<span class="math align-center">$x=0.5{_10},y=0.4375{_10}$</span>,假设尾数有效位为4位，用二进制求<span class="math align-center">$(x+y){_浮}$</span></p>
<p>把x和化为1.M的格式
<span class="math align-center">$x=0.5{_10}=0.1{_2}=0.1{_2}\cdot 2^0=1.000{_2}\cdot 2^{-1}$</span>
<span class="math align-center">$x=-0.4375{_10}=-0.0111{_2}=-0.0111{_2}\cdot 2^0=-1.000{_2}\cdot 2^{-2}$</span></p>
<p>在这里需要对上面的转换进行说明，说明前我们先看<span class="math align-center">$0.2\cdot10^{0}$</span>,如果现在想写成2，那上面的式子该怎么改呢？</p>
<p>修改如下：
<span class="math align-center">$0.2\cdot10^{0}=2\cdot10^{-1}$</span></p>
<p>也就是要让式子的左右相等，所以后面10的次方就不一样，理解了上面这个我们再来看<span class="math align-center">$-0.1{_2}\cdot 2^0=-1.000{_2}\cdot 2^{-1}$</span>就会更好理解。</p>
<p>下面是具体的步骤：</p>
<ol>
<li>对阶，由上可知y的阶小，向x的看齐
<span class="math align-center">$-1.000{_2}\cdot 2^2=-0.100{_2}\cdot 2^{-1}$</span></li>
<li>尾数相加，
<span class="math align-center">$1.000{_2}\cdot 2^{-1}+(-0.100{_2}\cdot 2^{-1})=0.001{_2}\cdot 2^{-1}$</span></li>
<li>规格化：把结果把x和化为1.M的格式
<span class="math align-center">$0.001{_2}\cdot 2^{-1}=1.0000{_2}\cdot 2^{-4}$</span></li>
<li>检验上溢或下溢
由于指数-4用移码表示，-127&lt;=-4&lt;=127,-4在这个范围即没有溢出</li>
<li>舍入操作
根据题目要求<span class="math align-center">$(x+y){_浮}=1.0000{_2}\cdot 2^{-4}=0.0625{_10}$</span>
十进制检验结果x+y=0.5-0.4375=0.0625</li>
</ol>
<h3 id="浮点数乘除法运算">浮点数乘除法运算</h3>
<p>乘除运算分为四步</p>
<ul>
<li>0操作数检查</li>
<li>阶码加减操作</li>
<li>尾数乘除操作</li>
<li>结果规格化和舍入处理</li>
</ul>
<p>流程与浮点数乘除法类似，但也有不同的地方，下面以乘法运算为例子详细说明具体步骤：</p>
<ol>
<li>将两数的指数部分相加（前提是你要把两数规格化为1.M的形式）</li>
<li>将被乘数和乘数的尾数相乘</li>
<li>规格化于溢出检测</li>
<li>舍入操作</li>
<li>确定乘积的符号（同号为正，异号为负）</li>
</ol>
<h2 id="存储系统">存储系统</h2>
<h3 id="存储系统的层次结构">存储系统的层次结构</h3>
<p>目前存储器的特点是：</p>
<p>• 速度快的存储器价格贵，容量小；
• 价格低的存储器速度慢，容量大。</p>
<ul>
<li>高速缓冲存储器简称<strong>cache</strong>，它是计算机系统中的一个高速小容量半导体存储器。</li>
<li>主存储器简称 <strong>主存</strong>，是计算机系统的主要存储器，用来存放计算机运行期间的 <strong>大量程序</strong> 和 <strong>数据</strong> 。</li>
<li>外存储器简称 <strong>外存</strong>，它是大容量辅助存储器。
<a href="#R-image-c878e9cb358ec34323d958d62642f080" class="lightbox-link"><img alt=" tu6" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu6.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c878e9cb358ec34323d958d62642f080"><img alt=" tu6" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu6.png"></a></li>
</ul>
<h3 id="存储系统分类">存储系统分类</h3>
<ul>
<li>按 <strong>存储介质</strong> 分类：磁表面/半导体存储器</li>
<li>按 <strong>存取方式</strong> 分类：随机/顺序存取（磁带）</li>
<li>按 <strong>读写功能</strong> 分类：ROM，RAM
<ul>
<li>RAM，<strong>随机存取存储器</strong> ：双极型/MOS</li>
<li>ROM，<strong>只读存储器</strong> ：MROM/一次可编程只读存储器PROM/可擦除EPROM/电可擦除EEPROM</li>
</ul>
</li>
<li>按信息的可保存性分类：永久性和非永久性的</li>
<li>按存储器系统中的作用分类：主/辅/缓/控</li>
</ul>
<h3 id="存储器的编制和端模式">存储器的编制和端模式</h3>
<ul>
<li>字存储单元：存放一个机器字的存储单元，相应的单元地址叫字地址。</li>
<li>字节存储单元：存放一个字节的单元，相应的地址称为字节地址。</li>
<li>端模式：一个存储字内部的多字节排列方式。
<ul>
<li>大端 big-endian</li>
<li>小端 little-endian</li>
</ul>
</li>
</ul>
<h3 id="存储器技术">存储器技术</h3>
<ul>
<li><strong>存储容量：</strong> 指一个存储器中可以容纳的存储单元总数。存储容量越大，能存储的信息就越多。</li>
<li><strong>存取时间</strong> 又称存储器访问时间：指一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间。通常取写操作时间等于读操作时间，故称为存储器存取时间。</li>
<li><strong>存储周期：</strong> 指连续启动两次读操作所需间隔的最小时间。通常，存储周期略大于存取时间，其时间单位为ns。</li>
<li><strong>存储器带宽：</strong> 单位时间里存储器所存取的信息量，通常以位/秒或字节/秒做度量单位。
记住：<span class="math align-center">$1KB=2^{10}B，1MB=2^{20}B，1GB=2^{30}B，1TB=2^{40}B$</span></li>
</ul>
<h3 id="sram存储器">SRAM存储器</h3>
<ul>
<li>主存（内部存储器）是半导体存储器。根据信息存储的机理不同可以分为两类：
<ul>
<li>静态读写存储器(SRAM)：存取速度快</li>
<li>动态读写存储器(DRAM)：存储密度和容量比SRAM大。</li>
</ul>
</li>
</ul>
<p>三组信号线：
 地址线:n条地址线，确定存储单元（地址）的个数，或说有2^n个存储单元。
 数据线：决定字的长度（位数）。6条地址线，4条数据线，没那么有64*4个存储位元的总数。
 行线
 列线
 控制线：控制读/写，读写不会同时进行
例如一台计算机数据线有4条，那么它就是4位的计算机。
<a href="#R-image-725a6e40c19444190287a649ca1f0b20" class="lightbox-link"><img alt="tu7" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu7.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-725a6e40c19444190287a649ca1f0b20"><img alt="tu7" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu7.png"></a></p>
<h4 id="存储容量的扩充">存储容量的扩充</h4>
<p>1、字长位数扩展
字节不变，即给的地址线不变，改变数据线让芯片容量符合设计要求。</p>
<p>芯片个数d=设计要求的存储器容量/选择芯片存储器容量</p>
<p>[例2] 利用1M×4位的SRAM芯片，设计一个存储容量
为1M×8位的SRAM存储器。</p>
<p>解：所需芯片数量=(1M×8)/(1M×4)=2片</p>
<p>2、字存储容量扩展</p>
<p>位不变，即数据线不变，通过增加芯片改变地址线使其符合设计要求。</p>
<p>芯片个数d=设计要求的存储器容量/选择芯片存储器容量</p>
<p>[例3]利用1M×8位的DRAM芯片设计2M×8位的DRAM存储
器
解：所需芯片数d=（2M×8）/（1M×8）=2(片)</p>
<p>3、字节扩展</p>
<p>先进行位扩展（数据线bite），字节扩展（字节扩展Byte）</p>
<h3 id="动态随机存取存储器">动态随机存取存储器</h3>
<h4 id="工作原理图">工作原理图</h4>
<p><a href="#R-image-e3d733477dee90472bf47bd60d139dfe" class="lightbox-link"><img alt="tu8" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu8.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e3d733477dee90472bf47bd60d139dfe"><img alt="tu8" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu8.png"></a>
原理图上的刷新本质上是给mos管充电。</p>
<h4 id="动态随机存取存储器的刷新操作">动态随机存取存储器的刷新操作</h4>
<p>刷新的目的是为了保存存储器的存储信息。
注：读出1才会刷新，读出0不会刷新。
当前主流的DRAM器件的刷新周期间隔时间为64秒</p>
<ul>
<li>集中式刷新。先工作最后在进行充电，假设DRAM有1024行，刷新周期为8ms（这里假设是8ms）</li>
<li>分散式刷新。边工作边刷行，假设DRAM有1024行，由8ms（这里假设是8ms）除以1024=7.4us,所以刷新周期为7.4us</li>
</ul>
<h3 id="只读存储器">只读存储器</h3>
<p>ROM叫做只读存储器。顾名思义，只读的意思是
在它工作时只能读出，不能写入。然而其中存储的原
始数据，必须在它工作以前写入。只读存储器由于工
作可靠，保密性强，在计算机系统中得到广泛的应用。</p>
<p>主要有两类：</p>
<ul>
<li>掩模ROM：掩模ROM实际上是一个存储内容固定的ROM，由生产厂家提供产品。</li>
<li>可编程ROM：用户后写入内容，有些可以多次写入。
<ul>
<li>一次性编程的PROM</li>
<li>多次编程的EPROM和E2PROM。</li>
</ul>
</li>
</ul>
<h4 id="掩模rom">掩模ROM</h4>
<p>1、掩模ROM的阵列结构和存储元
<a href="#R-image-dc70a62cb12d2638259c1245b6dcc9c5" class="lightbox-link"><img alt="tu9" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu9.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-dc70a62cb12d2638259c1245b6dcc9c5"><img alt="tu9" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu9.png"></a></p>
<p>2、可编程ROM</p>
<p> EPROM叫做 <em><strong>光擦除可编程可读存储器</strong></em>。它的存储内容可以根据需要写入，当需要更新时将原存储内容抹去，再写入新的内容。
 现以浮栅雪崩注入型MOS管为存储元的EPROM为例进行说明，结构如下图所示。</p>
<p>E2PROM存储元</p>
<p>EEPROM，叫做电擦除可编程只读存储器。其存储元是一个具有两个栅极的NMOS管，如图(a)和(b)所示，G1是控制栅，它是一个浮栅，无引出线；G2是抹去栅，它有引出线。在G1栅和漏极D之间有一小面积的氧化层，其厚度极薄，可产生隧道效应。如图(c)所示，当G2栅加20V正脉冲P1时，通过隧道效应，电子由衬底注入到G1浮栅，相当于存储了1”。利用此方法可将存储器抹成全“1”状态。
<a href="#R-image-fac496052f4945f0f47f006edc87c3ae" class="lightbox-link"><img alt=" tu10" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu10.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fac496052f4945f0f47f006edc87c3ae"><img alt=" tu10" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu10.png"></a></p>
<h4 id="flash">FLASH</h4>
<p>FLASH存储器也翻译成闪速存储器，它是高密度非失易失性的读/写存储器。高密度意味着它具有巨大比特数目的存储容量。非易失性意味着存放的数据在没有电源的情况下可以长期保存。总之，它既有RAM的优点，又有ROM的优点，称得上是存储技术划时代的进展。</p>
<p><strong>FLASH存储器的基本操作</strong> 编程操作、读取操作、擦除操作。</p>
<h3 id="并行存储器">并行存储器</h3>
<p>并行存储器的作用：提高读写效率</p>
<h4 id="双端口与存储器">双端口与存储器</h4>
<p>1、双端口存储器的逻辑结构</p>
<p>双端口存储器由同一个存储器具有两组 <strong>相互独立的读写控制电路</strong> 而得名。由于进行并行的独立操作，因而是一种高速工作的存储器，在科研和工程中非常有用。 举例说明，双端口存储器IDT7133的逻辑框图 。如下图：
<a href="#R-image-44a13c58d17e61a66f854f8ddcf4296d" class="lightbox-link"><img alt="tu11" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu11.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-44a13c58d17e61a66f854f8ddcf4296d"><img alt="tu11" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu11.png"></a></p>
<p>2、无冲突读写控制</p>
<p>当两个端口的地址不相同时，在两个端口上进行读写操作，一定不会发生冲突。当任一端口被选中驱动时，就可对整个存储器进行存取，每一个端口都有自己的片选控制(CE)和输出驱动控制(OE)。读操作时，端口的OE(低电平有效)打开输出驱动器，由存储矩阵读出的数据就出现在I/O线上。</p>
<p>3、有冲突读写控制</p>
<p>当两个端口同时存取存储器同一存储单元时，便发生读写冲突。为解决此问题，特设置了BUSY标志。在这种情况下，片上的判断逻辑可以决定对哪个端口优先进行读写操作，而对另一个被延迟的端口置BUSY标志(BUSY变为低电平)，即暂时关闭此端口。</p>
<h4 id="多模块交叉存储器">多模块交叉存储器</h4>
<p>1、存储器的模块化组织
一个由若干个模块组成的主存储器是线性编址的。这些地址在各模块中如何安排，有两种方式：</p>
<ul>
<li>一种是 <strong>顺序方式</strong> ，</li>
<li>一种是 <strong>交叉方式</strong> 。
<a href="#R-image-757ac7fd1cd699538106a8c44dd97818" class="lightbox-link"><img alt="tu12" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu12.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-757ac7fd1cd699538106a8c44dd97818"><img alt="tu12" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu12.png"></a></li>
</ul>
<h5 id="顺序方式">顺序方式</h5>
<p>[例]M0－M3共四个模块，则每个模块8个字</p>
<p>顺序方式：</p>
<p>M0：0—7
M1：8－15
M2：16－23
M3：24－31</p>
<ul>
<li>5位地址组织如下： X X X X X</li>
<li>高位选模块，低位选块内地址</li>
<li>特点：某个模块进行存取时，其他模块不工作，优点是某一模块出现故障时，其他模块可以照常工作，通过增添模块来扩充存储器容量比较方便。缺点是各模块串行工作，存储器的带宽受到了限制。</li>
</ul>
<h5 id="交叉方式">交叉方式</h5>
<ul>
<li>
<p>M0：0，4,&hellip;除以4余数为0</p>
</li>
<li>
<p>M1：1，5,&hellip;除以4余数为1</p>
</li>
<li>
<p>M2：2，6,&hellip;除以4余数为2</p>
</li>
<li>
<p>M3：3，7,&hellip;除以4余数为3</p>
</li>
<li>
<p>5位地址组织如下： X X X X X</p>
</li>
<li>
<p>高位选块内地址，低位选模块</p>
</li>
<li>
<p>特点：连续地址分布在相邻的不同模块内，同一个模块内的地址都是不连续的。优点是对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽。使用场合为成批数据读取。</p>
</li>
</ul>
<p><strong>多模块交叉存储器的基本结构</strong> 下图为四模块交叉存储器结构框图。主存被分成4个相互独立、容量相同的模块M0，M1，M2，M3，每个模块都有自己的读写控制电路、地址寄器和数据寄存器，各自以等同的方式与CPU传送信息。在理想情况下，如果程序段或数据块都是连续地在主存中存取，那么将大大提高主存的访问速度。
!p<a href="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu13.png">tu13</a></p>
<ul>
<li>通常在一个存储器周期内，n个存储体必须分时启动，则各个存储体的启动间隔为<span class="math align-center">$t=\frac{T}{n}$</span>（n为交叉存取度）</li>
<li>整个存储器的存取速度有望提高n倍
<span class="math align-center">$t{_顺序}=xT$</span>
<span class="math align-center">$t{_交叉}=T\frac{x+n-1}{n}$</span></li>
</ul>
<h3 id="cache-基本原理">cache 基本原理</h3>
<p>为了解决CPU和主存之间速度不匹配而采取的一种重要技术。</p>
<ul>
<li>一般采用高速的SRAM构成。</li>
<li>CPU和主存之间的速度差别很大采用两级或多级Cache系统</li>
<li>早期的一级Cache在CPU内，二级在主板上</li>
<li>现在的CPU内带L1 Cache和L2 Cache</li>
<li>全由硬件调度，对用户透明
<a href="#R-image-304b9b0a00e6c70d65d4e7f686e40959" class="lightbox-link"><img alt="tu14" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu14.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-304b9b0a00e6c70d65d4e7f686e40959"><img alt="tu14" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu14.png"></a>
cpu与缓存之间数据交换是以字节为单位，而缓存与主存之间的数据交换以块为单位，一个块有若干组成，是定长的。</li>
</ul>
<p>从CPU来看，增加一个cache的目的，就是在性能上使主存的平均读出时间尽可能接近cache的读出时间。为了达到这个目的，在所有的存储器访问中由cache满足CPU需要的部分应占很高的比例，即cache的命中率应接近于1。由于程序访问的局部性，实现这个目标是可能的。</p>
<p>命中率：CPU访问cache且需要获取的文件在cache里，即为命中，公示如下：
<span class="math align-center">$h=\frac{N{_c}}{N{_c}+N{_m}}$</span></p>
<p><span class="math align-center">$N{_c}$</span>:cache完成存取的总次数（访问cache的总次数）；</p>
<p><span class="math align-center">$N{_m}$</span>:主存完成存取的总次数。</p>
<h3 id="主存与cache的地址映射">主存与cache的地址映射</h3>
<p>无论选择那种映射方式，都要把主存和cache划分为同样大小的“块”。下面介绍三种一映射方式：</p>
<p>1、全相联的映射方式（一对多，一是指缓存，多是指主存里的数据块）</p>
<p>（1）将地址分为两部分（块号和字），在内存块写入Cache时，同时写入块号标记；
（2）CPU给出访问地址后，也将地址分为两部分（块号和字），比较电路块号与Cache 表中的标记进行比较，相同表示命中，访问相应单元；如果没有命中访问内存，CPU 直接访问内存，并将被访问内存的相对应块写入Cache。
<a href="#R-image-9d7fc43eb62039bd9cfd3203f659b821" class="lightbox-link"><img alt=" tu15" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu16.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9d7fc43eb62039bd9cfd3203f659b821"><img alt=" tu15" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu16.png"></a></p>
<p>1、全相联映射方式</p>
<p>特点：</p>
<ul>
<li>优点：冲突概率小，Cache的利用高。</li>
<li>缺点：比较器电路难实现，适用于小容量的Cache</li>
</ul>
<h3 id="直接映射方式">直接映射方式</h3>
<p>2、直接映射方式（一对多）：</p>
<ul>
<li>i= j mod m</li>
<li>m为cache中的总行数</li>
<li>主存第j块内容拷贝到Cache的i行</li>
<li>一般I和m都是2^N级
<a href="#R-image-85a2ed8a4275fbf597b010a93d55a510" class="lightbox-link"><img alt="tu15" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu15.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-85a2ed8a4275fbf597b010a93d55a510"><img alt="tu15" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu15.png"></a></li>
</ul>
<p>[例]cache容量16字，主存容量256字，则地址2，18，34…..242等都存放在cache的地址2内，如果第一次2在cache中，下次访问34内容，则不管cache其他位置的内容访问情况，都会引起2块内容的替换。</p>
<p>特点</p>
<ul>
<li>优点：比较电路少m倍线路，所以硬件实现简单，Cache地址为主存地址的低几位，不需变换。</li>
<li>缺点：冲突概率高（抖动）</li>
<li>适合大容量Cache</li>
</ul>
<h3 id="组相联映射方式">组相联映射方式</h3>
<p>前两者的组合</p>
<ul>
<li>Cache分组，组间采用直接映射方式，组内采用全相联的映射方式</li>
<li>Cache分组U，组内容量V</li>
<li>映射方法（一对多）
<ul>
<li>q= j mod u</li>
<li>主存第j块内容拷贝到Cache的q组中的某行</li>
</ul>
</li>
<li>地址变换
<ul>
<li>设主存地址x，看是不是在cache中，先y= x mod u，则在y组中一次查找</li>
</ul>
</li>
</ul>
<p>分析：比全相联容易实现，冲突低</p>
<ul>
<li>v=1，则为直接相联映射方式</li>
<li>u=1，则为全相联映射方式</li>
<li>v的取值一般比较小， 一般是2的幂，称之为v路组相联cache。
<a href="#R-image-e7d363d862b7d8b4517a37500cda5840" class="lightbox-link"><img alt="tu17" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu17.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e7d363d862b7d8b4517a37500cda5840"><img alt="tu17" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu17.png"></a></li>
</ul>
<h3 id="cache替换策略">cache替换策略</h3>
<ul>
<li>LFU（最不经常使用 ）：每行有一个计数器，被访问的行计数器增加1，哪一行的值小，就换值小的行，不能反映近期cache的访问情况，</li>
<li>LRU（近期最少使用） ：被访问的行计数器置0，其他的计数器增加1，哪一行的值大，换值大的行，符合cache的工作原理</li>
<li>随机替换：随机替换策略实际上是不要什么算法，从特定的行位置中随机地选取一行换出即可。这种策略在硬件上容易实现，且速度也比前两种策略快。
<ul>
<li>缺点：随意换出的数据很可能马上又要使用，从而降低命中率和cache工作效率。</li>
<li>优点：但这个不足随着cache容量增大而减小。随机替换策略的功效只是稍逊于前两种策略。</li>
</ul>
</li>
</ul>
<p>由于cache的内容只是主存部分内容的拷贝，它应当 <strong>与主存内容保持一致</strong>。而CPU对cache的写入更改了cache的内容。如何与主存内容保持一致，可选用如下三种写操作策略。</p>
<ul>
<li>写回法：换出时，对行的修改位进行判断，决定是写回还是舍掉。当主存数据传向缓存而缓存满的时候，缓存就要进行替换，只有这个时候才将数据写回主存。</li>
<li>全写法：写命中时，Cache与内存一起写，也就是主存和缓存一起更改；</li>
<li>写一次法：与写回法一致，第一次Cache命中时采用全写法，也就是这个时候要把数据写回主存，因为第一次命中的时候CPU会在总线上启动一个存储写周期，其他cache即可监听到该消息，选择复制或丢弃该数据，以便委会系统全部cache的一致性。</li>
</ul>
<h2 id="4-指令系统">4 指令系统</h2>
<h3 id="指令系统基本概念">指令系统基本概念</h3>
<p>指令：就是要计算机执行某种操作的命令。从计算机组成的层次结构来说，计算机的指令有微指令、机器指令和宏指令之分。</p>
<span class="math align-center">$指令=\begin{cases}微指令\\机器指令\\宏指令\end{cases}$</span>
<ul>
<li><strong>微指令</strong> 是微程序级的命令，它属于硬件；</li>
<li><strong>宏指令：</strong> 由若干条机器指令组成的软件指令，它属于软件；</li>
<li><strong>机器指令：</strong> 介于微指令与宏指令之间，通常简称为指令，每一条指令可完成一个独立的算术运算或逻辑运算操作。</li>
</ul>
<p><strong>本小节介绍的就是机器指令。</strong></p>
<h3 id="指令系统的性能要求">指令系统的性能要求</h3>
<ul>
<li>完备性</li>
<li>规整性</li>
<li>有效性</li>
<li>兼容性</li>
</ul>
<p>低级语言与高级语言的关系
<a href="#R-image-339c479385c82fcd0df367a7629429d2" class="lightbox-link"><img alt="tu18" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu18.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-339c479385c82fcd0df367a7629429d2"><img alt="tu18" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu18.png"></a></p>
<p>机器程序员看到的计算机属性就是指令系统体系结构，简称 <strong>ISA</strong>。</p>
<h3 id="指令格式">指令格式</h3>
<table>
  <thead>
      <tr>
          <th>操作字段OP</th>
          <th>地址码字段A</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>表示进行什么性质的操作，如+、-等</td>
          <td>存储操作数的地址</td>
      </tr>
  </tbody>
</table>
<p>不同的指令用操作码字段的不同编码来表示，每一种编码代表一种指令。</p>
<p>根据一条指令中有几个操作数地址，可将该指令称为几操作数指令或几地址指令。</p>
<ul>
<li>三地址指令</li>
<li>二地址指令</li>
<li>单地址指令</li>
<li>零地址指令
<table>
  <thead>
      <tr>
          <th>地址码名称</th>
          <th>操作码</th>
          <th>地址块1</th>
          <th>地址块2</th>
          <th>地址块3</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>三地址指令</td>
          <td>OP码</td>
          <td><span class="math align-center">$A_1$</span></td>
          <td><span class="math align-center">$A_2$</span></td>
          <td><span class="math align-center">$A_3$</span></td>
      </tr>
      <tr>
          <td>二地址指令</td>
          <td>OP码</td>
          <td><span class="math align-center">$A_1$</span></td>
          <td><span class="math align-center">$A_2$</span></td>
          <td></td>
      </tr>
      <tr>
          <td>一地址指令</td>
          <td>OP码</td>
          <td><span class="math align-center">$A$</span></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>零地址指令</td>
          <td>OP码</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
</li>
</ul>
<h4 id="三地址指令">三地址指令</h4>
<table>
  <thead>
      <tr>
          <th>三地址指令</th>
          <th>OP码</th>
          <th><span class="math align-center">$A_1$</span></th>
          <th><span class="math align-center">$A_2$</span></th>
          <th><span class="math align-center">$A_3$</span></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td>操作码</td>
          <td>被操作数或源操作数地址</td>
          <td>操作数或终点操作数地址</td>
          <td>存放结果操作数地址</td>
      </tr>
  </tbody>
</table>
<ul>
<li>功能描述：
<ul>
<li>(A1) op(A2)→A3（把A1A2的结果存放到A3中）</li>
<li>(PC) +1→PC（PC加1）</li>
</ul>
</li>
</ul>
<p>这种格式虽然省去了一个地址，但指令长度仍比较长，所以只在字长较长的大、中型机中使用，而小型、微型机中很少使用。</p>
<h4 id="二地址指令双操作数指令">二地址指令（双操作数指令）</h4>
<table>
  <thead>
      <tr>
          <th>二地址指令</th>
          <th>OP码</th>
          <th><span class="math align-center">$A_1$</span></th>
          <th><span class="math align-center">$A_2$</span></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td>操作码</td>
          <td>第一操作数</td>
          <td>第二操作数</td>
      </tr>
  </tbody>
</table>
<ul>
<li>功能描述：
<ul>
<li>(A1) op(A2)→A1</li>
<li>(PC)+1→PC</li>
</ul>
</li>
<li>二地址指令在计算机中得到了广泛的应用，但是在使用时有一点必须注意：指令执行之后，A1中原存的内容已经被新的运算结果替换了。</li>
</ul>
<p>二地址地址根据操作数的物理位置分为：</p>
<ul>
<li>SS 存储器-存储器类型</li>
<li>RS 寄存器-存储器类型</li>
<li>RR 寄存器-寄存器类型
RR到RS再到SS，指令执行会越来越慢，也就是说指令执行从内存某个单元到内存的另一个单元比较慢。</li>
</ul>
<h4 id="一地址指令">一地址指令</h4>
<table>
  <thead>
      <tr>
          <th>一地址指令</th>
          <th>OP码</th>
          <th><span class="math align-center">$A$</span></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td>操作码</td>
          <td>操作数</td>
      </tr>
  </tbody>
</table>
<p>功能描述：</p>
<ul>
<li>(AC) op(A1) →A1</li>
<li>(PC)+1→PC</li>
<li>单操作数运算指令，如“+1”、“-1”、“求反”</li>
<li>指令中给出一个源操作数的地址</li>
</ul>
<h4 id="零地址指令">零地址指令</h4>
<table>
  <thead>
      <tr>
          <th>零地址指令</th>
          <th>OP码</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td></td>
          <td>操作码</td>
      </tr>
  </tbody>
</table>
<p>功能：“停机”、“空操作”、“清除”等控制类指令。</p>
<h4 id="指令字长度">指令字长度</h4>
<p>概念</p>
<ul>
<li>指令字长度（一个指令字包含二进制代码的位数）</li>
<li>机器字长：计算机能直接处理的二进制数据的位数。</li>
<li>单字长指令</li>
<li>半字长指令</li>
<li>双字长指令</li>
</ul>
<p>多字长指令的优缺点</p>
<ul>
<li>
<p>优点提供足够的地址位来解决访问内存任何单元的寻址问题 ；</p>
</li>
<li>
<p>缺点必须两次或多次访问内存以取出一整条指令，降低了CPU的运算速度，又占用了更多的存储空间。</p>
</li>
<li>
<p>指令系统中指令采用 <strong>等长指令</strong> 的优点：各种指令字长度是相等的，指令字结构简单，且指令字长度是不变的 ；</p>
</li>
<li>
<p>采用 <strong>非等长指令</strong> 的的优点：各种指令字长度随指令功能而异，结构灵活，能充分利用指令长度，但指令的控制较复杂 。</p>
</li>
</ul>
<h4 id="指令助记符">指令助记符</h4>
<table>
  <thead>
      <tr>
          <th>零地址指令</th>
          <th>OP码</th>
          <th>OP码</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>加法</td>
          <td>ADD</td>
          <td>001</td>
      </tr>
      <tr>
          <td>减法</td>
          <td>SUB</td>
          <td>010</td>
      </tr>
      <tr>
          <td>传送</td>
          <td>MOV</td>
          <td>011</td>
      </tr>
      <tr>
          <td>跳转</td>
          <td>JMP</td>
          <td>100</td>
      </tr>
      <tr>
          <td>转子</td>
          <td>JSR</td>
          <td>101</td>
      </tr>
      <tr>
          <td>存数</td>
          <td>STO</td>
          <td>110</td>
      </tr>
      <tr>
          <td>取数</td>
          <td>LAD</td>
          <td>111</td>
      </tr>
  </tbody>
</table>
<h3 id="操作数类型">操作数类型</h3>
<ul>
<li>地址数据:地址实际上也是一种形式的数据。（ <strong>类似指针</strong> ）</li>
<li>数值数据:计算机中普遍使用的三种类型的数值数据。</li>
<li>字符数据:文本数据或字符串，目前广泛使用ASCII码。</li>
<li>逻辑数据:一个单元中有几位二进制bit项组成，每个bit的值可以是1或0。当数据以这种方式看待时，称为逻辑性数据。（类似布尔型）</li>
</ul>
<h3 id="指令和数据的寻址方式">指令和数据的寻址方式</h3>
<p><span class="math align-center">$指令寻址方式=\begin{cases}顺序寻址\\跳跃寻址\end{cases}$</span>
此处的跳跃寻址包含了选择和循环。</p>
<h3 id="操作数基本寻址方式">操作数基本寻址方式</h3>
<p>1、隐含寻址</p>
<p><a href="#R-image-6745562daed29cebf3af1371bc77e90e" class="lightbox-link"><img alt="tu20" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu20.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6745562daed29cebf3af1371bc77e90e"><img alt="tu20" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu20.png"></a></p>
<ul>
<li>指令中隐含着操作数的地址，比如隐藏累加器的地址，当该指令被执行时会执行累加器，但累加器的地址是没有表现在该指令上的。</li>
<li>如某些运算，隐含了累加器AC作为源和目的寄存器</li>
<li>如8086汇编中的STC指令，设置标志寄存器的C为1</li>
</ul>
<p>2、立即寻址</p>
<p><a href="#R-image-c1e112881c7012011bcb9194e0cff1df" class="lightbox-link"><img alt="tu21" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu21.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c1e112881c7012011bcb9194e0cff1df"><img alt="tu21" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu21.png"></a></p>
<p>指令的地址指出的不是操作数地址，而是操作数本身。比如</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span>,y<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> z<span style="color:#f92672">=</span>x<span style="color:#f92672">+</span>y;</span></span></code></pre></div>
<p>在上面这个例子中，执行加法的时候x,y不是6和7的地址，而是6和7本身；</p>
<p>3、直接寻址</p>
<p><a href="#R-image-d845f24caa3cae028bac4a29b134a3c8" class="lightbox-link"><img alt="tu22" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu22.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-d845f24caa3cae028bac4a29b134a3c8"><img alt="tu22" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu22.png"></a></p>
<p>在指令格式中的地址上指出操作数在内存中的地址。其实这很像数组，例如</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> x<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;1&#39;</span>;<span style="color:#75715e">//地址为5673
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> cha[]<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#39;x&#39;</span>};<span style="color:#75715e">//地址为2341
</span></span></span></code></pre></div>
<p>我们在使用cha[0]的时候,地址2341指向的就是1的地址5673，一个地址指向另一个地址。</p>
<p>4、间接寻址</p>
<p><a href="#R-image-3d87435bbb31fb355c2e14c0dba954e1" class="lightbox-link"><img alt="tu23" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu23.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3d87435bbb31fb355c2e14c0dba954e1"><img alt="tu23" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu23.png"></a></p>
<p>类似二维数组</p>
<p>5、寄存器寻址</p>
<p><a href="#R-image-445c1f7cf3699273e1d4a6b743f4eba9" class="lightbox-link"><img alt="tu24" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu24.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-445c1f7cf3699273e1d4a6b743f4eba9"><img alt="tu24" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu24.png"></a></p>
<p>当操作数不在内存而是在CPU的寄存器中时使用这个寻址方式</p>
<p>6、寄存器简介寻址</p>
<p><a href="#R-image-c56063c16405b609e648ca760f0b8daa" class="lightbox-link"><img alt="tu25" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu25.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c56063c16405b609e648ca760f0b8daa"><img alt="tu25" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu25.png"></a></p>
<p>操作数不在寄存器中，而是在寄存器地址所知的位置，比如内存（类似二维数组）</p>
<p>7、偏移寻址</p>
<p><a href="#R-image-72222f2d4e6617d957f153b630e0b9f5" class="lightbox-link"><img alt="tu26" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu26.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-72222f2d4e6617d957f153b630e0b9f5"><img alt="tu26" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu26.png"></a></p>
<p>类似于数组中，数组下标的变化会对应不同的地址上的值，下标的变化可以理解为加了某一个偏移量而产生改变。</p>
<p>下面介绍三种不同的偏移寻址，他们的不同我觉得就是使用的寄存器不一样，本质上都是地址加了偏移量后找到第二个地址，再通过第二个地址上的值进行操作。</p>
<p>7.1 相对寻址</p>
<p>使用的是程序计数器（CP），CP作为原始地址，EA=A+（CP）</p>
<p>7.2 基址寻址</p>
<p><a href="#R-image-4ea9b7f6bf2cad471838c29973fea3f6" class="lightbox-link"><img alt="tu27" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu28.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4ea9b7f6bf2cad471838c29973fea3f6"><img alt="tu27" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu28.png"></a></p>
<p>使用存储器地址，作为原始地址，</p>
<p>7.3 变址寻址</p>
<p><a href="#R-image-3c35e233df2d18d85af166485b72c38a" class="lightbox-link"><img alt="tu28" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu29.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3c35e233df2d18d85af166485b72c38a"><img alt="tu28" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu29.png"></a></p>
<p>就是将指令的地址码部分给出的基准地址A与CPU内某特定的变址寄存器Rx中的内容相加，以形成操作数的有效地址。</p>
<p>8、分寄存器堆栈、存储器堆栈以先进后出原理存储数据
<a href="#R-image-9beeca64cec7047c5e53f060b4e5466c" class="lightbox-link"><img alt="tu27" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu27.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9beeca64cec7047c5e53f060b4e5466c"><img alt="tu27" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu27.png"></a></p>
<p>9、段寻址方式</p>
<p>存储空间划分为多段
<a href="#R-image-8dacbbbec472c3f3d664853d37f2bcbc" class="lightbox-link"><img alt="tu30" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu30.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8dacbbbec472c3f3d664853d37f2bcbc"><img alt="tu30" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu30.png"></a></p>
<h3 id="典型的指令">典型的指令</h3>
<ul>
<li>数据处理</li>
<li>数据存储</li>
<li>数据传送</li>
<li>程序控制</li>
</ul>
<ol>
<li>数据传送指令</li>
<li>算术运算指令</li>
<li>逻辑运算指令</li>
<li>程序控制指令</li>
<li>输入输出指令</li>
<li>字符串处理指令</li>
<li>特权指令</li>
</ol>
<h2 id="中央处理器">中央处理器</h2>
<p>冯诺一曼机的运算器与控制器是分开的，二现今这两个是设计在同一块芯片上，成为 <strong>CPU</strong> ，而单片机就是 <strong>CPU+存储器</strong>。</p>
<h3 id="cpu的功能和组成">CPU的功能和组成</h3>
<h4 id="cpu的功能">CPU的功能</h4>
<p>取指令，执行指令</p>
<ul>
<li>指令控制。程序的<strong>顺序控制</strong> 。</li>
<li>操作控制。控制指令的取出与执行。</li>
<li>时间控制。对操作实施时间上的定时。</li>
<li>数据加工。例如算数运算和逻辑运算</li>
</ul>
<h4 id="cpu的组成">CPU的组成</h4>
<p><a href="#R-image-9e897cd4bc1ac5fefd8c5faff45090da" class="lightbox-link"><img alt="tu31" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu31.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9e897cd4bc1ac5fefd8c5faff45090da"><img alt="tu31" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu31.png"></a>
中央处理器CPU = 运算器 + cache + 控制器</p>
<h5 id="运算器">运算器</h5>
<ul>
<li>ALU：算术逻辑运算单元</li>
<li>通用寄存器：R0～R3</li>
<li>数据缓冲寄存器：DR</li>
<li>程序状态字寄存器：PSWR</li>
</ul>
<h5 id="控制器">控制器</h5>
<p>程序计数器、指令寄存器、时序发生器、操作控制寄存器；</p>
<ul>
<li>程序计数器PC(Programming Counter)
<ul>
<li>用来存放正在执行的指令的地址或接着将要执行的下一条指令的地址。</li>
<li><strong>顺序执行</strong> 时，每执行一条指令，PC的值应 <strong>加1</strong></li>
<li>要改变程序执行顺序的情况时，一般由转移类指令将转移目标地址送往PC ，可实现程序的转移。</li>
</ul>
</li>
<li>指令寄存器IR(Instruction Register)
<ul>
<li>指令寄存器用来存放从存储器中 <strong>取出的待执行的指令</strong>。</li>
<li>在执行该指令的过程中，指令寄存器的内容不允许发生变化，以保证实现指令的全部功能。</li>
</ul>
</li>
</ul>
<h3 id="重要的寄存器">重要的寄存器</h3>
<ul>
<li>数据缓冲寄存器（DP）：暂时存放ALU（算术逻辑运算单元）运算结果，或或有数据寄存器读出的数据字，或外部接口的数据字。
<a href="#R-image-9ea386b5f0660170ed4899c268d176d6" class="lightbox-link"><img alt="tu32" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu32.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9ea386b5f0660170ed4899c268d176d6"><img alt="tu32" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu32.png"></a></li>
<li>指令寄存器(IR)：用来保存当前正在执行的第一条指令</li>
<li>程序计数器(PC)：总是保持将要执行的下一条指令，绝大多数是顺序程序，所以修改过程中通常是简单的PC加1.</li>
<li>数据地址寄存器(AR)用来保存当前CPU所访问的数据存储单元的地址。</li>
<li>通用寄存器(R0～R3)：存常用的指令，</li>
<li>状态字寄存器(PSW)：保存有算术运算或逻辑运算或测试结果产生的更重条件代码，简而言之就是存储一些运算的结果，比如进位、溢出、零标志、负标志等</li>
</ul>
<h3 id="指令周期">指令周期</h3>
<p><a href="#R-image-35a7d6bb56612c1fe460ab64f7ff2cb9" class="lightbox-link"><img alt="tu23" class="lazy lightbox figure-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu33.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-35a7d6bb56612c1fe460ab64f7ff2cb9"><img alt="tu23" class="lazy lightbox lightbox-image" loading="lazy" src="/class/13.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%B0%8F%E7%9F%A5%E8%AF%86/tu33.png"></a>
指令周期由若干个CPU周期数表示，CPU周期又称为机器周期，在一些系统中称机器周期为时钟周期。</p>
<p>指令周期又分为取指令周期与执行指令周期</p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>也被称为电脑，或者电子计算机。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年1月10日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/f1-%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">F1-复习资料</a></li>
    <li><a class="term-link" href="/categories/z-%E4%B8%93%E4%B8%9A%E8%AF%BE/">Z-专业课</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a></li>
  </ul>
</div>
  </header>

<h1 id="51单片机">51单片机</h1>

<ul class="children children-li children-sort-">
  <li class="children-title"><a href="/class/8.51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%BB%A3%E7%A0%81%E7%83%A7%E5%BD%95/">pretues&#43;kiel5仿真软件配合使用时需要注意的地方</a><p><p>不知道keil5从哪个版本开始就不支持了晶振的设置操作，我在网上搜也得到不同的答案，所以从哪个版本开始限制这就不提了，
好在这样的改变并不会形象我们使用keil5。最近在刚进阶学习stm32，用到了<a href="/layout/variables">pretues_8.11</a> 仿真软
件和<a href="/layout/variables">keil5</a>代码编辑器，自己把心中所得分享一下。</p></p></li>
</ul>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年1月9日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E6%A0%B8%E5%BF%83%E8%AF%BE%E7%A8%8B/">核心课程</a></li>
  </ul>
</div>
  </footer>
</article>
          <section>
            <h1 class="a11y-only">51单片机 的子部分</h1>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E6%8A%A5%E9%94%99%E4%B8%8E%E8%A7%A3%E5%86%B3/">报错与解决</a></li>
    <li><a class="term-link" href="/tags/%E4%BB%A3%E7%A0%81%E7%83%A7%E5%BD%95/">代码烧录</a></li>
  </ul>
</div>
  </header>

<h1 id="pretueskiel5仿真软件配合使用时需要注意的地方">pretues&#43;kiel5仿真软件配合使用时需要注意的地方</h1>

<p>不知道keil5从哪个版本开始就不支持了晶振的设置操作，我在网上搜也得到不同的答案，所以从哪个版本开始限制这就不提了，
好在这样的改变并不会形象我们使用keil5。最近在刚进阶学习stm32，用到了<a href="/layout/variables">pretues_8.11</a> 仿真软
件和<a href="/layout/variables">keil5</a>代码编辑器，自己把心中所得分享一下。</p>
<p><strong>别人编译编译成功的工程，我另外用<a href="/layout/variables">keil5</a>打开编译为什么会失败？</strong></p>
<p>假设你拿到的别人的工程所选芯片为<a href="/layout/variables">stm32f103VC</a>，那么你在另外的电脑打开<a href="/layout/variables">keil5</a>，在设置里选芯片也是<a href="/layout/variables">stm32f103VC</a>，如果选的芯片与工程最初选的型号不同，那编译可能会失败，接着在打勾生成.hex文件。</p>
<p><strong>pretues里没有找到<a href="/layout/variables">keil5</a>里选择的芯片，能用别的芯片代替吗？</strong></p>
<p>答案是可以的，但尽量使用版本更高的芯片，使之能向下兼容，在<a href="/layout/variables">keil5</a>如果选了<a href="/layout/variables">stm32f103VC</a>，而pretues仿真的芯片是<a href="/layout/variables">stm32f103C6</a>，那么你并不用担心芯片不对应而导致你仿真失败。</p>
<p><strong>在pretues导入.hex文件后直接开始仿真，为什么报了许多错误？</strong></p>
<p>可能原因：在选择好<a href="/layout/variables">.hex</a>文件后，还必须设置晶振频率，即12MHz，如果没置会导致仿真失败，另外你不用担心选择的.hex文件路径有中文，我测过即使导入文件路径有中文也可以正常运行。</p>
<div class="box attachments cstyle default" style="--VARIABLE-BOX-color: fuchsia;">
  <div class="box-label"><i class="fab fa-hackerrank"></i> 附件</div>
  <ul class="box-content attachments-files">
  </ul>
</div>

  <footer class="footline">
              <i class='fa-fw fas fa-calendar'></i> 2024年1月9日
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/d1-51%E5%8D%95%E7%89%87%E6%9C%BA/">D1-51单片机</a></li>
    <li><a class="term-link" href="/categories/z-%E4%B8%93%E4%B8%9A%E8%AF%BE/">Z-专业课</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
<article class="default">
  <header class="headline">
<div class="R-taxonomy taxonomy-tags cstyle tags" title="标签" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <ul>
    <li><a class="term-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc&amp;#43;&amp;#43;/">设计模式（C&#43;&#43;）</a></li>
  </ul>
</div>
  </header>

<h1 id="19设计模式c">19.设计模式（C&#43;&#43;）</h1>

<h2 id="组件协作">组件协作</h2>
<h3 id="模板方法-template-method">模板方法-template method</h3>
<p>在C语言代码编写中主函数调用常调用库函数，进行功能实现。那么现在面向对象编程中，可以选择在库中调用未来写在主函数中的函数，这个设计方式就叫template method（个人的理解，不是定义）。举个例子，假设有一个lib.h的库，里面写了画圆的步骤，主体框架已经在rung()中写好，但是还有一个函数没用写，该函数是用来指定圆的半径等参数的，这个函数用virtual修饰，在未来主函数中可以继承该类并重写这个函数，最后在调用lib.h库里的run()即可。</p>
<p>在这里画圆的框架以及步骤已经规定好，也就是稳定的，而圆的半径是变化，使用以上方法就把稳定与变化分开，这也是设计模式的核心要点之一。例子粗糙但已经能说明该设计模式了</p>
<p>前一过程称为早绑定，后一过程称为晚绑定。</p>
<h3 id="策略方法-strategy">策略方法-strategy</h3>
<p>如下图是该方法的结构图。
<a href="#R-image-f34085b85a3bbb99f9fe6ee4a76f1c30" class="lightbox-link"><img alt="alt text" class="lazy lightbox figure-image" loading="lazy" src="/class/19.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc%E5%8A%A0%E5%8A%A0/image.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f34085b85a3bbb99f9fe6ee4a76f1c30"><img alt="alt text" class="lazy lightbox lightbox-image" loading="lazy" src="/class/19.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc%E5%8A%A0%E5%8A%A0/image.png"></a></p>
<p>该方法是为了应对未来的需求，这在业务就很常见，在未来会增加业务的功能，主要体现在代码<strong>运行时</strong>，假设现在有三种算分分别对应三种不同的情况，在运算时需要对不同的算法做不同的处理，以往我们会使用if-else或Switch-case，但是当情况不是三种或未来增加时，后者的代码会变得冗长，也不好维护，现在我们可以把三种情况对应的算法继承一个基类中的virtual修饰的方法，并重写这个方法。在运行处通过上下文调用对应的算法。</p>
<ul class="children children-li children-sort-">
</ul>

  <footer class="footline">
<div class="R-taxonomy taxonomy-categories cstyle" title="类别" style="--VARIABLE-TAGS-BG-color: var(--INTERNAL-TAG-BG-color);">
  <i class="fa-fw fas fa-layer-group"></i>
  <ul>
    <li><a class="term-link" href="/categories/%E8%87%AA%E5%AD%A6%E8%AF%BE%E7%A8%8B/">自学课程</a></li>
  </ul>
</div>
  </footer>
</article>
          </section>
        </div>
      </main>
    </div>
    <script src="/js/clipboard/clipboard.min.js?1744119132" defer></script>
    <script src="/js/perfect-scrollbar/perfect-scrollbar.min.js?1744119132" defer></script>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/js/mathjax/tex-mml-chtml.js?1744119132"></script>
    <script src="/js/theme.js?1744119132" defer></script>
  </body>
</html>
