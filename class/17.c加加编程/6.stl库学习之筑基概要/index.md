# 6.STL库学习之筑基概要

## STL程序源代码位置

了解自身编译器STL程序源代码位置。

## OOP 与 GP

面向对象编程（OOP）：

面向对象编程是一种编程范式，它将数据和处理这些数据的方法封装在对象中。这种方法强调了数据和函数的捆绑，使得代码更加模块化，易于理解和维护。对象可以包含属性（数据）和方法（函数），它们一起工作来模拟现实世界的行为。

补充说明：OOP 通过类（Class）来定义对象的蓝图，支持继承、封装和多态等特性，从而提高代码的重用性和灵活性。例如list中有自己的sort()函数，专门为list而设计，比::sort()的算法更优。

泛型编程（GP）：

泛型编程是一种编程范式，它允许开发者定义操作类型数据结构的函数和类，而不需要在编译时指定具体的数据类型。这种方法强调了数据和处理方法的分离，提供了更高的代码复用性和类型安全性。

补充说明：GP 通过模板（Templates）或泛型容器（如 std::vector、std::map）来实现，允许开发者写出与数据类型无关的代码，从而在不同的数据类型间共享相同的算法逻辑。例如vector和deque没有为自身设计sort(),在做排序操作时，需要调用::sort()来实现。

## 操作符重载

STL源码程序中会包含很多的操作符重载，一般你会看到operate修饰符，后面就紧跟着操作符。注意：`::`、`.`、`.*`和 `:?`不能进行操作符重载。

在我看来操作符重载是一个重要的特性，它可以让你实现任何类的运算法则，这些法则有你自己规定，操作空间还是比较宽泛。

## 模版-template

最常见的写法如下：
```cpp
    template <typename T>
    class FOO{
        ...
    }
```

### 类模板

最常见的写法如下：
```cpp
    template <class T>
    class FOO{
        ...
    }
```

### 成员模版

### 泛化、特化和偏特化

以我个人的理解，泛化是为了应对大部分的情况，特化是为了应对特殊的情况，或使用单独的方法处理对某些情况而言更好，偏特化比偏特化更近一步，把处理的手段限定在一定范围内，举个简单的例子，假设为设计计算两种情况的相加做如下定义：

1.泛化

泛化编程在C++中通过模板实现。以下是一个泛化编程的示例，其中 AND 类是一个模板类，可以处理任何类型的数据。

```cpp
    template <class T,class U>
    class AND{
        ...
    }
```

2.特化

特化是对模板类或函数的特定实例化。以下是特化的示例，其中 AND 类被特化为处理 string 和 Text 类型：

```cpp
    template <class T, class U>
    class AND {
        // ... 类的泛型实现
    };

    template <>
    class AND<string, Text> {
        // ... 类的特化实现
    };
```

3.偏特化

偏特化允许对模板类的部分参数进行特化。以下是偏特化的示例，其中 AND 类被偏特化为处理第一个类型为 int 的情况：

```cpp
    template <class T, class U>
    class AND {
        // ... 类的泛型实现
    };

    template <class U>
    class AND<int, U> {
        // ... 类的偏特化实现
    };
```

{{% attachments color="fuchsia" icon="fab fa-hackerrank" /%}}